{"title": "微信小程序开发上传图片后缀名为unknow和getImageInfo的orientation不准的问题 ...", "author": "Rolan", "time": "2020-6-1 00:41", "content": "问题1:在云开发的存储中发现一些文件名为unknow，打开开发调试发现小程序chooseMedia拍摄图片后后缀名为unknow。在微信社群里搜索了相关信息官方表示这确实是一个bug。但是官方没有说明下次更新时间，而且这个bug前端也可以稍加修复。只需要判断后缀名是不是自己规定的并且设置一个默认的后缀名即可。getExt: function (filename,defaultExt) {\r\n    if(filename && filename.length > 3) {\r\n      const r = filename.split('').reverse().join(''); // 反转\r\n      const p = r.search(/\\./)\r\n      if(p > 2) {\r\n        // .unknown\r\n        const ext = r.substring(0,p).split('').reverse().join('');\r\n        if(['jpg','jpeg','png','mp4'].includes(ext)) {\r\n          return ext\r\n        }else{\r\n          return defaultExt\r\n        }\r\n      }else{\r\n        return defaultExt\r\n      }\r\n    }else{\r\n      return defaultExt\r\n    }\r\n  },问题2:getImageInfo的orientation不准一开始发现上传的图片很多方向都不对。就想到用canvas旋转一下图片。// 非要和国际标准不一样 不知道怎么想的\r\nconst orientations = {\r\n  up: 1,\r\n  'up-mirrored': 2,\r\n  down: 3,\r\n  'down-mirrored': 4,\r\n  'left-mirrored': 5,\r\n  right: 6,\r\n  'right-mirrored': 7,\r\n  left: 8\r\n}\r\n\r\n\r\nmodule.exports = async function (canvas,ctx,imgs) {\r\n  if(Array.isArray(imgs) && imgs.length) {\r\n\r\n    const tasks = []\r\n    for(const o of imgs) {\r\n      const promise = rotate(canvas,ctx,o).then(res=>{\r\n        return {...o,...res}\r\n      })\r\n      tasks.push(promise)\r\n    }\r\n    return await Promise.all(tasks)\r\n\r\n  }else{\r\n    return null\r\n  }\r\n}\r\n\r\nasync function rotate (canvas,ctx,o) {\r\n  console.log('rotate',canvas,ctx,o)\r\n\r\n\r\n  if(o.orientation === 'up') {\r\n    return {}\r\n  }\r\n\r\n  return await new Promise((resolve)=>{\r\n    const imgObj = canvas.createImage()\r\n    imgObj.src = o.tempFilePath\r\n    //imgObj.width = o.width\r\n    //imgObj.height = o.height\r\n    imgObj.onload = function (e) {\r\n      console.log('imgObj.onload')\r\n      let width = 0;\r\n      let height = 0;\r\n      let deg = 0;\r\n      const orientation = orientations[o.orientation]\r\n      console.log('orientation',orientation)\r\n      // 开始旋转逻辑\r\n      if ([2, 3, 6, 8, 4, 5, 7].includes(orientation)) {\r\n        if (orientation === 3 || orientation === 4) {\r\n          width = o.width;\r\n          height = o.height;\r\n          deg = 180;\r\n        } else if (orientation === 6 || orientation === 5) {\r\n          width = o.height;\r\n          height = o.width;\r\n          deg = 90;\r\n        } else if (orientation === 8 || orientation === 7) {\r\n          width = o.height;\r\n          height = o.width;\r\n          deg = -90;\r\n        }\r\n        // 利用canvas 进行旋转\r\n        canvas.width = width\r\n        canvas.height = height\r\n\r\n        console.log('reset canvas',canvas)\r\n\r\n        // 旋转canvas 并且 把图片放入canvas\r\n        ctx.translate(parseInt(width / 2, 10), parseInt(height / 2, 10));\r\n        if ([2, 4, 5, 7].includes(orientation)) {\r\n          ctx.scale(-1, 1);\r\n        }\r\n        ctx.rotate((deg * Math.PI) / 180);\r\n        ctx.drawImage(\r\n          imgObj,\r\n          0,\r\n          0,\r\n          o.width,\r\n          o.height,\r\n          0 - o.width / 2,\r\n          0 - o.height / 2,\r\n          o.width,\r\n          o.height\r\n        );\r\n\r\n        console.log('drawImage',imgObj)\r\n\r\n        wx.canvasToTempFilePath({\r\n          canvas,\r\n          fileType:'jpg',\r\n          quality: 0.5,\r\n          x: 0,\r\n          y: 0,\r\n          width,\r\n          height,\r\n          destWidth: width,\r\n          destHeight: height,\r\n          success(res) {\r\n            console.log('canvasToTempFilePath',res,width,height)\r\n            resolve({\r\n              width,\r\n              height,\r\n              tempFilePath: res.tempFilePath\r\n            })\r\n          },\r\n          fail(err) {\r\n            console.log('fail err',err)\r\n          },\r\n          complete(res){\r\n            console.log('com res',res)\r\n          },\r\n        })\r\n      }\r\n\r\n    }\r\n\r\n  }).then(res=>{\r\n    console.log('res2',res)\r\n    return res\r\n  })\r\n\r\n}以上是旋转并保持图片为本地临时文件的方法，由于微信开始自己出了一套canvas规则后来又废弃采用web标准版本的canvas，导致API文档新旧规则你中有我，我只有你。看完文档后通常就拿不定用哪一个方法如何开始了。微信自己实现的canvas drawImage 是支持临时文件的，而web标准版本的drawImage支持的是image对象的，在这个地方很多人都被官方带沟里了。当我实现canvas旋转图片后发现getImageInfo的orientation不准，让我无法判断用户选择的图片的orientation，从而导致了无法正确的旋转图片。后来经过各种资料查找发现getImageInfo只能判断原图的方向，知道这个问题就好办了，修改chooseImage文件类型为原图即可。"}
{"title": "小程序实战(二)-上传多图功能", "author": "Rolan", "time": "2020-6-2 00:53", "content": "一、需求说明\r\n\r\n可选取相册照片，可拍照\r\n可选择压缩大小，可选择原图大小\r\n每次最多可选择 5 张图片\r\n\r\n二、需求实现\r\n2.1 选取照片实现\r\n通过调用小程序 api - chooseImage 来实现选取照片功能\r\n// 定义一个变量，用来存储用户选取的图片路径\r\nlet imagePaths\r\nwx.chooseImage({\r\n  count: 5,    // 限制每次最多选择 5 张\r\n  sizeType: ['original', 'compressed'],  // 可选择压缩大小，可选择原图大小\r\n  sourceType: ['album', 'camera'],   // 可选取相册照片，可拍照\r\n  success: res => {   // 选取图片成功的回调函数\r\n    imagePaths = res.tempFilePaths   // 存储选取的图片路径，是个数组\r\n  }\r\n})\r\n复制代码2.2 上传照片实现\r\n// 定义一个变量，用来存储上传成功的图片路径\r\nlet successPaths = []\r\n// wx.uploadFile 接口只能一次上传 1 张图片，所以需要先遍历\r\nimagePaths.forEach((path) => {\r\n  wx.uploadFile({\r\n    url: api.apiRootUrl + '/distribution/addPicture',   // 接口地址\r\n    filePath: path,\t// 当前图片路径\r\n    name: 'file',\r\n    header: { \"Content-Type\": \"multipart/form-data\" }, \r\n    success: res => {\t\t\t\t\t// 上传成功的回调函数\r\n      if (res.code == 200) {\r\n        successPaths.push(res.filePath)\r\n      } else {\r\n        this.showToast({\r\n\t\t\ttitle: res.msg\r\n\t\t  })\r\n      }\r\n      let filePaths = `formData.filePaths`\r\n\t\t// 存储上传成功的图片路径\r\n      this.setData({\r\n        [filePaths]: successPaths\r\n      })\r\n    }\r\n  })\r\n})\r\n复制代码2.3 图片预览实现\r\n<view wx:for=\"{{formData.filePaths}}\" wx:key=\"filePath\">\r\n\t<image src=\"{{filePath}}\"></image>\r\n</view>\r\n复制代码"}
{"title": "小程序工程化-环境变量配置管理", "author": "Rolan", "time": "2020-6-3 00:11", "content": "引言\r\n我们在项目开发的过程中，会把环境分为开发环境、测试环境、生产环境等，社区里也有很多类似cross-env环境管理工具。但是在小程序的生态环境中，并没有成熟的解决方案来管理环境变量，开发者往往需要自己手动维护一些项目配置信息，这样做虽然没什么问题，但是随着项目的增大，要维护的配置信息可能会越来越多，我们很难保证不出错。下面我们将利用node的一些知识实现简单的环境变量配置管理。\r\n建立配置文件\r\n首先我们在项目根目录新建一个config文件夹，并在config文件夹下分别建立env/dev.json和env/prod.json等若干不同环境配置文件。分别放置该环境的配置信息，例如\r\n    // config/env/dev.json\r\n    {      \r\n        \"environment\":\"development\",\r\n        \"defaultURL\": \"https://dev.xxx.com/api/\"\r\n    }\r\n复制代码然后我们在根目录建立一个放置默认配置的projectConfig.js文件,并把它引入到app.js\r\n    // projectConfig.js\r\n    module.exports ={\r\n        \"projectname\": \"xxx\",\r\n    }\r\n    \r\n    // app.js\r\n    const config = require('./projectConfig')\r\n    App({\r\n        ...,\r\n        globalData: {\r\n         ...config\r\n        }\r\n    })\r\n复制代码这样子就完成了第一步：把配置信息引入到了我们的项目中。\r\n根据命令行，选择对应的env下的配置文件\r\n接下来在我们项目的package.json里scripts增加两条命令行,用来启动不同的环境\r\n    \"scripts\": {\r\n        \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\r\n        \"switch:dev\": \"node switch.js --dev\",\r\n        \"switch:prod\": \"node switch.js --prod\"\r\n    }\r\n复制代码在根目录建立switch.js，利用node.js处理配置信息\r\n/**\r\n * 根据命令行运行参数，修改/config.js 里面的项目配置信息，\r\n */\r\n\r\nconst fs = require('fs')\r\nconst path = require('path')\r\n//源文件\r\nconst sourceFiles = {\r\n  prefix: '/config/env/',\r\n  dev: 'dev.json',\r\n  prod: 'prod.json'\r\n}\r\n//目标文件\r\nconst targetFiles = [{\r\n  prefix: '/',\r\n  filename: 'projectConfig.js'\r\n}]\r\nconst preText = 'module.exports = '\r\n// 获取命令行参数\r\nconst cliArgs = process.argv.splice(2)\r\nconst env = cliArgs[0]\r\n// 判断是否是 prod 环境\r\nconst isProd = env.indexOf('prod') > -1 ? true : false\r\n// 根据不同环境选择不同的源文件\r\nconst sourceFile = isProd ? sourceFiles.prod : sourceFiles.dev\r\n// 根据不同环境处理数据\r\nfs.readFile(__dirname + sourceFiles.prefix + sourceFile,\r\n  (err, data) => {\r\n    if (err) {\r\n      throw new Error(`Error occurs when reading file ${sourceFile}.\\nError detail: ${err}`)\r\n      process.exit(1)\r\n    }\r\n    // 获取源文件中的内容\r\n    const targetConfig = JSON.parse(data)\r\n    // 将获取的内容写入到目标文件中\r\n    targetFiles.forEach(function(item, index) {\r\n      let result = null\r\n      if (item.filename === 'config.js') {\r\n        result = preText + JSON.stringify(targetConfig, null, 2)\r\n      }\r\n      console.log(result)\r\n      // 写入文件(这里只做简单的强制替换整个文件的内容)\r\n      fs.writeFile(__dirname + item.prefix + item.filename, result, 'utf8', (err) => {\r\n        if (err) {\r\n          throw new Error(`error occurs when reading file ${sourceFile}. Error detail: ${err}`)\r\n          process.exit(1)\r\n        }\r\n      })\r\n    })\r\n  })\r\n复制代码这样子当我们输入不同的命令行，动态的将相应环境配置信息写入默认配置文件，并引入到项目中。\r\n\r\n与开发者工具关联\r\n每次切换环境都要自己运行npm脚本，也会有点不方便，这个时候我们可以配置开发者工具\r\n在开发者工具的本地设置中，勾选启用自定义处理命令，并分别在编译前预处理和上传前预处理填入我们的命令\r\n\r\n这样子就保证了开发环境和生产环境隔离，避免产生脏数据。\r\n写在最后\r\n欢迎大家关注我的公众号：前端Readhub 。"}
{"title": "腾讯开心鼠英语 小程序实践与总结", "author": "Rolan", "time": "2020-6-3 00:34", "content": "腾讯开心鼠英语 团队中有很多小程序的项目，且后续还会很多小程序的开发和迭代规划，因此我们团队是小程序的重度使用者。在小程序的开发中，团队积累了一些技术和经验，也遇到了一些困难和挑战，还踩了很多坑，因此有必要将我们团队的小程序实践进行总结和分享。一、工程化探索微信小程序的开发规范里，有一些工程方面的要求，例如可以通过项目的配置文件来设置根目录，每个页面或组件需要wxml、js、json、wxss 4个文件组成等，于此同时微信的开发者工具可以帮忙初始化项目，并设置好目录结构。除此之外对于项目工程方面的支持就比较薄弱了。为了提升团队的开发效率和质量，我们还需要在已有的基础之上进行一些列的优化。我们希望小程序的开发脚手架至少具备以下的能力：css预处理语言支持，可以使用例如sass、postcss等开发样式；typescript支持，可以更好地使用typescript进行开发；更好的目录结构设计；更好的npm包支持；代码检验支持，可以使用eslint/tslint、stylelint等对代码进行规制校验；因为现阶段的小程序开发的工程需求主要集中在文件编译和资源整理上，小程序开发者工具会帮我们处理文件打包，因此我们考虑使用gulp去搭建工程脚手架。1. 目录结构设计微信小程序的代码主要由4个放置在同一目录下的文件构成：.json 后缀的  JSON 配置文件；.wxml 后缀的  WXML 模板文件；.wxss 后缀的  WXSS 样式文件；.js 后缀的  JS 脚本逻辑文件；微信开发者工具会对以上的文件进行监听，当其中任意一个文件发生改变时，开发者工具就会刷新预览。如果使用ts进行开发，那在同一目录下，还将多出ts文件；如果参考这种方式引入css的预编译语言，那还会再多出一个待编译的样式文件。这样一个页面或组件的目录下，就至少会存在6个文件，显得非常臃肿，不仅降低了文件查找的效率，还有可能带来其他的误操作。因此这样的目录结构就不足以支撑我们后续开发的工程化要求。我们希望将源文件和编译文件分离，只保留基本的4种类型文件，当源文件发生改变时，就触发编译，将其编译成对应的开发者工具可以监听的文件类型。因此设计了以下新的目录结构：src 目录下存放项目的源文件，使用gulp监听文件的变化，并触发对应的编译任务，将源文件编译为目标文件，或者拷贝不需要编译的文件到目标目录（dist文件夹），然后在project.config.json里指定小程序的根目录为dist文件夹，这样开发者工具就会去监听dist目录里的文件变化并更新预览了。通过这样的设计，整个目录结构更加清晰，开发者只需要关注src目录即可。当然在实践的过程中，这样的目录结构也存在一定的问题：从文件变化到最后开发者工具更新预览的整个链路变长了，有一定的时间上的损耗；因为整个链路变长，也加大了引入其他问题的可能；因为一些历史原因，团队一些老的项目还没有完全按照这样的目录结构去设计，团队中的小程序项目目录结构还没有完全统一；以上的问题还需要我们团队在后续的开发中去解决和优化。2. css预处理语言支持微信小程序的样式代码主要是编写在wxss文件中，其语法和css是一样的，只有少量的css规则不适用。如果只是编写css样式，那只写wxss是完全没问题的。但是现在市面上还是有很多流行的css预处理语言可以帮助更好地开发css样式，提供了例如mixins、function、变量等功能。因此我们希望编写css预处理语言，并将其编译成wxss文件。我们团队使用的是postcss。源文件编写的是css文件，通过设置gulp task的方式，将css编译成wxss。并通过postcss插件的方式，集成更多的其他功能。在实践过程中，我们发现当项目规模开始变大时，在有些机器上，修改一次样式文件后触发更新的速度很慢，这个时候我们就引入cache去加速css的编译。第一次编译时会将所有的css编译，而后只会去编译修改过的文件。代码如下：/** * 将 css 编译成 wxss */const cssCompile = () =>  src([`${mpDir}/**/*.css`, `!${mpDir}/**/_*.css`])    .pipe(cache('css-compile'))    .pipe(      // 防止编译中断      postcss().on('error', () => {        this.emit('end');      })    )    // 去掉编译出来的 :root{}    .pipe(replace(/:root\\s\\{[^}]*\\}?\\s*/, ''))    .pipe(      rename((path) => {        path.extname = '.wxss';      })    )    .pipe(dest((file) => file.base));3. typescript支持原先的微信小程序对ts文件的支持，是通过预置编译脚本，使用 tsc 去编译ts文件的。我们的项目引入了gulp之后，对ts的支持就是通过设置gulp task，使用gulp-typescript 这个插件去编译ts文件，同时还需要使用gulp-sourcemaps这个插件去写入sourcemap。在实践过程中，我们发现有的时候ts的文件编译比较慢，这个时候可以使用gulp-typescript提供的增量编译的功能。开启增量编译之后，第一次编译时的速度是一样的，而之后的编译速度就会提升约50%。代码如下：const tsProject = ts.createProject(\"tsconfig.json\");// 编译 tsconst tsCompile = () =>  gulp    .src(tsPath)    .pipe(sourcemaps.init())    .pipe(      /* 增量编译 */      tsProject()    )    .js.pipe(sourcemaps.write())    .pipe(gulp.dest(dist));4. 更好的npm包支持微信小程序是支持使用npm包的，但是这个支持是有一些前提条件的。例如当引入某个包时：import { abcRequest } from '@tencent/abcmouse-sdk-mp-tools';小程序会去根目录下的miniprogram_npm这个文件夹下查找有没有@tencent/abcemouse-sdk-mp-tools这个包，如果没有则会提示找不到对应的包。而miniprogram_npm又是根据package.json里的dependencies字段里声明的依赖构建而成的。因此微信小程序要使用npm包的前提总结如下：必须在package.json的dependencies字段里有声明 ；小程序的根目录下必须有node_modules目录，其目录里有对应的包；必须构建出miniprogram_npm；因此要想使用npm包，整个过程是比较波折的。好在小程序官方有提供对应的ci构建可以帮助我们。但在实践过程中发现，调用ci.packNpmManually这个接口构建出来的miniprogram_npm目录，不仅包含了dependencies里的依赖，还包含了其他的依赖，而miniprogram_npm这个目录里的代码在上传小程序代码时也是会上传的，引入其他多余的依赖会增大小程序的包体积，在小程序严格的代码大小要求下，这是不可取的。因此还需要对构建的包进行筛选。其大致流程如下：使用gulp监听package.json文件，当安装新的npm包，并指定 --save 时，package.json文件会发生变化，并触发对应的gulp task。在gulp task里去遍历package.json的denpendcies字段，并从顶层目录的node_modules里拷贝对应的npm包放入dist目录的node_modules中。最后再通过ci.packNpmManually方法去构建，这个时候构建出来的miniprogram_npm目录里就只有必须的npm包了。通过这种方式，我们需要使用新的npm包时，就只需要npm install并在代码中import就可以了，其他的处理过程对开发者来说都是无感知的。相应的gulp task代码如下：/** * 在小程序根目录下生成package.json文件用于构建miniprogram_npm * @param {Array<string>} deps denpendencies对象 */const generateSubPkg = (deps) =>     writeJsonFile(subPkgPath, { dependencies: deps })    .then(() => deps);/** * 获取必要的npm包目录路径 * @param {Array<string>} deps 依赖数组 */const getDepsModule = (deps) =>     Object.keys(deps).map((key) => `node_modules/${key}`);/** * 构建miniprogram_npm * @param {Array<string>} modules npm包路径数组 */const packNpmManually = (modules) => {  const packPath = `${mpDir}/miniprogram_npm`;  const subNpmPath = `${mpDir}/node_modules`;  fsx.emptyDirSync(packPath);  fsx.emptyDirSync(subNpmPath);  modules.forEach((modulePath) => {    fsx.copySync(modulePath, `${mpDir}/${modulePath}`);  });  return ci.packNpmManually({    packageJsonPath: path.resolve(process.cwd(), subPkgPath),    miniprogramNpmDistDir: path.resolve(process.cwd(), mpDir),  });};/** * 构建miniprogram_npm gulp plugin */const packPkgManually = () =>  through.obj(function (chunk, enc, cb) {    const filepath = path.resolve(process.cwd(), 'package.json');    if (!fsx.pathExists(filepath)) {      cb(null, chunk);    }    const pkgData = fsx.readJSONSync(filepath);    const dependencies = pkgData.dependencies || {};    // denpendencies 没有发生变动则不需要构建    if (isEqual(cached, dependencies) || packing) {      cb(null, chunk);    }    const spinner = ora('开始构建npm包...').start();    packing = true;    generateSubPkg(dependencies)      .then(getDepsModule)      .then(packNpmManually)      .then((result) => {        cached = dependencies;        spinner.succeed('构建成功，构建结果:');        packing = false;        console.log(result);        cb(null, chunk);      })      .catch((err) => {        spinner.fail('构建失败');        packing = false;        console.error(err);      });  });const pkgPack = () => src(pkgPath).pipe(packPkgManually());const pkgWatch = () => {  watch(pkgPath, pkgPack);};5. 代码校验我们团队还接入了imweb团队的eslint和stylelint规则去做代码校验，这里就不具体暂开讲了，感兴趣的可以参考：eslint-config [ 1 ]；stylelint-config [ 2   ] ；6. 后续展望其实在小程序的工程化这一块还有很多工作可以做，例如：当项目体积变大时，小程序开发者工具的刷新预览速度变慢，除了等待小程序官方的优化之外，是否可以通过工程化的手段，提升开发者工具的预览刷新速度；合理的分包可以提升小程序的加载速度，是否可以通过工程化的手段，将项目中用到的通用组件，智能合理地分配到主包和子包中；引入命令行工具生成页面和组件的文件模板；尝试引入tree-shaking剔除无用的代码；尝试引入purifycss剔除无用的样式；集成官方的ci工具，完善开发体验；...我们团队会继续在小程序工程化方面进行探索和尝试，如果有新的成果我们也会及时分享。二、性能优化因为微信小程序是运行在微信app里的，所以其运行环境是比较苛刻的，因此要想使小程序流畅地运行，提供良好的用户体验，对其进行性能优化就至关重要。对于小程序优化来说，一些传统的前端优化方案也适用于小程序。而其双线程的设计模式，又和传统前端的单线程有所不同，因此也有一些新的优化点，下面主要从几个大的方面归纳总结：加快网络请求 ；加快页面渲染；提升渲染性能 ；内存优化 ；其他优化。1. 加快网络请求1.1 减小代码包大小小程序在冷启动时，会首先下载对应的代码包，然后解压执行代码，所以减小包大小可以加快代码下载和解压的速度。一些方法可以减小代码包的大小：代码复用，尽量将可以复用的代码提取封装做出npm包或通用函数；剔除无用的样式，可以使用类似 purifycss的库将无用的css样式剔除以减小样式代码的大小；剔除无用的函数，可以尝试引入tree-shaking剔除无用的代码；静态资源走cdn，尽量不要将静态资源打包到代码中；分包，可以将一些和首页渲染无关的代码分发到子包中从而加快主包的下载和执行。1.2 预请求数据预拉取：小程序提供了一个接口，可以让用户在进入到小程序之前就去请求接口，当然这个方法有一定的限制，需要深入调研和谨慎使用；分包预下载：可以配置进入某个页面时下载可能会用到的分包，可以有效避免进入某些页面”白屏“时间过长。1.3 缓存没有什么请求比不请求更快的了，合理利用缓存可以有效减少网络请求的数量，加快整体的加载速度。对于一些实时性不高的数据，我们可以利用微信提供的缓存能力，将一些数据存储在本地，从而避免一些网络请求。1.4 图片优化webp格式图片；图片剪裁和降质；图片懒加载和雪碧图；渐进式加载大图资源：在不得不使用大图资源的场景下，可以适当使用“体验换速度”的措施来提升渲染性能。小程序会把已加载的静态资源缓存在本地，因此，对于大图资源，我们可以先呈现高度压缩的模糊图片，同时利用一个隐藏的 <image> 节点来加载原图，待原图加载完成后再转移到真实节点上渲染。整个流程，从视觉上会感知到图片从模糊到高清的过程，但与对首屏渲染的提升效果相比，这点体验落差是可以接受的。2. 加快页面渲染其实小程序的页面渲染的优化思路和传统前端的优化思路是一致的，主要思想是： 关键渲染路径渲染 ；关键渲染路径（Critical Rendering Path）是指完成屏幕渲染的过程中必须发生的事件。我们可以分析页面上哪些部分是主要模块，哪些部分是次要模块，例如一些提示性的组件，我们可以稍后渲染。于此同时，还可以在主要模块中还可以优先渲染主屏模块，不在主屏内的模块可以延迟加载或者滚动加载。3. 提升渲染性能提升渲染性能可以有效减少交互时的卡顿，让用户在交互的时候体验”如丝般流畅“。小程序采用的双线程模型，即渲染和逻辑分散在两个不同的线程中。所以在小程序的环境下，加快用户响应主要从以下3点出发：降低线程之间的通信频次；减少线程之间通信的数据量；减少wxml的节点数量。可以采用的办法有：合并setData调用；只把与界面渲染相关的数据放在data中；去掉不必要的事件绑定；去掉不必要的节点数据；事件总线管理数据；滚动渲染长列表节点；...4. 内存优化因为小程序毕竟是一个程序（微信）中的程序，可提供给其运行的环境资源是十分有限的，这对于小程序的设计和开发来说就比较苛刻了，因此要在实现的时候小心翼翼。可以从以下几个方面注意内存的优化：内存预警；回收后台页面计时器；避免触发事件中的重度内存操作；大图、长列表优化。5. 其他优化还可以采用一些其他的方式来对小程序进行优化：逻辑后移：可以让后台承担更多的业务实现。小程序端主要承担展示相关的职责，这样可以避免在小程序端进行过多的数据操作，占用过多的内存。也可以避免因为复制的业务实现而带来的潜在的程序崩溃；骨架屏：可以利用骨架屏来提升整体的加载体验。最后总结输出一下小程序性能优化相关的脑图如下：三、自动化探索1. 自动化测试小程序官方提供了自动化地工具去模拟小程序的操作，搭配常用的测试框架，可以很容易地实现小程序的前端测试。小程序的模拟器提供了4个级别的操作api：模拟器级别的 AutoMator；小程序级别的 MiniProgram；页面级别的 Page；元素级别的 Element。我们可以利用这几个api对象去模拟小程序的行为，例如模拟元素点击、页面数据修改、页面跳转等操作。具体api可以参考：小程序自动化工具 [ 3 ]。在实践接入的过程中遇到了一些坑。要想使用小程序模拟器是有一些前提条件的，首先是要开启开发者工具安全设置中的 CLI/HTTP 调用功能。并通过以下代码开启调用：automator.launch({  cliPath: 'path/to/cli', // 工具 cli 位置  projectPath: 'path/to/project', // 项目文件地址})其中 cliPath 是我们的开发者工具的文件路径，如果没有更改过默认安装的位置则可以忽略。projectPath是项目目录的地址，这里的项目目录指的是project.config.json里指定的目录，而且这个路径必须是绝对路径才可以调用成功。其次小程序的模拟器是有一些使用限制的，它不能调用和操作微信系统的原生组件的，例如授权、位置、支付等功能。当我们希望利用脚本去测试整个页面的流程时，当涉及到授权和支付等操作时，往往就跑不下去，因此小程序的模拟器更适合去做一些关键操作的测试，例如测试某些操作之后，页面的样式、行为是否符合预期。2. CI接入小程序的代码打包、上传等功能可以交由CI来操作。我们团队主要使用蓝盾CI，配合蓝盾上的小程序插件，可以很轻松地接入，其流程比较简单，主要是拉取代码、安装依赖和构建上传。蓝盾流水线如下：小程序代码上传需要用到秘钥，我们可以将其秘钥托管在蓝盾，即方便又安全。References[1] eslint-config:  https://github.com/imweb/eslint-config-imweb[2] stylelint-config:  https://github.com/imweb/stylelint-config-imweb[3] 小程序自动化工具:  https://developers.weixin.qq.com/miniprogram/dev/devtools/auto/"}
{"title": "Taro 1.0系列：taro build原理分析", "author": "Rolan", "time": "2020-6-3 00:51", "content": "众所周知， taro-cli 是Taro脚手架初始化和项目构建的的命令行工具，它的实现原理，相信大家从 Taro 技术揭秘：taro-cli 这篇文章中已经有所了解；本文将对其中的项目构建 build 命令进行分析，从 cli 层面了解 taro 构建的过程到底做了什么；build命令的注册在执行 npm install -g @tarojs/cli 时， npm 通过读取 package.json 文件中的 bin 字段，将 taro 这个命令注册到 [prefix]/bin 中作为全局命令；如果在当前项目目录下，执行 npm install @tarojs/cli ，则会将taro这个命令注册到 ./node_modules/.bin/ 底下作为本地命令；// package.json\r\n\"bin\": {\r\n  \"taro\": \"bin/taro\"\r\n}由于 npm config get prefix 为 /usr/local ，所以全局命令将会被注册到 /usr/local 目录底下，通过 symlink 符号链接的方式，使得 /usr/local/bin/taro 指向 /usr/local/lib/node_modules/@tarojs/cli/bin/taro ；bin/taro 文件作为 taro-cli 的入口，内部使用 commander.js 来解析命令中的参数，并且支持 git 风格的子命令处理，可以根据子命令自动引导到 [command]-[subcommand] 格式命名的执行文件；所以当执行 taro build 命令时，则被 commander.js 自动引导到 bin/taro-build 文件下，继而执行 bin/taro-build 的逻辑；build命令的分发taro build 命令功能非常多，它能够支持：1、构建 H5 ；taro build --type h52、构建小程序及小程序插件，支持 weapp/swan/alipay/tt/qq/jd 类型；// 小程序\r\ntaro build --type weapp\r\n// 小程序插件\r\ntaro build --plugin weapp3、构建UI库；cross-env TARO_BUILD_TYPE=component taro build --uitaro-build 接收 --type 参数的值，接收到的结果交由 dist/build.js 的 build 函数进行判断，通过判断不同 type 的值，决定执行对应平台构建类型的逻辑，例如，当 --type 为 h5 时，则执行 dist/h5/index.js 文件中 build 函数的逻辑；当 --type 为 weapp 时，则执行 dist/mini/index.js 文件中 build 逻辑；h5的构建逻辑h5 的构建流程主要经过： 源代码 => 中间代码 => 目标代码 的转换； 其中：源代码：一般是指 src 目录底下的代码，如果 config 中有配置 sourceRoot ，则源代码入口就为 sourceRoot ；中间代码：指 .temp 目录下的代码，由 taro-build 实现的中间流程，主要通过 babel 实现中间代码的转换和生成；目标代码：指最终运行在浏览器的代码，一般指 dist 目录下的代码，如果 config 中配置 outputRoot ，则目标代码将输出在 outputRoot ；所以，三种代码间的转换关系可以用下图表示：taro-build 帮助将源代码转换成中间代码，并保存在 .temp 文件夹中，中间代码再交由 webpack 进行打包构建生成目标代码；中间代码的生成为什么会有中间代码生成这个步骤呢，这是因为：直接将 源代码 交由 webpack 进行编译，会出现部分方法的缺失、页面无法找到等的问题；Taro 需要根据构建平台的类型进行一系列的 转换 ，并导入对应平台的核心包；还需要根据工程或者页面的 config 对 源代码 进行转换，并插入一些 关键代码 ；中间代码的生成流程需要转换的代码主要以 src 目录下的代码为主，而且只分析和转换js和ts的文件，因为涉及到代码的分析，所以借助了 babel 工具链，例如 babel-core 、 babel-traverse 、 babel-types 和 babel-template 等核心包中的方法进行处理，主要流程如下：1、区分是否为 js或ts ，是则进行分析，否则直接复制；2、分析文件是否为 ENTRY文件 ， PAGE文件 ， NORMAL文件 ，分类完成，则交由对应的处理函数进行处理；3、处理解析 ENTRY文件 ；4、处理解析 PAGE文件 和 NORMAL文件 ；5、处理完后的代码生成到 .temp 文件夹中；6、调用 webpack-runner ，对 .temp 文件的代码进行处理，生成到 dist 文件夹中；ENTRY文件的分析ENTRY类型 的文件，由 processEntry 函数处理，通过 babel-traverse 中的traverse方法对不同类型的AST节点进行分析，其中涉及到很多细节，主要流程如下：1、解析 config 这个 ClassProperty 节点的内容，获取 pages 和 subPages ;2、依赖纠正：主要转换 tarojs/taro 、 tarojs/mobx 、 tarojs/redux 相关依赖为 tarojs/taro-h5 、 tarojs/mobx-h5 、 tarojs/redux-h5 ；转换 ImportDeclaration 节点中的 alias 别名；引入 Nervjs 核心包；3、在 render 函数中，加入页面的 Router 组件(根据 pages 和 subPages )， Provider 组件， Tabbar 组件；4、引入 taro-router 相关代码；PAGE文件和NORMAL文件的分析PAGE类型 和 NORMAL类型 的文件，由 processOthers 函数处理，也是通过 babel-traverse 中的traverse方法对不同类型的AST节点进行分析，这里只列出主要流程：1、依赖纠正：主要转换 tarojs/taro 、 tarojs/mobx 、 tarojs/redux 相关依赖为 tarojs/taro-h5 、 tarojs/mobx-h5 、 tarojs/redux-h5 ；转换 ImportDeclaration 节点中的 alias 别名；引入 Nervjs 核心包；2、解析 config 这个 ClassProperty 节点的内容，获取配置项，对页面添加相关的组件和函数，例如 PullDownRefresh 组件和 onPageScroll 方法;3、导出纠正：当前类的 nameExport 纠正为 defaultExport ，例如：当前文件 page-index.js// 纠正前\r\nexport class PageIndex extends Component {\r\n  ...\r\n}\r\n\r\n// 纠正后\r\nclass PageIndex extends Component {\r\n  ...\r\n}\r\n\r\nexport default PageIndex;4、声明纠正：当前 ClassExpression 或 ClassDeclaration 中，在没有 identifier 的情况下，添加默认的 identifier 为 _TaroComponentClass ：// 纠正前\r\nexport default class extends Component {\r\n  ...\r\n}\r\n\r\n// 纠正后\r\nexport default class _TaroComponentClass extends Component {\r\n  ...\r\n}webpack-runner逻辑中间代码生成后，缓存在 .temp 文件夹底下，并且作为 webpack-runner 的入口文件， taro-build 在完成 buildTemp 的流程后，就会继续执行调用 webpack-runner 的逻辑； webpack-runner 的逻辑实际上就是根据定义好的 webpack 的配置，生成目标代码的流程，后面将会有单独的一篇文章详述相关配置，这里不做再多的描述；小程序的构建逻辑taro-build 的小程序构建逻辑不存在中间代码的生成，而是直接由 源代码 生成小程序能运行的 目标代码 ；这里的源代码是指遵循 React 规范的taro代码，这种代码在小程序的容器中是无法直接运行的，所以需要通过 taro-build转换 成小程序可运行的代码，因此在这个流程中涉及大量的 AST语法解析和转换 ；小程序的构建流程主要分三步完成(当然这里还有很多细节，但本文暂不详细阐述)：构建入口：指构建 sourceDir 指定的文件，默认是 app.jsx 文件，构建的逻辑由 buildEntry 函数完成；构建页面：指构建在 app.jsx 文件中的 config.pages 配置好的页面文件，主要由 buildPages 函数完成；构建组件：指构建页面文件中依赖的组件，主要由 buildSingleComponent 函数完成；构建流程需要依赖 taro-transformer-wx 包去解析 JSX 语法，已经对源代码的 AST语法树 ，进行代码插入和转换；buildEntry逻辑构建入口的逻辑大概如下：1、调用 taro-transformer-wx 中的 wxTransformer 方法转换 JSX语法 ；2、将 app.jsx 中的 es6 语法通过 babel 转换为 es5 ，并且引入 taro-weapp 核心包；3、通过AST转换，插入调用 taro-weapp 包中 createApp 函数的语句；4、生成 app.json 、 app.js 、 app.wxss 文件；buildPages逻辑构建页面的逻辑大概如下：1、调用 taro-transformer-wx 中的 wxTransformer 方法转换 JSX语法 ；2、将页面js中的 es6 语法通过 babel 转换为 es5 ，并且引入 taro-weapp 核心包；3、通过AST转换，插入调用 taro-weapp 包中 createComponent 函数的语句；4、编译页面所依赖的组件文件，由 buildDepComponents 函数实现；5、生成页面对应的 page.json 、 page.js 、 page.wxss 、 page.wxml 文件；buildComponent逻辑构建组件与构建页面类似，但多了递归的步骤，其逻辑大概如下：1、调用 taro-transformer-wx 中的 wxTransformer 方法转换 JSX语法 ；2、将组件js中的 es6 语法通过 babel 转换为 es5 ，并且引入 taro-weapp 核心包；3、通过AST转换，插入调用 taro-weapp 包中 createComponent 函数的语句；4、 递归 编译组件所依赖的组件文件，由 buildDepComponents 函数实现；5、生成页面对应的 page.json 、 page.js 、 page.wxss 、 page.wxml 文件；taro-transformer-wxtaro 将 JSX 解析到小程序模板的逻辑，单独拆成一个包 taro-transformer-wx ，里面涉及到大量的AST解析和转换，本文由于篇幅的关系，暂时不详细分析，希望后面会有单独的文章去分析 小程序AST转换的流程 ，敬请期待；结语总的来说，从 cli 层面去看taro的构建流程，会发现为了兼容多平台，taro会使用较多的 AST解析和转换 ，帮助将 React 规范的taro代码转换到对应平台能够运行的代码；这里也告诉我们，作为一个前端er，学习和掌握 AST 相关知识，能让你看到更大的世界！最后，本文作为一篇原理分析的文章，如有疏漏以及错误，欢迎大家批评指正！"}
{"title": "小程序实战(三)-生成二维码海报", "author": "Rolan", "time": "2020-6-3 00:52", "content": "一、需求说明\r\n\r\n点击生成海报\r\n海报有二维码\r\n点击保存 可将海报保存到手机相册\r\n\r\n二、需求实现\r\n2.1 总体实现方式\r\n这个需求的核心路径就是：\r\n获取到图片路径 -> 使用 canvas 画图 -> 将 canvas 画布转换为 url -> 将该图片存储到手机相册\r\n其中，各个步骤的实现方式如下：\r\n\r\n\r\n获取到图片路径：\r\n若是本地图片，可直接使用相对路径，如 '/images/poster-bg.png'\r\n若是网络图片，或接口返回的图片，则需要先将图片下载到本地，获取到图片的路径，再使用。可使用 wx.getImageInfo实现\r\n\r\n\r\n使用 canvas 画图：\r\n在小程序中使用 canvas 与在正常 web 项目中不同。\r\n正常项目中这样使用：\r\n\r\n\r\n<canvas id=\"canvas-container\"></canvas>\r\n复制代码let canvas = document.getElementById('canvas-container')\r\nlet ctx = canvas.getContext()\r\n// 接下来使用 ctx 的 api 进行绘图\r\n复制代码而在小程序中，是无法直接使用 document.getElementById 这样的 api 操控 dom。因此，需要使用小程序专门提供的 api，用法如下：\r\n<canvas canvas-id=\"canvas-container\"></canvas>\r\n复制代码let ctx = wx.createCanvasContext('canvas-container')\r\n// 接下来使用 ctx 的 api 进行绘图\r\n复制代码\r\n\r\n将 canvas 画布转换为 url\r\n使用微信提供的 api，将完成的画布转换为 url：wx.canvasToTempFilePath\r\n\r\n\r\n将该图片存储到手机相册\r\n使用微信提供的 api，将图片保存在手机相册：wx.saveImageToPhotosAlbum\r\n2.1 获取到图片路径\r\n\r\n\r\n海报背景图\r\n背景图片直接放进了代码的静态资源文件夹里。直接使用相对路径即可\r\n\r\n\r\n二维码\r\n二维码需要调用后端接口获得，并下载到本地获取临时路径。\r\n调接口获取二维码路径并保存：\r\n\r\n\r\ngetPosterImage() {\r\n\twx.showLoading({\r\n    title: '正在制作海报。。。'\r\n  })\r\n\tlet that = this\r\n\tpost(api.getQRImage).then(res => {\r\n\t  this.setData({\r\n\t    qrImageUrl: res.path\r\n\t  })\r\n\t  this.getImageInfo()\r\n\t})\r\n}\r\n复制代码由于网络图片或接口返回图片，无法直接使用，需要下载到本地获取临时路径：\r\ngetImageInfo() {\r\n\tlet that = this\r\n\twx.getImageInfo({\r\n\t\tsrc: this.data.qrImageUrl,\r\n\t\tsuccess: res => {\r\n\t\t\tthat.drawPoster(res.path)\r\n\t\t}\r\n\t})\r\n}\r\n复制代码2.2 使用 canvas 画图\r\n\r\n增加 canvas 标签，设置为不可见\r\n\r\n<!-- 通过 isShowPoster 控制画布是否显示 -->\r\n<!-- 设置画布宽高 -->\r\n<canvas canvas-id=\"poster-canvas\" class=\"{{isShowPoster ? '' : 'no-display'}}\" style=\"width:{{windowWidth}}px;height:{{posterHeight}}px;\"></canvas>\r\n\r\n<!-- 保存海报按钮，通过 isShowPoster 控制是否显示 -->\r\n<button class=\"{{isShowPoster ? '' : 'no-display'}}\" bindtap=\"handleSavePoster\">保存海报</button>\r\n复制代码\r\n通过屏幕尺寸计算画布尺寸：\r\n\r\nonLoad: function (options) {\r\n\t  // poster 的宽和高依据拿到的背景图宽高为准\r\n    const poster = {\r\n      \"with\": 375,\r\n      \"height\": 587\r\n    }\r\n\t  // 获取设备宽高信息 画布宽度等于屏幕宽度，画布高度按比例计算\r\n    const systemInfo = wx.getSystemInfoSync()\r\n    let windowWidth = systemInfo.windowWidth \r\n    let windowHeight = systemInfo.windowHeight\r\n    let posterHeight = parseInt((windowWidth / poster.with) * poster.height)\r\n    this.setData({\r\n      windowWidth: windowWidth,\r\n      posterHeight: posterHeight\r\n    })\r\n  }\r\n复制代码\r\n获取 canvas context 实例：\r\n\r\n<canvas canvas-id=\"canvas-container\"></canvas>\r\n复制代码drawPoster() {\r\n\tlet ctx = wx.createCanvasContext('canvas-container')\r\n}\r\n复制代码\r\n使用 ctx 实例的 api 绘图：\r\n\r\ndrawPoster() {\r\n\tlet windowWidth = this.data.windowWidth\r\n  let posterHeight = this.data.posterHeight\r\n\tlet ctx = wx.createCanvasContext('canvas-container')\r\n\t// 绘制背景图\r\n\tctx.drawImage(this.data.backgroundUrl, 0, 0, windowWidth, posterHeight, 0, 0);\r\n\t// 绘制二维码 \r\n\t// x坐标为 (画布宽度 - 二维码宽度) / 2\r\n\t// y坐标为 (画布高度 - 二维码高度 - 底部距离) \r\n  ctx.drawImage(this.data.qrImageUrl, (windowWidth - 60) / 2, posterHeight - 70, 60, 60, 0, 0);\r\n\t// 绘图\r\n\tctx.draw()\r\n\r\n\t// 将画布设置为可见\r\n\tthis.setData({\r\n  \tisShowPoster: true\r\n\t})\r\n\twx.hideLoading()\r\n}\r\n复制代码2.3 将 canvas 画布转换为 url\r\nhandleSavePoster() {\r\n    wx.showLoading({\r\n      title: '正在保存海报。。。'\r\n    })\r\n    let that = this\r\n    setTimeout(function() {\r\n      wx.canvasToTempFilePath({\r\n        x: 0,\r\n        y: 0,\r\n        width: that.data.windowWidth,\r\n        height: that.data.posterHeight,\r\n        destWidth: that.data.windowWidth,\r\n        destHeight: that.data.posterHeight,\r\n        canvasId: 'poster-canvas',\r\n        success: function (res) {\r\n          that.setData({\r\n            posterUrl: res.tempFilePath,\r\n          })\r\n          that.saveImageToAlbum()\r\n        }\r\n      })\r\n    }, 500)\r\n  }\r\n复制代码2.4 将该图片存储到手机相册\r\nsaveImageToAlbum() {\r\n    let that = this;\r\n    //将图片保存到相册       \r\n    wx.saveImageToPhotosAlbum({\r\n      filePath: that.data.posterUrl,\r\n      success(res) {\r\n        wx.hideLoading()\r\n        wx.showModal({\r\n          title: '保存成功',\r\n          content: '图片成功保存到相册了，快去分享朋友圈吧',\r\n          showCancel: false,\r\n          confirmText: '好的',\r\n          confirmColor: '#818FFB',\r\n          success: function (res) {\r\n\t\t\t  // 保存成功，隐藏画布\r\n            if (res.confirm) {\r\n              that.setData({\r\n                isShowPoster: false\r\n              })\r\n            }\r\n          }\r\n        })\r\n      }\r\n    })\r\n  }"}
{"title": "微信小程序一键转快应用", "author": "Rolan", "time": "2020-6-4 00:41", "content": "微信小程序与快应用兼容版的语法有 95% 以上的相似度，通过 npm 包，我们可以实现从微信小程序源码到快应用源码的一键转换。1. 安装 qa-adapterqa-adapter 可用于帮助已有微信小程序或者支付宝小程序的开发者，快速将项目适配到快应用兼容版中去。使用 npm 安装：npm install -g qa-adapter使用 yarn 安装：yarn add -g qa-adapter2. 使用使用adt命令转换项目adt [sourceDir] [destDir?optional]参数说明参数作用-v，--version输出工具版本号-l，--logs在转换后项目的根目录中输出转换记录文件logs.txt-d，--diff在转换后项目的 .quickapp 目录中生成转换前后代码的对比报告3. 案例对于我们已经上架了的微信小程序 性能排行榜 ：只需一条命令就能转换为快应用：adt ./miniprogram/rank ./quickapp/rank转换结果：可以看到转换过来的快应用的界面显示，数据请求等过程都是正确的。也可以对比转换前后的代码。adt -d ./miniprogram/rank ./quickapp/rank对于 95% 以上的小程序可以做到一键转换，对于中大型的小程序，本转换工具能减少 95% 的迁移工作量。转换过程中有任何问题欢迎及时反馈，开发快应用的过程中有任何问题也可与我一起交流。交流 QQ 群： 171685021"}
{"title": "微信小程序bindtap与catchtap的区别", "author": "Rolan", "time": "2020-5-26 00:22", "content": "1、bindtap和catchtap的区别(1) 相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分。\r\n(2) 不同点：他们的不同点主要是bindtap是冒泡的，catchtap是非冒泡的。2、例子1、假如有三个view点击事件都是用的bindtap，三个view是层级包含关系?123456789<view id=\"outer\" bindtap=\"out\">    outer view    <view id=\"middle\" bindtap=\"middle\">        middle view        <view id=\"inner\" bindtap=\"inner\">            inner view        </view>    </view></view>　　 2、我么在js里代码是在相对应的事件打印出log，代码如下?out:function(e){\r\n    console.log(\"--out bindtap click\")\r\n}, middle: function (e) {\r\n    console.log(\"--middle bindtap click\")\r\n}, inner: function (e) {\r\n    console.log(\"--inner bindtap click\")\r\n} 3、bindtap执行结果点击out view打印出一条log --> out bindtap click\r\n\r\n点击middle view打印出两条log --> middle bindtap click--out bindtap click\r\n\r\n点击innew view打印出三条log --> inner bindtap click--middle bindtap click--out bindtap click\r\n\r\n可以看出bindtap不阻止向上冒泡，所以点击inner一直冒泡到了最外层。 4、如果我们只修改middle view的bindtap为catchtap点击out view打印出一条log --> out bindtap click（因为没有上层元素故而无法向上冒泡）\r\n\r\n点击middle view打印出一条log --> middle bindtap click（catchtap阻止向上冒泡）\r\n\r\n点击innew view打印出两条log --> inner bindtap click（catchtap阻止向上冒泡）本博客主要记录自己的学习点滴~，文章来源于总结，还有在工作中实际碰到的问题以记录。"}
{"title": "TensorFlow.js 微信小程序插件开始支持 WebAssembly", "author": "Rolan", "time": "2020-5-26 00:31", "content": "我们知道，微信小程序由一个描述整体程序的 app 和多个描述各自页面的 page 组成。小程序主体部分由 app.js、app.json、app.wxss三个文件组成，页面 page 则通常包含 js、wxml、json、wxss 文件。这些文件都是文本文件，由微信小程序引擎解析并解释执行。然而，随着业务需求越来越复杂，微信小程序的逻辑越来越复杂，相应的代码量随之变的越来越多。对于 js 代码的执行，通常需要进行 词法分析 -> 语法分析 -> 预解析 -> 解释执行 等过程，性能太差。当然，随着 JS 引擎在发展的过程中引入了许多优化手段如字节码缓存，可以省掉每次解释执行时重新遍历语法树的过程。特别是谷歌的 V8 的 JIT 技术，在运行过程中直接生成并缓存机器码，下次执行时可由计算机直接执行，极大的提升了执行速度。然而，由于 JavaScript 这门语言本身的缺陷，使得优化变得越来越困难。由于JavaScript没有静态变量类型，只有动态变量，上一秒可能是Array，下一秒就变成了Object，那么引擎所做的优化就失去了作用，这会导致运行效率降低。为了应对这一问题， WebAssembly 出现了。WebAssembly官方对 WebAssembly 的定义如下：WebAssembly（wasm）是一个可移植、体积小、加载快并且兼容 Web 的全新格式。嗯，估计你看了这个定义还是不知道 WebAssembly 是什么。简单来说，WebAssembly是一种新的字节码格式，旨在成为高级语言的编译目标，目前可以使用C、C++、Rust、Go、Java、C#等编译器（未来还有更多）来创建wasm模块（见下图）。该模块以二进制的格式发送到浏览器，并在专有虚拟机上执行，与JavaScript虚拟机共享内存和线程等资源。它是由 Google、Microsoft、Mozilla、Apple 等几家大公司合作发起的一个关于面向Web的通用二进制和文本格式的项目。关于字节码格式，可以参考 Java，因为 Java 程序就是一种与平台无关的字节码。首先，字节码是一种经过编译器编译之后的二进制代码，无需经过 解析 和 字节码编译 这两步。其次，WebAssembly强制使用静态类型，在语法上完全脱离JavaScript，同时具有沙盒化的执行环境，安全性更好。最后，WebAssembly可直接和html以及浏览器进行交互。相对于 JS，WebAssembly 有如下优点：体积小：由于浏览器运行时只加载编译成的字节码，一样的逻辑比用字符串描述的 JS 文件体积要小很多；加载快：由于文件体积小，再加上无需解释执行，WebAssembly 能更快的加载并实例化，减少运行前的等待时间；兼容性问题少：WebAssembly 是非常底层的字节码规范，制订好后很少变动，就算以后发生变化,也只需在从高级语言编译成字节码过程中做兼容。可能出现兼容性问题的地方在于 JS 和 WebAssembly 桥接的 JS 接口。微信小程序对WebAssembly的支持微信小程序在Android / iOS上用于执行脚本以及渲染组件的环境都不尽相同。在Android上，微信小程序的 Javascript 引擎采用了 V8，原生支持 WebAssembly，所以微信小程序在 Android 手机上提供 WebAssembly的支持。在iOS上，微信小程序采用了苹果公司的 JavaScriptCore 引擎，并没有原生支持 WebAssembly，但最新 JavaScriptCore 也已经支持 WebAssembly。在不久的将来，IOS 手机 的微信小程序会支持 WebAssembly。使用TensorFlow.js的WASM backendTensorFlow.js的WASM backend非常适合在中低端Android手机上使用。中低端手机的GPU往往相对CPU要弱一些，而WASM backend是跑在CPU上的，这就为中低端手机提供了另一个加速平台。而且WASM的能耗一般会更低。使用WASM backend需要修改package.json文件：{\r\n  \"name\": \"yourProject\",\r\n  \"version\": \"0.0.1\",\r\n  \"main\": \"dist/index.js\",\r\n  \"license\": \"Apache-2.0\",\r\n  \"dependencies\": {\r\n    \"@tensorflow/tfjs-core\": \"1.7.3\"，\r\n    \"@tensorflow/tfjs-converter\": \"1.7.3\",\r\n    \"@tensorflow/tfjs-backend-wasm\": \"1.7.3\",\r\n    ...\r\n  }\r\n}\r\n然后在app.js中设置 wasm backend, 你可以自行在服务器上托管 wasm 文件以提高下载速度, 下面例子中的 wasmUrl 可以替代成你的URL。const info = wx.getSystemInfoSync();\r\n    const wasmUrl = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-wasm@1.7.3/wasm-out/tfjs-backend-wasm.wasm';\r\n    const usePlatformFetch = true;\r\n    console.log(info.platform);\r\n    if (info.platform == 'android') {\r\n      setWasmPath(wasmUrl, usePlatformFetch);\r\n      tf.setBackend('wasm').then(() => console.log('set wasm backend'));\r\n    }\r\n注意使用WASM需要导入>= 1.7.3的tfjs库。小结本文介绍了 WebAssembly 以及微信小程序对 WebAssembly 的支持情况，最后介绍了如何启用TensorFlow.js的WASM backend。由于在苹果手机上还未能全面支持 WebAssembly，在加上 WebAssembly 技术出现的比较晚（2015年），需要时间的检验，要在项目中全面采用 WebAssembly 不现实。但是如果项目中某个功能模块存在性能瓶颈，使用传统的 JS 实现效率太低，这个时候可以考虑 WebAssembly。另外, 如果在低端 Android 手机上运行 tfjs 微信小程序，也可以考虑采用WASM backend。参考https://github.com/tensorflow/tfjs-wechatWebAssembly进阶系列一：WebAssembly是什么"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发", "author": "admin", "time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "原生小程序跨平台实现（微信/支付宝/百度）？", "author": "Rolan", "time": "2020-3-23 00:31", "content": "前言\r\n微信推出小程序平台以来，国内各大公司陆续跟进，带来了小程序的繁荣。从开发者的视角，我们看到小程序开发者变多，各种小程序技术方案不断出现。\r\n\r\n\r\n小程序增强型开发框架的出现\r\n小程序原生框架能力扩充，典型的有 wepy/mpvue\r\n小程序跨端开发框架的出现\r\n * 通过编写一套代码，实现多个小程序平台运行，典型的有 taro/uniapp\r\n小程序与 web/native（app）融合的技术需求出现\r\n\t* 因 小程序/web/native 平台差异较大，虽然有许多框架进行了尝试，但还处于蛮荒时代，未出现得到一致认可的方案\r\n\r\n\r\n而这繁荣的背后也显得杂乱，影响开发者选择适合的技术方案。基于此，我们做了一次小程序跨平台开发方向的调研，并得出如下建议：\r\n\r\n原生小程序如何实现多平台投放？\r\n从我们的了解来看，目前小程序市场，大部分还是微信小程序应用，其次是支付宝小程序，百度小程序。对这几端的融合也是目前比较切合需求场景的需求。基于此，我们调研了从微信小程序到其它端的转换的情况，帮助大家了解如何快速实现微信小程序到其它小程序的迁徙。\r\n\r\n说明： 以下测试结果基于微信官方微信小程序 demo 调研而得\r\n\r\nAntmove 小程序转换器\r\n\r\n官网：ant-move.github.io/guide/\r\nGithub：github.com/ant-move/An…\r\n\r\nAntmove 是目前小程序转换开源解决方案里成熟度最高的，通过 Antmove 转换器，可以一键将微信小程序转换为其它平台小程序，也可以将支付宝小程序转换为其它平台小程序，目前还在持续维护更新。\r\n基于 Antmove 的多端开发相关介绍可以从这里了解\r\ntaro\r\n介绍：Taro 是一套遵循 React 语法规范的 多端开发 解决方案。\r\nGithub: github.com/NervJS/taro…\r\nTaro 本质上是一套自定义语法的跨端开发方案，但官方提供了微信小程序转换为 taro 代码的工具，基于此，用户可以借助于 taro 将微信小程序转换为 taro 代码，然后再将其转换为对应平台的小程序代码。\r\n不足\r\n\r\n\r\n需要进行两次转换才能可以得到对应平台的代码\r\n\r\n\r\n功能支持情况不是很理想，如下为将微信小程序官方 demo 转换为 taro，再转换其它平台的测试情况\r\n\r\n\r\n转支付宝：\r\n\r\n目前转码后点击事件失效，转码后框架上函数有报错，逻辑需要重新写\r\nsetData函数运行失败，项目没办法使用\r\n\r\n\r\n\r\n转百度小程序\r\n\r\n界面（不支持，需要修改的）\r\n\r\nflex相关样式设置失败\r\nbutton报错，getLaunchOptionsSync没有处理\r\nmap\r\n显示隐藏指南针\r\n开启俯视功能\r\n\r\n\r\n接口（不支持，需要修改的）\r\n\r\n登陆\r\n支付\r\n客服消息\r\n生物认证\r\n蓝牙\r\niBeacon\r\n搜索WIFI\r\n上传视频和图片\r\n动态加载字体\r\n储存数据报错\r\n多线程计算\r\n\r\n\r\n\r\n\r\n\r\n转头条小程序\r\n\r\n目前转码后点击事件失效，转码后框架上函数有报错，逻辑需要重新写\r\nsetData函数运行失败，项目没办法使用\r\n\r\n\r\n\r\n\r\n注： 目前转码工具初始化微信小程到taro代码会有图片路径处理错误，需要手动修改一下\r\n\r\n总结\r\n\r\n工具整体体验流畅，其设计核心是用react语法使用工具提供的API和组件完成项目开发，然后一键生成多端小程序\r\n目前对原生小程序（微信）转到taro的问题比较多，但是整体能够完成转码，只是转码后需要花费一定的精力重新处理各种问题\r\n\r\nuniapp\r\n介绍： uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台\r\nGithub： github.com/dcloudio/un…\r\n微信小程序转换 uniapp 代码指南\r\n总结\r\n\r\n需要手工将微信小程序改造成 uniapp 应用\r\n非官方版本有一个转换工具，但转换不理想，测试微信官方 demo 转换报错\r\n单纯开发多端小程序这个框架还是比较好用的，但是转码微信小程序没有一键转码功能，需要手动配置大量的文件，其开发成本比较高\r\n\r\nmpx\r\n介绍：相同风格的语言开发开发多端小程序的开发框架，语言风格类似小程序，支持双向数据绑定\r\nGithub：github.com/didi/mpx.gi…\r\n结论\r\n\r\n不同的小程序需要搭建不同的开发环境，并做好相应的配置，\r\n不支持原生小程序转换，但支持使用原生小程序组件/页面，对于完整的小程序转换成本较高\r\n\r\n\r\n说明：除了 Antmove 转换器外，其它方案解决方案的初衷是基于 react/vue 或自定义语法的角度来实现多端，所以微信小程序转换到多端这一转换流程并不包含来这些框架的所有能力和优势，对于原生小程序迁移到其它平台本文调研结果可以参考。\r\n\r\n非小程序语法多端方案对比\r\n\r\n这里主要指采用非小程序语法开发小程序应用。\r\n非小程序语法开发业务代码方案已有诸多的调研和说明，可参考如下链接：\r\n\r\n\r\n小程序开发：用原生还是选框架（wepy/mpvue/uni-app/taro）？\r\nChameleon\r\n深入测试一周，主流多端框架大比武~by DCloud\r\n\r\n关于小程序跨平台开发的看法\r\n存在的问题\r\n从上面我们可以看到随着小程序的繁荣，跨端融合这个概念被提得越来越多，也出现了许多解决该问题的框架。但这真的代表着跨端开发的繁荣吗？\r\n我觉得还不是，小程序和 web，小程序和 native app存在着天然的差异化，这是很难弥补的，虽然社区上有出现了很多的方案，但都还不能说成熟。\r\n只考虑小程序这一平台，差异性会小一点，但想做到完全的一套代码，多个小程序平台运行还是很难。这里有以下几个原因：\r\n\r\n各大厂商采用自己的小程序技术框架，难以进行标准化\r\n小程序会自带厂商基因，能力差异化\r\n\r\n虽然有如上的差异，但依然小程序间的跨平台还是看到了一定的可能性，这也是目前小程序跨端方案出现这么多的原因。\r\n展望未来\r\n虽然上面提及了跨平台开发的不足，但其优势依然存在，一套代码多处运行充满了诱惑。当我们将全端的要求降低，只考虑某些平台的情况下，已经出现了较为成熟的方案。\r\n\r\n大多数情况下其实我们需要的只是某一端或是几端的融合，在 taro 的统计示例中我们可以发现，微信小程序应用占比达 90%，即大多数的应用只用 taro 开发了微信小程序。uniapp 也提到绝大多数应用只用其来开发其中一端的应用。在 Antmove 的统计中，绝大部分的用户也只是微信小程序和支付宝小程序两端的融合要求。\r\n\r\n在小程序之前，多端融合就已经被提及推出，在前端领域中，react 在这方面做得比较成功。在 react 学习一遍，即可多处编写的理念下，较低成本的实现了多端的需求，如 react-web/react-native/react-sketch 等，也因此构建了丰富的 react 生态。\r\n除了 react 体系外，如下的方案则切实的实现了某些平台的跨端\r\n\r\nflutter - 高性能移动端跨平台框架\r\nelectron - PC 应用跨平台开发工具\r\nQT\r\n小程序\r\n\r\ntaro/uniapp/Antmove/rax/mpx/cml\r\n\r\n\r\n\r\n畅想未来，设备复杂化是个必然的趋势，而这也更考验着跨端技术方案是否足够成熟。"}
{"title": "小程序导航栏之导航面板", "author": "Rolan", "time": "2020-4-2 00:55", "content": "导航面板\r\n导航系统起着组织内容和功能的作用，让它们按照产品的信息架构图进行连接，展现在在用户面前，导航将零散的内容和功能组织成了一个完成的有结构的系统，有时我们需要把更多的内容放置在导航栏的位置，因此需要一个导航面板\r\n导航面板是导航栏的一个扩展，从导航栏部分拖拽出导航面板，展示更多的入口\r\n\r\n\r\n\r\n\r\n支持自定义面板内容\r\n\r\n\r\n示例代码\r\nhttps://github.com/webkixi/aotoo-xquery  \r\n=> pages/navpad  \r\n复制代码\r\n配置说明\r\nconst Pager = require('../../components/aotoo/core/index')\r\nconst mkNavpad = require('../../components/modules/navpad')\r\nPager({\r\n  data: {\r\n    navPadConfig: mkNavpad({\r\n      id: '',\r\n      bindopen: null,\r\n      bindclose: null,\r\n      content: null,\r\n      navpadHeight: '90%', // 默认导航板高度\r\n      navpadTop: '85%', // 默认导航板初始位置\r\n      navpadOpen: '-80%' // 默认导航板打开高度\r\n    }),\r\n  }\r\n})\r\n复制代码id\r\n{Array} 配置实例的Id\r\nbindopen\r\n{Function} 弹开导航面板时的回调方法\r\nbindclose\r\n{Function} 关闭导航面板时的回调方法\r\ncontent\r\n{Array} 设置导航面板的内容\r\nnavpadHeight\r\n{String} 设置导航面板的高度，默认为全屏90%\r\nnavpadTop\r\n{String} 设置导航面板的默认位置, 默认为85%\r\nnavpadOpen\r\n{String} 设置导航面板打开时的占整屏高度, 默认为80%\r\n如何设置\r\n设置回调函数\r\nnavPadConfig: mkNavpad({\r\n  bindopen: function(){\r\n    // 导航栏面板弹开时响应\r\n  },\r\n  bindclose: function(){\r\n    // 导航栏面板关闭时响应\r\n  },\r\n  navpadHeight: '90%', // 默认导航板高度\r\n  navpadTop: '85%', // 默认导航板初始位置\r\n  navpadOpen: '-80%' // 默认导航板打开高度\r\n}),\r\n复制代码如何获得实例\r\nPager({\r\n  data: {\r\n    navPadConfig: mkNavpad({\r\n      id: 'idName',\r\n    }),\r\n  },\r\n  onReady(){\r\n    let that = this[idName]\r\n  }\r\n})  \r\n复制代码使用实例插入数据\r\nPager({\r\n  data: {\r\n    navPadConfig: mkNavpad({\r\n      id: 'idName',\r\n    }),\r\n  },\r\n  onReady(){\r\n    let that = this[idName]\r\n    // 插入一条数据\r\n    that.innerContent({ title: '好好学习，天天向上' })  \r\n\r\n    // 插入数组  \r\n    that.innerContent([\r\n      { title: '好好学习' },\r\n      { title: '天天向上' },\r\n    ])  \r\n    \r\n    // 追加数据  \r\n    that.appendContent([\r\n      { title: '好好学习' },\r\n      { title: '天天向上' },\r\n    ]) \r\n  }\r\n})\r\n复制代码设置文本内容\r\nmkNavpad({ content: [\r\n  '好好学习',\r\n  '天天向上'\r\n]})\r\n复制代码设置列表\r\nmkNavpad({ content: [\r\n  {title: '好好学习', itemClass: 'xuexi'},\r\n  {title: '天天向上', itemClass: 'xiangshang'},\r\n  {img: {src: 'path/to/img', itemClass: 'img-class'}},\r\n]})\r\n复制代码设置文档\r\nmkNavpad({ \r\n  content: [\r\n    {\"@md\": `markdown的文本内容`}\r\n  ]\r\n})\r\n复制代码设置复杂的图文\r\nmkNavpad({\r\n  content: [\r\n    {\r\n      img: {src: 'path/to/image'},\r\n      \"@md\": `文档描述内容`\r\n    },\r\n  ]\r\n})\r\n复制代码GITHUB源码\r\n查看演示"}
{"title": "微信小程序云开发—云函数连接MySQL", "author": "Rolan", "time": "2020-4-13 00:27", "content": "微信小程序云开发—云函数连接MySQL本文章代码已上传GitHub：\thttps://github.com/aquanlerou/miniprogram-cloud-development直接上干货，主要是利用微信的云函数和\tSequelize 进行连接外部\tMySQL ，本文章主要讲述：MySQL\r\nMySQL\r\n注：微信小程序APPID（请自行去地址注册\thttps://mp.weixin.qq.com ）拉取我的代码或则创建一个新的云开发小程序//本文章主要的代码在一下目录中\r\nminiprogram-cloud-development\r\n ├── cloudfunctions\r\n │   └── mysql\r\n ├── miniprogram\r\n │   └── pages\r\n │       └── mysql\r\n ├── project.config.json\r\n └── README.md选择已经配置好的\tmysql 页面编译模式，在编译器中直接打开\tMySQL 页面我们页面代码也只需要一行代码，按钮进行触发云函数即可。mysql.wxml<button bindtap=\"mysql\">mysql</button>mysql.jsPage({\r\n    mysql: function(event) {\r\n        console.log(event)\r\n\t\t//调用云函数\r\n        wx.cloud.callFunction({\r\n            name: 'mysql' //调用我们后面写的mysql云函数对应命名\r\n        }).then(res => {\r\n            console.log(res)\r\n        })\r\n    }\r\n})这是我们前端看到的页面了，就一个按钮触发云函数的页面就写好了。创建连接MySQL云函数可以看到我的代码中已经创建好一个叫\tmysql 的\tindex.js 云函数如下const cloud = require('wx-server-sdk')\r\n\r\nconst Sequelize = require('sequelize')\r\n// const sequelize = new Sequelize('数据库名称', '用户名', '密码', {\r\nconst sequelize = new Sequelize('xx', 'xx', 'xx', {\r\n    host: '119.28.161.110',//云数据库IP地址\r\n    port: 3306,\r\n    dialect: 'mysql',\r\n    operatorsAliases: false,\r\n    pool: {\r\n        max: 5,\r\n        min: 0,\r\n        acquire: 30000,\r\n        idle: 10000\r\n    }\r\n})\r\n\r\n//创建USER表，表结构为一个firstName和lastName字段同为String类型\r\nconst User = sequelize.define('user', {\r\n    firstName: {\r\n        type: Sequelize.STRING\r\n    },\r\n    lastName: {\r\n        type: Sequelize.STRING\r\n    }\r\n})\r\n\r\ncloud.init()\r\n\r\nexports.main = async (event, context) => {\r\n\t\r\n    //这里进行调用创建USER表，并且插入一条数据，最后返回结果给调用者。\r\n    return await User.sync({ force: true }).then(() => User.create({\r\n        firstName: 'Huangquan',\r\n        lastName: 'Wu'\r\n    })).then(res => {\r\n        return res.toJSON()\r\n    })\r\n\r\n}Sequelize 的文档地址：\thttps://sequelize.org/v4/下面我们要在个云函数\tminiprogram-cloud-development\\cloudfunctions\\mysql 目录打开终端，安装\tSequelize 的依赖Microsoft Windows [版本 6.1.7601]\r\n版权所有 (c) 2009 Microsoft Corporation。保留所有权利。\r\n\r\nD:\\Git\\miniprogram-cloud-development\\cloudfunctions\\mysql>npm install --save sequelize\r\nnpm notice created a lockfile as package-lock.json. You should commit this file.\r\nnpm WARN mysql@1.0.0 No description\r\nnpm WARN mysql@1.0.0 No repository field.\r\n\r\n+ sequelize@5.21.6\r\nadded 21 packages from 93 contributors and audited 22 packages in 7.577s\r\nfound 0 vulnerabilities\r\n\r\n\r\nD:\\Git\\miniprogram-cloud-development\\cloudfunctions\\mysql>npm install --save mysql2\r\nnpm WARN mysql@1.0.0 No description\r\nnpm WARN mysql@1.0.0 No repository field.\r\n\r\n+ mysql2@2.1.0\r\nadded 19 packages from 21 contributors and audited 41 packages in 10.162s\r\nfound 0 vulnerabilities\r\n\r\n\r\nD:\\Git\\miniprogram-cloud-development\\cloudfunctions\\mysql>安装好后我们需要把它同步到云开发的环境中，这里就不详细讲解怎么开通创建云开发环境了，可以自行在官方文档进行查找学习附上地址：\thttps://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html测试调用云函数我们只需要在预先设置的\tmysql 编译模式下后，点击我们的按钮观察控制台打印的结果，和数据库可视化工具是否创建了表和插入数据。可以看到我们远端的\tMySQL 数据库已经创建了\tUSER 表并且插入一条数据。总结个人比较推荐直接使用云开发自带的数据库，因为速度快，用外连\tMySQL 的话会收到网络波动的影响。就像我要把这个云函数的\t超时时间跳到15s"}
{"title": "人人都该具备封装思维：Taro+Es6+Promise+Ts简易构建微信小程序的全局请求方法 ...", "author": "Rolan", "time": "2020-4-20 00:51", "content": "无论是app还是小程序或者其他端，交互中请求无处不在。一个优秀的封装类，能让你的开发效率事半功倍，所以封装逻辑至关重要，当然我也是个小菜鸟，跟着自己的思路写过一些封装方法，一方面是想不足之处还望路过的大神给予指正，二者是为新手打开一个善于封装思维的大门，下面进入到前置知识。Api： cnodejs.org/api/v1Ts： 简易的类型声明、接口等Es6：结构赋值、扩展运算、promise、export等Taro：类react，以及小程序基础知识等1.梳理Taro的请求 Taro.request，实现最简易的请求方法import Taro from '@tarojs/taro'\r\n//回调调用\r\nfunction doRequestAction(){\r\n  Taro.request({\r\n    url: '',\r\n    data: {},\r\n    header: {},\r\n    success: res => {},\r\n    fail: err => {},\r\n    complete: info => {}\r\n  })\r\n}\r\n// promise调用\r\nfunction doRequestAction(){\r\n  Taro.request({\r\n    url: '',\r\n    data: {},\r\n    header: {}\r\n  })\r\n  .then(res=>{})\r\n  .catch(err=>{})\r\n  .finally(()=>{})\r\n}\r\n复制代码其中利弊不多做介绍，我们将会用到promise的请求方式。2.梳理会用到的请求结构，以及定义的文件分类：接口地址，也就是我们常说的url，存放于api.ts文件中请求方法，也就是我们封装的方法，我们存放于request.ts文件中接口类型，也就是我们声明数据类型的文件，我们存放于inter.d.ts文件中配置文件，常用的全局请求域名，其他不动参数等，我们这里只是简单的示例因此不需要，如果有需要请大家自行配置文件名作用api.ts存放接口地址、以及统一请求域名前缀request.ts封装公共请求方法、以及调用方法集合inter.d.tsts的声明文件，主要存放返回值类型，请求参数类型等3.接入promise声明自己的方法并返回自己的promise请求对象我这里尽量写es6写法让大家在今后的项目开发中更加顺畅的使用，当然在自己的项目中请结合实际情况使用，不要盲目的接入一些新的写法。下面进入知识点梳理：请求是否loading，真 ? 结束隐藏loading : ' 'loading层是否开启maskloading文字参数可自定义请求失败是否弹出我们的报错信息url在不以http/https的情况下使用自定义接口import Taro from '@tarojs/taro'\r\n// 暂时考虑 req的属性都会传入\r\nconst doRequestAction = (req) => {\r\n  return new Promise((resolve, reject) => {\r\n    if (req.loading) Taro.showLoading({ title: req.title ? req.title : '数据加载中...' })\r\n    Taro.request({\r\n      url: /^http(s?):\\/\\//.test(req.url) ? req.url : '', //暂时留空\r\n      method: 'POST',\r\n      data: {},\r\n      header: { 'content-type': 'application/x-www-form-urlencoded' }\r\n    })\r\n    .then(res => {})\r\n    .catch(err => { \r\n        //报错提示 \r\n    })\r\n    .finally(() => {\r\n      if (req.loading) Taro.hideLoading()\r\n    })\r\n  })\r\n}\r\n复制代码4.分离请求参数并使用ts声明传入值与类型1.将使用到的参数进行分离 2.每个参数给出默认值，如果不传人将用默认值代替 3.使用ts声明参数类型export interface RequestBase {\r\n  url: string, //字符串\r\n  method: 'POST' | 'GET', //常规请求方式，根据项目要求添加\r\n  data: any, // 每次的参数都是不固定的，因此我们暂时不声明数据类型\r\n  header: RequestHeader, // 下面的requestheader类型,\r\n  loading: boolean, // 请求是否开启loading层\r\n  mask: boolean, //开启loading层的情况下是否不能点击，全屏遮罩\r\n  title: string, //开启loading层的提示内容\r\n  failToast: boolean //如果请求是否，我是否直接弹出我的提示\r\n}\r\n\r\nexport interface RequestHeader {\r\n  'content-type': string // 表示content-type类型必须声明\r\n}\r\n复制代码上面的header,我重新定义了一个接口来声明类型，是为了更方便的去管理这个数据，试想如果我们平时需要将用户的token带入到header里面，那么我们就会在RequestHeader中在声明一个token字段。所谓的接口也就相当于我们这个数据里面有什么字段，字段是什么类型。所以，我们在header中在加入token字段，实际项目中，可能还会带入加密串，时间，以及其他的辅助验证字段，这里只为了大家方便开发做出示例，实际还需看项目声明。特殊提醒：ts是可以不加逗号的export interface RequestHeader {\r\n  'content-type': string // 表示content-type类型必须声明\r\n  token: string\r\n}\r\n复制代码声明我们的默认参数，在用户没有参数传入的情况下，将会使用我们的默认参数来辅助请求。// 使用默认参数，当数据不传入指定字段时替代\r\nconst NormalRquestData: RequestBase = {\r\n  url: api.DOMAIN, // 默认请求地址\r\n  method: 'GET', // 默认get请求\r\n  header : { // 默认使用的header头\r\n    \"content-type\": 'application/x-www-form-urlencoded',\r\n    token: ''\r\n  },\r\n  data: {}, // 默认没有参数，传入空对象\r\n  loading: true, //默认开启loading层\r\n  mask: true, //请求时不需要点击\r\n  title: '数据加载中', //loading提示文字\r\n  failToast: false // 一般我们会处理相应业务逻辑，就不直接提示阻断流程\r\n}\r\n复制代码思考问题，我们如果每次动态 带上我们token？ 用户刚开始进入小程序，这时可能是没有授权，后面授权了我们要及时更新token来达到用户交互目的 这时我们可以将header提出，当然我一般会在我的状态管理中操作，这里做个例子为大家提供思路。将token作为可选字段封装方法每次请求动态提取token方法返回类型为我们定义的RequestHeader类型// inter.d.ts\r\nexport interface RequestHeader {\r\n  'content-type': string // 表示content-type类型必须声明\r\n  token?: string // token可能不存在，如果存在就是字符串类型\r\n}\r\n//request.ts 获取header头 返回值是RequestHeader类型\r\nconst getRequestHeader = (): RequestHeader => {\r\n  let token: string = Taro.getStorageSync('token')\r\n  return token ? {\r\n    \"content-type\": 'application/x-www-form-urlencoded',\r\n    token: token\r\n  } : {\r\n    \"content-type\": 'application/x-www-form-urlencoded'\r\n  }\r\n}\r\n复制代码5.在参数某些字段不传入的情况下，我们使用自己的参数字段进行默认填充思考问题：RequestBase参数都是必传，但是我们的请求的时候参数都是可传，如果我们将其都改为可选参数，这个时候如果我们使用req.title(loading标题)、req.url('请求api地址') 在ts的检测下，这些参数都是可能不存在的，这样我们会写大量判断，那么我们的代码就会变得相当糟糕~！因此我们再声明一个接口用来可选参数的规范。// 遍历RequestBase中所有key，都改为可选参，这样我们就只管维护RequestBase\r\ntype Request = {\r\n  [K in keyof RequestBase]?: RequestBase[K]\r\n}\r\n复制代码改造请求方法，并声明各个类型，使ts更加规范, 将接口类使用inter导入,也将之前的api改成Api统一首字母大写import Taro from '@tarojs/taro'\r\nimport * as Api from './api'\r\nimport * as Inter from './inter.d'\r\n\r\n\r\n// 请求传入reqData参数   返回promise对象 因为全局请求我每次返回的类型都是不一样的，所以我直接any\r\nconst doRequestAction = (reqData: Inter.Request): Promise<any> => {\r\n  // 将不存在的参数字段使用默认值进行替换\r\n  let req: Inter.RequestBase = { ...NormalRquestData, ...reqData }\r\n  return new Promise((resolve, reject) => {\r\n    //检测是否开启loading层 是否打开msak\r\n    if (req.loading) Taro.showLoading({ title: req.title, mask: req.mask })\r\n    Taro.request({\r\n      url: req.url, //引入我的接口是特殊声明的，所以我就不检测http/https了\r\n      method: req.method,\r\n      data: req.data,\r\n      header: req.header\r\n    })\r\n    .then(res => {\r\n      // 大多数请求中 success并不代表成功，需要我们自己检测statusCode来确保\r\n      if (res.statusCode === 200) {\r\n        resolve(res.data) // 成功\r\n      } else {\r\n        // 如果失败 检测是否直接提示信息\r\n        if(req.failToast) Taro.showToast({ title: '网络不好，请求失败！' })\r\n        reject(res) // 失败\r\n      }\r\n    })\r\n    .catch(err => {\r\n      // 如果失败 检测是否直接提示信息\r\n      if (req.failToast) Taro.showToast({ title: '网络不好，请求失败！' })\r\n      reject(err)\r\n    })\r\n    .finally(() => {\r\n      // 请求结束 关闭loading层\r\n      if (req.loading) Taro.hideLoading()\r\n    })\r\n  })\r\n}\r\n复制代码ok，请求方法写到这里我们暂时只能告一段落了6.完善api.ts，声明全局域名以及每个接口的定义.//定义全局请求地址，因为我们用到的地址是https://cnodejs.org/api/v1\r\nexport const DOMAIN: string = 'https://cnodejs.org/'\r\n// 声明获取主题首页接口地址并导出\r\nexport const topics: string = DOMAIN + 'api/v1/topics'\r\n复制代码7.观察api，声明请求data文件，以及使用请求并返回promise以及返回类型 返回类型： cnodejs.org/api/v1/topi… 自己观察我就不截图了。// 请求主题接口参数类型\r\nexport interface TOPICSDATA {\r\n  page: number,\r\n  tab: 'ask' | 'share' | 'job' | 'good',\r\n  limit: number,\r\n  mdrender?: boolean\r\n}\r\n// 获取主题的接口\r\nexport interface TOPICS {\r\n  id: string,\r\n  author_id: string,\r\n  tab: string,\r\n  content: string,\r\n  title: string,\r\n  last_reply_at: string,\r\n  good: boolean,\r\n  top: boolean,\r\n  reply_count: number,\r\n  visit_count: number,\r\n  create_at: string,\r\n  author: TOPICSAUTHOR\r\n}\r\n// 作者的类型\r\nexport interface TOPICSAUTHOR {\r\n  loginname: string,\r\n  avatar_url: string\r\n}\r\n复制代码8.自定义获取方法，结合自己的请求方法返回新的promise对象// 调用封装方法 返回promise对象 得到获取到的数据\r\nconst getTopics = (data: Inter.TOPICSDATA): Promise<Inter.TOPICS> => {\r\n  return doRequestAction({\r\n    url: Api.topics,\r\n    data: data\r\n  })\r\n}\r\n复制代码9. 页面内可以调用getTopics方法拿到我们的数据import { getTopics } from '../../utils/request/request'\r\nimport { TOPICSDATA } from '../../utils/request/inter'\r\n\r\nuseEffect(()=>{\r\n    let data: TOPICSDATA= {\r\n      page: 1,\r\n      tab: 'ask',\r\n      limit: 10\r\n    }\r\n    getTopics(data).then(res=>console.log(res))\r\n  },[])\r\n复制代码至此，一个简易的封装就完美的结束了，但是在实际开发中为了自己的便利，我们会封装很多经常使用到的参数，这里只是提供一个封装思维，具体还需要在大家的项目中去思考怎么才能去优化代码。10.总结知识点es6语法： ...展开运算， 解构赋值， promisets：类型声明， 可选项， type , any类型 ，单个类型定义封装思维，文件拆分代码连接： pan.baidu.com/s/1DZ9u7U1f… 密码:t7rc最后如果这篇文章对您有用，麻烦您点亮一个赞，感激不尽，如果代码中有好的意见或建议，还望不吝赐教。"}
{"title": "微信小程序实现基于三元运算验证手机号/姓名功能示例", "author": "Rolan", "time": "2020-4-29 00:41", "content": "本文实例讲述了微信小程序实现基于三元运算验证手机号/姓名功能。分享给大家供大家参考，具体如下：wxml部分：<view class=\"fl_form\" style=\"position:relative;padding-top:20rpx;\">\r\n <text><text style=\"color:red;padding-right:10rpx\">*</text>您的姓名</text>\r\n <input type=\"text\" placeholder='请输入您的姓名' value=\"{{trueName}}\" bindblur='userNameInput'></input>\r\n <text class=\"{{isName=='1'?'show':'hidden'}}\">姓名不能为空</text>\r\n</view>\r\n<view class=\"fl_form\">\r\n <text><text style=\"color:red;padding-right:10rpx\">*</text>所属部门</text>\r\n <input type=\"text\" placeholder='请输入所属部门' value=\"{{deparment}}\" bindblur='userBranchInput'></input>\r\n <text class=\"{{isDeparment=='1'?'show':'hidden'}}\">部门不能为空</text>\r\n</view>\r\n<view class=\"fl_form\" style=\"padding-bottom:20rpx;\">\r\n <text><text style=\"color:red;padding-right:10rpx\">*</text>联系电话</text>\r\n <input type=\"number\" placeholder='请输入联系电话' maxlength='11' value=\"{{phone}}\" bindblur='userTellInput'></input>\r\n <text class=\"{{isPhone=='1'?'show':'hidden'}}\" style=\"width:35%\">请输入有效的手机号</text>\r\n</view>\r\njs部分：data: {\r\n  trueName: \"\",\r\n  deparment: \"\",\r\n  phone: \"\",\r\n  isName: \"\",\r\n  isDeparment: \"\",\r\n  isPhone: \"\",\r\n },\r\n //事件处理函数\r\n userNameInput: function (e) {\r\n  //用户姓名\r\n  if (e.detail.value) {\r\n   console.log(e.detail.value)\r\n   this.setData({\r\n    isName: '',\r\n    trueName: e.detail.value\r\n   })\r\n  } else {\r\n   this.setData({\r\n    isName: '1'\r\n   })\r\n  }\r\n },\r\n userBranchInput: function (e) {\r\n  //所属部门\r\n  if (e.detail.value) {\r\n   this.setData({\r\n    isDeparment: '',\r\n    deparment: e.detail.value\r\n   })\r\n  } else {\r\n   this.setData({\r\n    isDeparment: '1'\r\n   })\r\n  }\r\n },\r\n userTellInput: function (e) {\r\n  //联系电话\r\n  if (/^1[3|4|5|6|7|8|9]\\d{9}$/.test(e.detail.value)) {\r\n   this.setData({\r\n    phone: e.detail.value,\r\n    isPhone: \"\"\r\n   })\r\n  } else {\r\n   this.setData({\r\n    isPhone: \"1\"\r\n   })\r\n  }\r\n }\r\n本机测试运行结果：希望本文所述对大家微信小程序开发有所帮助。"}
{"title": "微信小程序性能优化实践", "author": "Rolan", "time": "2020-5-7 00:21", "content": "本文主要是根据微信小程序官方优化建议和《2018微信公开课第七季上海站·小程序专场》的性能优化方案，针对性我们的小程序项目进行性能优化实践，将过程记录下来，方便以后查看，同时也希望能帮助到其他小伙伴，做好性能优化。毕竟一切性能优化都是为了更好的用户体验。小程序常见性能问题这个小程序为什么这么慢？这个小程序为什么滑不动了，卡住了？小程序在切页面的时候为什么会有延迟？为什么点击了没有反应，是不是挂掉啦？这些问题的场景都反映了小程序的性能问题，直接影响到用户体验。小程序如何进行性能优化？官方建议从这两方面进行优化：启动性能优化渲染性能优化启动性能优化小程序在整个启动流程中，一般需要完成几项工作：1.准备运行环境（微信自己处理的）2.下载，注入并执行对应小程序代码包3.渲染小程序首页开发者可以在第2，3去优化小程序的启动性能。1.代码包大小优化小程序在首次打开时，会去下载并执行代码包，随着代码包大小的上升，耗时也会相应增加。可以采取以下方案：分包使用分包对开发者而言，能使小程序有更大的代码体积，承载更多的功能与服务；而对用户而言，可以更快地打开小程序，同时在不影响启动速度前提下使用更多功能。建议开发者按照功能的划分，拆分成几个分包，当需要用到某个功能时，才加载这个功能对应的分包。使用分包实践我们的一个小程序在两年多前开始开发的，在设计之初，我们没有考虑到这一点，当时也没有小程序分包的功能。好吧，我们还是迎来了这个问题。微信小程序在开发文档中明确指出，小程序的所有包大小必须限制在2M以内，超过大小，就算在开发者工具中都不能正常预览，更不能上传发版。解决问题的方法：将静态资源图片压缩，因为小程序的压缩算法对图片的压缩微乎其微，于是互，笔者对图片进行一轮压缩，并且将重复使用的图片，进行了公共提取，虽然官方推荐使用网络图片，但是还需要去维护静态资源，嫌麻烦，就放弃。将项目中的弃用的页面，以及不用的三方，进行了一波清除。很多项目现在都是通过webpack打包成不通的分包，资源懒加载的形式来优化，小程序也提供了这个功能：分包，笔者按照按照功能划分的原则，将同一个功能下的页面和逻辑放置于同一个目录下，成为一个分包。分包之后：注意：1. 自定义第三方组件，需要放在主包内，miniprogram_npm文件会直接打到主包里；2. 小程序的tab切换页，必须放在主包里。分包预下载分包预下载是为了解决首次进入分包页面时的延迟问题而设计的。如果能够在用户进入分包页面之前就预先将分包下载完毕，那么进入分包页面的延迟就能够尽可能降低。实践用户进行了某个操作，再去下载分包，延迟操作用户体验很差，于是乎笔者对上面的分包设置分包预下载。在 app.json 文件中配置：\"preloadRule\": {\r\n    \"pages/work/index\": {\r\n      \"network\": \"all\",\r\n      \"packages\": [\r\n        \"package-work\",\r\n        \"package-field-statistics\"\r\n      ]\r\n    },\r\n    \"pages/appeal/index\": {\r\n      \"network\": \"all\",\r\n      \"packages\": [\r\n        \"package-appeal\"\r\n      ]\r\n    }\r\n},\r\n复制代码这里建议不要一次性把所有分包预下载，这样的操作同样回带来性能问题。独立分包小程序中的某些场景（如广告页、活动页、支付页等），通常功能不是很复杂且相对独立，对启动性能有很高的要求。使用独立分包，可以独立于主包和其他分包运行。从独立分包中页面进入小程序时，不需要下载主包。建议开发者将部分对启动性能要求很高的页面放到特殊的独立分包中。实践项目中没有适合的场景，尚未实践。2.首屏渲染优化1. 提前首屏数据请求大部分小程序在渲染首页时，需要依赖服务端的接口数据，接口请求放到页面的生命周期 onLoad 中，而不是 onReady 里。 `：实践监听到页面加载，就校验登录情况，请求页面数据onLoad: function (options) {\r\n    app.checkAuth((error, token) => {\r\n      if (error) {\r\n        return\r\n      }\r\n      // 请求该页面的数据\r\n    })\r\n  },\r\n复制代码2. 缓存请求数据小程序提供了wx.setStorageSync等异步读写本地缓存的能力，数据存储在本地，返回的会比网络请求快。实践登录成功后将用户的token，以及用户信息都可以缓存到本地，记得退出登录的时候清楚缓存，:joy:。/**\r\n * 设置本地 token 缓存\r\n * @param {Object} session 服务器返回的数据\r\n * @param {String} session.access_token 存取token\r\n * @param {String} session.refresh_token 刷新token\r\n * @param {String} session.expires_in 有效期限，以秒为单位\r\n */\r\nexport function set(session) {\r\n  const localSession = Object.assign({}, session, {\r\n    expires_timestamp: getExpireTimestamp(session.expires_in)\r\n  });\r\n  wx.setStorageSync(SESSION_KEY, localSession);\r\n\r\n  _token = session.access_token;\r\n}\r\n\r\nexport function clear() {\r\n  wx.removeStorageSync(SESSION_KEY);\r\n  clearTimeout(refresh_timer);\r\n\r\n  _token = null;\r\n}\r\n复制代码3. 精简首屏数据推荐开发者延迟请求非关键渲染数据，缩短网络请求时延，与视图层渲染无关的数据尽量不要放在 data 中，以免传输垃圾数据，加快首屏渲染完成时间。实践通过id请求详情的情况，id在渲染层不需要，就可以不把id，定义在data中：// 原来代码\r\ndata: {\r\n    id: ‘’,\r\n    // ….\r\n},\r\nonLoad: function (options) {\r\n    \tthis.setData({\r\n\t\tid: options.id\r\n\t})\r\n\t// ….\r\n}\r\n\r\n// 改写后 不把id定义到data中\r\ndata: {\r\n    // ….\r\n},\r\napp.checkAuth((error, token) => {\r\n      const id = options.id === undefined ? '' : options.id;\r\n      this.id = id \r\n})\r\n复制代码接口返回的数据要做数据处理，不要直接都塞给data，减少冗余数据的双线程回传。也是 精简首屏数据优化的一部分。4. 避免阻塞渲染在小程序启动流程中，会顺序执行app.onLaunch, app.onShow, page.onLoad, page.onShow, page.onReady，所以，尽量避免在这些生命周期中使用Sync结尾的同步API，如 wx.setStorageSync，wx.getSystemInfoSync 等。实践项目中没有这样使用，有先见之明。:smile:渲染性能优化小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。** 常见的 setData 操作错误 **1. 频繁的去 setData导致了两个后果：Android 下用户在滑动时会感觉到卡顿，操作反馈延迟严重，因为 JS 线程一直在编译执行渲染，未能及时将用户操作事件传递到逻辑层，逻辑层亦无法及时将操作处理结果及时传递到视图层；渲染有出现延时，由于 WebView 的 JS 线程一直处于忙碌状态，逻辑层到页面层的通信耗时上升，视图层收到的数据消息时距离发出时间已经过去了几百毫秒，渲染的结果并不实时；实践目前项目代码还是比较规范的，我们并没有把setData当成一个普通的对象去调用，晓得每次使用都需要两个线程间通信，WebView再去渲染的。哇，好棒。2. 每次 setData 都传递大量新数据由setData的底层实现可知，我们的数据传输实际是一次 evaluateJavascript 脚本过程，当数据量过大时会增加脚本的编译执行时间，占用 WebView JS 线程。实践目前每个接口的数据量并大，数据的量级还没达到影响脚步执行的程度，有需要的话再优化吧。3. 后台态页面进行 setData当页面进入后台态（用户不可见），不应该继续去进行setData，后台态页面的渲染用户是无法感受的，另外后台态页面去setData也会抢占前台页面的执行。实践A页面上有个定时器，此时打开了B页面，A页面的定时器还在运行，继续抢占B页面的资源，B页面卡顿了，但是并不是B页面的造成的性能问题，这种问题就不太好排查。希望大家都能做个有始有终的人，定时器不用了要清除。下面demo，定时器在 onHide 时要清除掉。切记切记:point_down:/**\r\n   * 生命周期函数--监听页面显示\r\n   */\r\nonShow: function () {\r\n    clearTimeout(getTodaytime)\r\n    this.updateNowTime()\r\n},\r\n\r\n/**\r\n   * 生命周期函数--监听页面隐藏\r\n */\r\nonHide: function () {\r\n    // 取消定时器 防止小程序内存不足，崩溃\r\n    clearTimeout(getTodaytime)\r\n},\r\nupdateNowTime() {\r\n    getTodaytime = setInterval(() => {\r\n      const myDate = new Date(); \r\n      const hours = myDate.getHours())\r\n      const minutes = myDate.getMinutes())\r\n      const seconds = myDate.getSeconds())\r\n\r\n      const newTime = hours + ':' + minutes + ':' + seconds;\r\n      this.setData({\r\n        newTime: newTime\r\n      })\r\n    }, 1000)\r\n  },\r\n复制代码2. 用户事件使用不当过多的使用bindTap、bindCatch不当的使用onPageScroll实践项目中展示没用使用该事件。3. 使用自定义组件在需要频繁更新的场景下，自定义组件的更新只在组件内部进行，不受页面其他部分内容复杂性的影响。"}
{"title": "微信小程序6位密码框/验证码实现 基于微信7.0.9", "author": "Rolan", "time": "2020-5-14 00:31", "content": "需求实现一个能够输入6位密码框组件（如微信支付密码框类似）思路一（不可行方案）使用一个Input 配合 letter-spacing 属性使用。后实验下来，input 并不使用css中的 letter-spacing 属性。思路二 （可行方案）在页面中，隐藏一个input，然后控制 input 组件的 focus 属性从而实现6位密码框输入。需要注意的是，在我写这个组件并验证时，(iphone xs max ios13.3) 微信版本为7.0.8，实测组件可以正常工作。当我微信升级为7.0.9时，input 手动设置 focus 并没有生效，同时，该 input 没有办法再次聚焦并弹出输入法。（很奇怪的是，我同事的手机也是iphone xs max ios13.3 微信 7.0.9 没有这个问题组件布局拆分组件wxml<view class=\"pay-password-container\">  <text class=\"pay-password-title\">安全验证</text>  <text class=\"pay-password-tips\">您使用了虚拟资产，为保障安全，请输入支付密码！</text>  <view style=\"position:relative\">    <view class=\"pay-password-layout\">      <view wx:for=\"{{passwordlayout}}\" class=\"pay-password-item\">        <view wx:if=\"{{index < passwordCode.length}}\" class=\"dot\" />      </view>    </view>    <!-- 这里采用了一个投机取巧的办法，使用两个Input 防止在某些机型上，input设置focus会导致input整个失效-->    <input value=\"{{passwordCode}}\" password maxlength=\"6\" type=\"number\" class='input-container-2' bindinput=\"passwordInput\" />  </view>  <input value=\"{{passwordCode}}\" focus=\"{{focus}}\" maxlength=\"6\" type=\"number\" class='input-container-2' bindinput=\"passwordInput\" bindfocus=\"getFocus\" bindblur=\"blur\" />  <view class='forget-password' catchtap=\"clickForgetPassword\">忘记密码?</view>  <view class=\"empty-layout\" />  <view class=\"controll-layout\">    <view class=\"cancel-button\" catchtap=\"dismiss\">      <text>取消</text>    </view>    <view class=\"divider\" />    <view class=\"sure-button\" catchtap=\"sure\">      <text>确定</text>    </view>  </view>  </view>组件wxss.pay-password-container {  width: 650rpx;  height: 525rpx;  border-radius: 16rpx;  background: #fff;  display: flex;  display: -webkit-flex;  flex-direction: column;  align-items: center;}.pay-password-title {  font-size: 40rpx;  font-weight: bold;  color: #030303;  margin-top: 59rpx;  flex-shrink: 0;}.pay-password-tips {  font-size: 24rpx;  color: #333;  opacity: 0.5;  margin-top: 31rpx;  flex-shrink: 0;}.pay-password-layout {  display: flex;  display: -webkit-flex;  flex-direction: row;  margin-top: 40rpx;  flex-shrink: 0;  z-index: 105rpx;}.pay-password-item:first-child {  height: 90rpx;  width: 90rpx;  border-radius: 8rpx 0rpx 0rpx 8rpx;  border-top: 1px solid #bbb;  border-left: 1px solid #bbb;  border-bottom: 1px solid #bbb;  box-sizing: border-box;  -moz-box-sizing: border-box;  -webkit-box-sizing: border-box;  display: flex;  display: -webkit-flex;  justify-content: center;  align-items: center;}.pay-password-item {  height: 90rpx;  width: 90rpx;  border-top: 1px solid #bbb;  border-left: 1px solid #bbb;  border-bottom: 1px solid #bbb;  box-sizing: border-box;  -moz-box-sizing: border-box;  -webkit-box-sizing: border-box;  display: flex;  display: -webkit-flex;  justify-content: center;  align-items: center;}.pay-password-item:last-child {  height: 90rpx;  width: 90rpx;  border-radius: 0rpx 8rpx 8rpx 0rpx;  border-top: 1px solid #bbb;  border-left: 1px solid #bbb;  border-bottom: 1px solid #bbb;  border-right: 1px solid #bbb;  box-sizing: border-box;  -moz-box-sizing: border-box;  -webkit-box-sizing: border-box;  display: flex;  display: -webkit-flex;  justify-content: center;  align-items: center;}.pay-password-item .dot {  height: 20rpx;  width: 20rpx;  background: #030303;  border-radius: 50%;}.input-container-2 {  position: absolute;  top: 40rpx;  height: 100rpx;  width: 1500rpx;  left: -500rpx;}.empty-layout {  flex-grow: 1;}.controll-layout {  flex-shrink: 0;  border-top: 1px solid #e9e9e9;  width: 100%;  height: 100rpx;  box-sizing: border-box;  -moz-box-sizing: border-box;  -webkit-box-sizing: border-box;  display: flex;  display: -webkit-flex;}.controll-layout .cancel-button {  flex-grow: 1;  display: flex;  display: -webkit-flex;  justify-content: center;  align-items: center;}.cancel-button text {  color: #333;  opacity: 0.5;  font-size: 34rpx;}.controll-layout .divider {  background: #e9e9e9;  height: 100%;  width: 1px;  flex-shrink: 0;}.controll-layout .sure-button {  flex-grow: 1;  display: flex;  display: -webkit-flex;  justify-content: center;  align-items: center;}.sure-button  text {  font-size: 34rpx;  color: #f8aa00;  font-weight: bold;}.forget-password {  font-size: 24rpx;  color: #333;  opacity: 0.5;  margin-top: 30rpx;  align-self: flex-end;  margin-right: 55rpx;}组件jsinput1 带 focus 属性，手动设置 focus 让其弹出。input2 不带 focus 属性，需要用户手动点击输入框（6格）后，输入。这样就避免了对 输入框（6格）监听tap事件，并设置focus 来让 input 聚焦，让输入法弹起。就解决了部分手机上手动设置 focus 会导致 input 组件没有响应的问题。Component({  data: {    passwordlayout: [1, 1, 1, 1, 1, 1],    passwordCode: \"\",    focus: false  },  methods: {    showModal: function () {      this.setData({        focus: true      })    },    closeModal: function () {      this._clearData();    },    passwordInput: function (e) {      this.setData({        passwordCode: e.detail.value      })    },    focusInput: function () {      this.setData({        focus: true      })    },    getFocus: function () {      this.setData({        focus: true      })    },    blur: function () {      this.setData({        focus: false      })    },    dismiss: function (e) {      this.closeModal();    },    sure: function (e) {      if (this.data.passwordCode.length < 6) {        UIManager.showToast('请输入支付密码');        return;      }      //todo 支付密码验证    },    clickForgetPassword: function (e) {      //todo 忘记密码    },  }})"}
{"title": "vue和小程序项目中使用iconfont的方法", "author": "Rolan", "time": "2020-5-20 00:45", "content": "一、vue中使用iconfont1、百度搜索iconfont或者阿里巴巴矢量图标库官网，注册登录；2、找到图标管理->新建项目，或者使用已有的项目，用于保存自己的图标；3、搜索自己需要的icon；4、添加到购物车中；5、购物车中就有了相应icon6、点击购物车，选择添加至项目。就是我们刚才创建的项目或者之前已有的项目7、点击确定，即可将icon添加到我们的项目中8、然后点击我的项目，找到自己的项目，即可看到刚才添加的icon9、点击下载至本地10、将下载的压缩包进行解压11、打开解压好的文件夹，找到iconfont.css12、把解压好的文件夹放入项目目录下，在vue项目中的index.html中引入即可使用如可以放在public文件夹下13、在组件中使用总结：三步搞定1、将iconfont下载至本地2、在项目中引入文件3、vue中直接使用，然后使用i标签，通过类来规定使用的icon4、小程序中把iconfont.css的后缀名改为wxss，在项目中直接使用i标签即可到此这篇关于vue和小程序项目中使用iconfont的方法的文章就介绍到这了,更多相关vue小程序使用iconfont内容请搜索我们以前的文章或继续浏览下面的相关文章希望大家以后多多支持我们！"}
{"title": "一个美观可定制主题的服务器监控小程序", "author": "Rolan", "time": "2020-5-20 00:51", "content": "mini-status中文 | English微信小程序miniStatus的后端程序介绍miniStatus是一个美观可定制主题的服务器监控小程序，可实现小程序与服务器的点对点连接，展示服务器基本运行状态，这个项目是其对应的后端程序。特点直接通过小程序和服务器的点对点连接，数据不经过第三方中转不要求服务器域名备案，可以直接使用ip，甚至局域网地址miniStatus小程序小程序地址搜索 miniStatus 小程序节点列表界面自定义主题样式界面安装npm install mini-status -g使用命令行参数usage: mini-status [-h] [-v] [-u URI] [-a ADDRESS] [-p PASSWORD]\r\n\r\nminiStatus backend program\r\n\r\nOptional arguments:\r\n  -h, --help            Show this help message and exit.\r\n  -v, --version         Show program's version number and exit.\r\n  -u URI, --uri URI     uri for api, default '/update'\r\n  -a ADDRESS, --address ADDRESS\r\n                        address to listen, default 0.0.0.0:8080\r\n  -p PASSWORD, --password PASSWORD\r\n                        access password, default 1234567890配置微信小程序点击小程序右下角的 + 按钮，填写对应的配置选项例如，mini-status -a A.B.C.D:8080 -u /status -p 123 对应的信息为：接口地址： http://A.B.C.D:8080/statuspassword: 123节点名用于标识该节点，可以随便填写原理这是一个黑魔法（hhh开玩笑原理很简单，是巧妙运用了 小程序image组件 的bindload接口，当图片加载成功时会返回图片的宽和高。也就是说一个图片能够返回两个数值，前后端约定好请求API后可以动态创建image获取一系列数值。注意这个接口是不要求图片地址是备案域名，不用在小程序开发信息中报备。但是这种信息传递方式比较低下，只适合传递少量的信息。所以拿来做了这个点对点的服务器监控小程序。但是直接传递大体积的二进制图片很浪费带宽，解决方案是后端动态生成svg图片。也就是说，动态返回下面这种形式的文字信息：<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\"></svg>详细的实现可以看 这个文件FAQ1.我配置填写服务器数据存放在哪？存放在你手机本地，放心，咱不馋你数据2.我是小白，没有node js的开发经验，但我看着挺好看也想用用怎么办？我写了一个简单的安装脚本，但还没有充分测试，欢迎反馈wget https://gist.githubusercontent.com/axipo/81e148e47f4a02892c22e76339b68b63/raw/4ae1fc7f1ccc42ee6a4537358e41c42b415725bd/mini_status_easy_install.sh && chmod u+x mini_status_easy_install.sh && ./mini_status_easy_install.sh或者，也可以使用下面相关项目中的一键脚本（未充分测试，有问题去提issue）相关项目mini-status一键安装脚本"}
{"title": "微信小程序装饰器模式实践", "author": "Rolan", "time": "2020-5-21 00:16", "content": "场景应用中本身存在一个商品组件，如下：显示商品的基础信息在应用开发的过程中，为商品增加了一个状态： 失效 状态。UI设计图如下：###设计思路 从需求和UI上来看，新增的失效状态，对原组件的功能做了增加而不是修改,不影响原组件的功能，适用于装饰器模式。装饰器模式装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。介绍意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。何时使用：在不想增加很多子类的情况下扩展类。如何解决：将具体功能职责划分，同时继承装饰者模式。应用实例： 1、孙悟空有 72 变，当他变成\"庙宇\"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。缺点：多层装饰比较复杂。使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。注意事项：可代替继承。原组件代码index.wxml\r\n<view style=\"border: 1rpx solid red; padding: 10rpx;\">\r\n  <image src=\"{{goods.url}}\"></image>\r\n  <view>名称：{{goods.name}}</view>\r\n  <view>规格：{{goods.sku}}</view>    \r\n  <view wx:if=\"{{type === 'member'}}\">价格:{{goods.price * 0.7}}元</view>\r\n  <view wx:elif=\"{{type === 'activity'}}\">价格:{{goods.price * 0.8}}元</view>\r\n  <view wx:else>价格:{{goods.price}}元</view>\r\n</view>\r\n复制代码装饰器代码index.wxml\r\n<view class=\"container\">\r\n\t<view class=\"wrapper\" wx:if=\"{{wrapped}}\">\r\n    <view style=\"color:{{title.color}};font-size:{{title.fontSize}};\">{{title.text}}</view>\r\n\t</view>\r\n\t<slot />\r\n</view>\r\n复制代码index.js\r\n// components/decorator/index.js\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    wrapped: {\r\n      type: Boolean,\r\n      value: true\r\n    },\r\n    title: {\r\n      type: Object,\r\n      value: {\r\n        text: '已抢光',\r\n        color: 'white',\r\n        fontSize: '26rpx'\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n\r\n  }\r\n})\r\n复制代码具体代码看demodemo地址通过动态地传入属性，来控制deractor里面的内容，没有修改原组件，但是完美地实现需求，这就是《装饰器模式》的魅力吧！"}
{"title": "为什么不在微信小程序中使用骨架屏，来提升用户体验？", "author": "Rolan", "time": "2020-5-21 00:25", "content": "历史回顾：\r\n\r\n微信小程序原生性能优化实践\r\n微信小程序自定义组件 - 表格组件来啦\r\n通过微信小程序来实现 “钉钉打卡”\r\n记一次微信小程序项目分包，以及分包预下载\r\n微信小程序实践\r\n\r\n骨架屏在前端的应用里很普及，不过大多都是在H5的应用中，今天想谈的是微信小程序中如何使用骨架屏，以及小程序骨架屏的实现原理，针对骨架屏项目还可以提个PR，封装出来一个npm包形式的第三方，为前端社区做点小贡献。\r\n如何在微信小程序中使用骨架屏？\r\n一、安装和引入\r\n1.安装组件：\r\nnpm install --save miniprogram-skeleton\r\n复制代码2.引入skeleton自定义组件\r\n{\r\n  \"usingComponents\": {\r\n    \"skeleton\": \"../miniprogram_npm/miniprogram-skeleton\"\r\n  }\r\n}\r\n复制代码小程序中npm的配置及使用：\r\n\r\n在微信开发者工具中，设置 —> 项目设置—> 勾选使用npm模块。\r\n在微信开发者工具中，工具 —> 构建npm，构建完成会生成 miniprogram_npm 文件夹，项目用到的npm包都在这里。\r\n按照页面的使用路径，从 miniprogram_npm 引入需要的包。\r\n\r\n\r\n注意下小程序中npm的配置及使用比普通的npm包的使用多了一些配置，引出了 miniprogram_npm 的概念。\r\n\r\n二、使用骨架屏组件\r\n1.在wxml页面需要用到的地方使用，如下：\r\n<!--引入骨架屏模版 -->\r\n<skeleton wx:if=\"{{showSkeleton}}\"></skeleton>\r\n\r\n<!--index.wxml-->\r\n<!--给页面根节点class添加skeleton, 用于获取当前页面尺寸，没有的话就默认使用屏幕尺寸-->\r\n<view class=\"container skeleton\">\r\n    <view class=\"userinfo\">\r\n        <block>\r\n\t        <!--skeleton-radius 绘制圆形-->\r\n            <image class=\"userinfo-avatar skeleton-radius\" src=\"{{userInfo.avatarUrl}}\"\r\n                   mode=\"cover\"></image>\r\n             <!--skeleton-rect 绘制矩形-->\r\n            <text class=\"userinfo-nickname skeleton-rect\">{{userInfo.nickName}}</text>\r\n        </block>\r\n    </view>\r\n    <view style=\"margin: 20px 0\">\r\n        <view wx:for=\"{{lists}}\" class=\"lists\">\r\n            <icon type=\"success\" size=\"20\" class=\"list skeleton-radius\"/>\r\n            <text class=\"skeleton-rect\">{{item}}</text>\r\n        </view>\r\n    </view>\r\n\r\n    <view class=\"usermotto\">\r\n        <text class=\"user-motto skeleton-rect\">{{motto}}</text>\r\n    </view>\r\n\r\n    <view style=\"margin-top: 200px;\">\r\n        aaaaaaaaaaa\r\n    </view>\r\n</view>\r\n复制代码2.在js页面需要用到的地方使用，如下：\r\n初始化默认的数据，用于撑开页面结构，让骨架屏可以获取到整体的页面结构。\r\n//index.js\r\nPage({\r\n\tdata: {\r\n\t\tmotto: 'Hello World',\r\n\t\tuserInfo: {\r\n\t\t\tavatarUrl: 'https://wx.qlogo.cn/mmopen/vi_32/SYiaiba5faeraYBoQCWdsBX4hSjFKiawzhIpnXjejDtjmiaFqMqhIlRBqR7IVdbKE51npeF6X1cXxtDQD2bzehgqMA/132',\r\n\t\t\tnickName: 'jayzou'\r\n\t\t},\r\n\t\tlists: [\r\n\t\t\t'aslkdnoakjbsnfkajbfk',\r\n\t\t\t'qwrwfhbfdvndgndghndeghsdfh',\r\n\t\t\t'qweqwtefhfhgmjfgjdfghaefdhsdfgdfh',\r\n\t\t],\r\n\t\tshowSkeleton: true   //骨架屏显示隐藏\r\n\t},\r\n\tonLoad: function () {\r\n\t\tconst that = this;\r\n\t\tsetTimeout(() => {     //3S后隐藏骨架屏\r\n\t\t\tthat.setData({\r\n\t\t\t\tshowSkeleton: false\r\n\t\t\t})\r\n\t\t}, 3000)\r\n\t}\r\n})\r\n复制代码在微信小程序中使用骨架屏比较简单的，注意骨架屏组件的基础传参，以及显示和隐藏骨架屏的控制。\r\n来看看骨架屏的实现原理\r\n源码地址：github.com/jayZOU/skel…\r\n作者是腾讯的一位大佬，是他"}
{"title": "浅谈 DoraemonKit 微信小程序 sdk", "author": "Rolan", "time": "2020-5-21 00:41", "content": "DoraemonKit 是什么\r\n一款移动端工具包，可以查看移动端的运行环境和 mock 接口，具体可以查看官网， 这次主要谈谈微信小程序端 sdk 的实现。\r\n小程序端主要支持了下面几个功能， 下面会逐一讲到。\r\n\r\nApp 信息\r\nApp 信息分为系统信息、账户信息、用户信息、授权信息\r\n这里面只要用到了微信的几个api， 包括getSystemInfo、getAccountInfoSync、getUserInfo 以及 getSetting，这个具体去看微信小程序api\r\n位置模拟\r\n这个有点 hack 意味，首先选择地理位置 wx.chooseLocation ， 在成功的回调里面用 defineProperty 去 mock getLocation 的返回值\r\nwx.chooseLocation({\r\n    success: res => {\r\n    this.setData({currentLatitude: res.latitude});\r\n    this.setData({currentLongitude: res.longitude})\r\n    Object.defineProperty(wx, 'getLocation', {\r\n        get(val) {\r\n            return function (obj) {\r\n                obj.success({latitude: res.latitude, longitude: res.longitude})\r\n            }\r\n        }\r\n    })\r\n    }\r\n})\r\n复制代码这样在后续我们调用 wx.getLocation 函数的时候，返回的都是我们之前选择地理位置的值，\r\nwx.getLocation({\r\n    type: 'gcj02',\r\n    success:res=> {\r\n        console.log(res.latitude, res.longitude)\r\n        \r\n    }\r\n})\r\n复制代码至于要恢复原来的数据，直接拿app上面的数据\r\n Object.defineProperty(wx, 'getLocation',{\r\n    get(val) {\r\n        return app.globalData.getLocation\r\n    }\r\n});\r\n复制代码缓存管理\r\n主要还是利用 wx.getStorageInfoSync 的api, 只不过把缓存中的 key 全部列举出来，提供可视化界面给开发人员去操作\r\nlet storageInfo = wx.getStorageInfoSync()\r\nthis.setData({limitSize:storageInfo.limitSize})\r\nthis.setData({currentSize:storageInfo.currentSize})\r\nstorageInfo.keys.forEach(key => {\r\n    let result = wx.getStorageSync(key)\r\n    let info = {\r\n        key,\r\n        value:result,\r\n        isModify:false,\r\n        ischecked:false\r\n    }\r\n    storageArr.push(info)\r\n});\r\n复制代码h5 任意门\r\n主要是提供我们内嵌 h5 快速输入 url 进行 h5 展示的入口，这个其实没什么好讲的，就是把 提供了扫码和 url 输入两个途径， 还有一个列表历史 url 展示\r\n请求注射\r\n这个主要是提供 http 返回数据的拦截，对于符合我们需要拦截的 key， 返回我们设置的 value，拦截的数据存储在全局的 app 里面\r\ngetApp().globalData['__HTTP_INJECTOR']\r\n复制代码至于怎么去拦截的, 还是去 hack wx.request方法，首先把 wx.request 缓存起来，app.globalData.originRequest = wx.request ，然后在hooksRequestSuccessCallback 中去决定是否去拦截\r\nhooksRequest() {\r\n    Object.defineProperty(wx,  \"request\" , { writable:  true });\r\n    const hooksRequestSuccessCallback = this.hooksRequestSuccessCallback\r\n    wx.request = function(options){\r\n        const originSuccessCallback = options.success\r\n        options.success = res => {\r\n            originSuccessCallback(hooksRequestSuccessCallback(res))\r\n        }\r\n        app.globalData.originRequest(options)\r\n    }\r\n},\r\n复制代码其中hooksRequestSuccessCallback 如下所示，遍历 this.data.interceptors.forEach 中的数据，查看 key 是否符合我们拦截的数据 key ，如果符合就替换数据\r\nhooksRequestSuccessCallback(res) {\r\n    let { data } = res\r\n    this.data.interceptors.forEach(interceptor => {\r\n        const { isRegex, key, value } = interceptor\r\n        const replaceKey = isRegex ? new RegExp(key, 'g') : key\r\n        const isNotStringData =  typeof data !== 'string'\r\n        if (isNotStringData) {\r\n            data = JSON.stringify(data)\r\n        }\r\n        data = data.replace(replaceKey,value)\r\n        if (isNotStringData) {\r\n            data = JSON.parse(data)\r\n        }\r\n    })\r\n    res.data = data\r\n    return res\r\n},\r\n复制代码更新版本\r\n其实有点像 app 里面的 检查更新，只不过对于的小程序的检查更新\r\nconst updateManager = wx.getUpdateManager();\r\n\r\nupdateManager.onCheckForUpdate(function (res) {\r\n    if(!res) {\r\n        // 请求完新版本信息的回调\r\n        wx.showModal({\r\n            title: '更新提示',\r\n            content: '当前已经是最新版本'\r\n        })\r\n    }\r\n});\r\n\r\nupdateManager.onUpdateReady(function () {\r\n    wx.showModal({\r\n        title: '更新提示',\r\n        content: '新版本已经准备好，是否重启应用？',\r\n        success(res) {\r\n            if (res.confirm) {\r\n                // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启\r\n                updateManager.applyUpdate()\r\n            }\r\n        }\r\n    })\r\n});\r\n\r\nupdateManager.onUpdateFailed(function () {\r\n    // 新版本下载失败\r\n})\r\n\r\n复制代码小结\r\n总的来说这款小程序工具 sdk 实现不算难，只要是看看怎么去运用微信给的 api 结合我们的需求去进行 hack 以及 怎么给微信小程序做工具库方便开发去诊断信息。"}
{"title": "微信小程序本地缓存二次封装", "author": "Rolan", "time": "2020-5-21 00:51", "content": "新建wxCache.js/**\r\n * 本地缓存\r\n * @工具测试 https://tool.lu/timestamp/\r\n * @param key 缓存参数\r\n * @param value 缓存值\r\n * @param time 缓存时间(小时为单位，传1，就意味缓存1个小时) 非必传\r\n* */\r\nexport default class wxCache {\r\n    constructor() {\r\n      this.now = new Date().getTime();// 获取当前时间\r\n    }\r\n    \r\n    // 获取\r\n    get(key) {\r\n        this.now = new Date().getTime();// 获取当前时间\r\n        let time = wx.getStorageSync(key).time || false;// 获取缓存时间\r\n        if(time) {\r\n            if (parseInt(time) >= this.now ) {\r\n              // console.log('还没过期')\r\n              return wx.getStorageSync(key).value\r\n            }else {\r\n              // console.log('过期啦')\r\n              this.remove(key);// 删除字段info\r\n              return false\r\n            }\r\n        }else {\r\n            // 没有设置时间处理返回\r\n            return wx.getStorageSync(key)\r\n        }\r\n    };\r\n    \r\n    // 添加\r\n    put(key,value,time) {\r\n        let data;\r\n        if(time) {\r\n          let timefrom = parseInt(Number(time)*60*60*1000); // 小时转化毫秒\r\n            data = {\r\n              value: value,\r\n              time: timefrom + this.now\r\n            }\r\n        }else {\r\n          data = value;\r\n        }\r\n        wx.setStorageSync(key, data);\r\n    };\r\n\r\n    // 移除\r\n    remove(key) {\r\n        console.log('删除')\r\n        wx.removeStorageSync(key);\r\n    };\r\n\r\n    // 清空所有\r\n    clearall() {\r\n      wx.clearStorageSync();\r\n    }\r\n\r\n}app.js 全局导入import wxCache from './common/wxCache.js'// 导入wxCache.js\r\nApp({\r\n  data:{},\r\n  wxCache:new wxCache(),// 全局导入\r\n})使用app.wxCache.put('time','123',1); // 设置key为time，value为 '123',时间缓存时间为1小时\r\n\r\napp.wxCache.get('time');// 获取key为time的value"}
{"title": "微信小程序性能优化技巧", "author": "Rolan", "time": "2020-5-22 00:10", "content": "微信小程序如果想要优化性能，有关键性的两点：提高加载性能和提高渲染性能。一、提高加载性能　　当用户点击小程序后发生了什么？　　资源准备（代码包下载） ——  业务代码注入和渲染  ——  异步请求数据　　上面的三个状态，我们经常遇到，它们分别对应小程序的下面三个状态：有三个点的白屏阶段： 下载代码包的阶段没有三个点的白屏： 业务代码注入和渲染的阶段加载中： 业务代码中异步请求数据　　总的来说，小程序呈现到用户面前，实际上经历了下面两个阶段：运行环境的加载，下载代码包启动小程序。　　运行环境预加载：这步是微信做的。微信会在用户打开小程序之前就已经准备好环境，用户点击小程序入口后，直接下载小程序的代码包即可。　　下载代码包启动小程序，小程序代码包里面的代码，不是小程序的源代码，而是编译、压缩、打包之后的代码包。　　下图中，左侧的“预加载”对应的是运行环境的预加载，右侧的“小程序启动” 对应的是下载代码包启动小程序。　     小程序提供的运行环境，分为逻辑层（AppService）和 视图层（webView），逻辑层是执行javascript的地方，视图层是渲染页面的地方。当小程序的代码包下载完毕后，业务代码分别注入逻辑层和渲染层。　　提升加载性能的最最最关键性一点是，控制包的大小，这个也是微信官方的说法。　　提升体验最直接的方法是控制小程序包的大小，基本上可以说，1M的代码包，下载耗时1秒左右。　　控制包大小的措施：压缩代码，清理无用的代码wxss 覆盖率较高，较少或没有引入未被使用的样式。按需引入 wxss 资源，如果小程序中存在大量未使用的样式，会增加小程序包体积大小，从而在一定程度上影响加载速度图片放在cdn避免将不会被使用的文件打包进去采用分包策略分包预加载独立分包（版本要求有点高）　　除了上面讲的控制包的大小，对异步请求的优化也很重要。　　对异步请求的优化onLoad 阶段就可以发起请求，不用等ready请求结果放在缓存中, 下次接着用请求中可以先展示骨架图先反馈，再请求。比如说，点赞的按钮，可以先改变按钮的样式，再发起异步请求。二、提升渲染性能　　setData 干了啥？每调用一次setData, 都是逻辑层向渲染层的一次通讯，这个通信还不是直接传给webView, 而是通过走了native层，通讯的开销很大。　　渲染层收到通讯后，还需要重新渲染出来，所以，一次setData带来两次开销：通信的开销 + webview更新的开销。　　setData工作原理：　　小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。　　而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。　　由于小程序运行逻辑线程与渲染线程之上，setData的调用会把数据从逻辑层传到渲染层，数据太大会增加通信时间。　　在数据传输时，逻辑层会执行一次JSON.stringify来去除掉setData数据中不可传输的部分，之后将数据发送给视图层。　　同时，逻辑层还会将setData所设置的数据字段与data合并，使开发者可以用this.data读取到变更后的数据。1、减少setData的数据量：如果一个数据不能会影响渲染层，则不用放在setData里面2、合并setData的请求，减少通讯的次数3、列表的局部更新　　在一个列表中，有n条数据，采用上拉加载更多的方式，假如这个时候想对其中某一个数据进行点赞操作，还能及时看到点赞的效果。此时，可以采用setData全局刷新，点赞完成之后，重新获取数据，再次进行全局重新渲染，这样做的优点是：方便，快捷！缺点是：用户体验极其不好，当用户刷量100多条数据后，重新渲染量大会出现空白期（没有渲染过来）　　如果采用局部刷新，将点赞的id传过去，知道点的是那一条数据，重新获取数据，查找相对应id的那条数据的下标（index是不会改变的），用setData进行局部刷新this.setData({\r\n    list[index] = newList[index]\r\n})3、小心后台页面的js　　小程序中可能有n个页面，所有的这些页面，虽然都拥有自己的webview(渲染层)， 但是却共享同一个js运行环境。　　也就是说，当你跳到了另外一个页面（假设是B页面），本页面（假设是A页面）的定时器等js操作仍在进行，并且不会被销毁，并且会抢占B页面的资源。　　在h5的环境中，当我们跳转到其他页面，老页面的js环境会被自动销毁，定时器什么都被销毁掉了，因此我们不需要关心老页面中，还有哪些js代码可能还会执行。但是在小程序中，我们必须手动的“清理”掉这样的代码。4、小心onPageScroll　　pageScroll 事件，也是一次通讯，是webview层向js逻辑层的通讯。这次通讯也是开销较大，如果考虑到这个事件被频繁的调用，回调函数如果有复杂的setData的话，性能就会很差了。5、尽可能使用小程序组件　　自定义组件的更新只在组件内部进行，不受页面其他部分内容的影响；比如一些运营活动的定时模块可以单独抽出来，做成一个定时组件，定时组件的更新并不会影响页面上其他元素的更新；各个组件也将具有各自独立的逻辑空间。每个组件都分别拥有自己的独立的数据、setData调用。"}
{"title": "小程序页面间传递数据", "author": "Rolan", "time": "2020-5-22 00:28", "content": "最近在做小程序项目，发现小程序的页面间经常需要传递一些数据。根据自己的了解和熟悉，针对不同的数据要求，总结到有几种不同的传数据方式，下面做一下简单的介绍归纳。\r\n第一种：页面跳转时通过url传递\r\n使用wx.navigateTo 与 wx.redirectTo 的时候，可以将部分数据放在 url 里面，并在新页面 onLoad 的时候获取且初始化。\r\n//pageA.js\r\n\r\n// Navigate\r\nwx.navigateTo({\r\n  url: '../pageB/pageB?name=lin&gender=male',\r\n})\r\n\r\n// Redirect\r\nwx.redirectTo({\r\n  url: '../pageB/pageB?name=lin&gender=male',\r\n})\r\n\r\n// pageB.js\r\n...\r\nPage({\r\n  onLoad: function(option){\r\n    console.log(option.name + 'is' + option.gender);\r\n    this.setData({\r\n      option: option\r\n    });\r\n  }\r\n})\r\n\r\n需要注意的问题：\r\n\r\n使用wx.navigateTo 与 wx.redirectTo时，不允许跳转到 tab 所包含的页面；\r\n\r\nonLoad只执行一次；\r\n\r\n适用：\r\n这种方式一般适用于少数页面之间需要少量数据传递，如B页面需要A页面中的1-2个数据等等。\r\n第二种：使用全局变量来传递\r\n在 app.js 文件中定义全局变量 globalData，旧页面将要传递的数据赋值存放在里面，新页面调用全局变量获取传递数据值。\r\n// app.js\r\n\r\nApp({\r\n     // 全局变量\r\n  globalData: {\r\n    name: null\r\n  }\r\n})\r\n\r\n//pageA.js\r\n···\r\ngetApp().globalData.name = \"lin\";\r\n\r\n\r\n//pageB.js\r\n···\r\nthis.setData({\r\n  userName: getApp().globalData.name\r\n});\r\n\r\n要注意的问题：\r\n\r\n使用的时候，直接使用 getApp() 拿到存储的信息。\r\n\r\n适用：\r\n这种方式一般适用于多个页面或者全部页面都需要获取使用同一个数据，比如一开始进入首页就获取到的用户信息等；\r\n第三种：使用本地缓存\r\n使用小程序中的本地缓存Storage，旧页面将传递数据存入缓存中，新页面通过调用获取缓存的API得到数据。\r\n//pageA.js\r\n···\r\nwx.setStorageSync('sessionId', res.sessionId);\r\n\r\n\r\n//pageB.js\r\n···\r\nvar sessionId = wx.getStorageSync('sessionId');\r\n\r\n要注意的问题：\r\n\r\nStorage每次存入会覆盖掉原来该 key 对应的内容。\r\n如果用户主动删除小程序或因存储空间原因被系统清理，Storage中数据将被清除。\r\n单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。\r\n\r\n适用：\r\n这种方式一般适用于即使小程序退出然后再重新进入，也要保留的数据，类似于登录状态的保留等。"}
{"title": "小程序框架原理之渲染流程及通信流程", "author": "Rolan", "time": "2020-5-22 00:47", "content": "MINA 是在微信中开发小程序的框架。其目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。MINA 提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，核心是一个响应的数据绑定系统。整个系统分为视图层(View)和逻辑层(App Service)，并在视图层与逻辑层间提供了数据传输和事件系统，可以让开发者可以方便的聚焦于数据与逻辑上。MINA 让数据与视图保持同步非常简单。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。MINA 是腾讯给微信小程序命名的框架，实际上应用的是目前业界最著名的 MVVM 模式。wxml的真实面目#我们都知道小程序提供了很多方便快捷的自定义组件（标签），但你知道小程序的这些组件编译过后会渲染成什么吗？先说答案，其实 wxml 经过编译后会渲染成 html 。很简单的一点，你发现在小程序内编写 html 标签，最终也可以运行。探寻#光说可能体会不到，下面开始探寻小程序真实渲染的样子。先看下开发者工具内 wxml 的内容，待会和真实渲染的内容做对比。接下来一步步找到小程序 wxml 渲染完成的真实样子，工具菜单栏点击微信开发者工具，选择调试微信开发者工具。打开的控制台可以调试整个微信开发者工具，用调试箭头指向小程序内容区域，这时可以看到小程序视图层是被嵌套在 webview 的 iframe 内。但是当我们点开 iframe 是无法查看到里面内容的。如果想要查看调试 webview，只需选中 webview 打开它的调试工具即可，在控制台输入以下代码：Copy$$('webview')[0].showDevTools(true)可以看到又打开了一个调试窗口，这里面就是小程序视图层渲染的真实样子：可以看到结构和 wxml 里的内容几乎一模一样，只是 topbar 变成了 wx-topbar，view 变成了 wx-view等。这些都是内部实现的一套对应小程序标签的 webComponent 组件，而 webComponent 实际渲染出来还是 html 标签。转换过程#转换过程是微信开发者工具内部通过一个可执行编译工具实现对小程序文件转换。在微信开发者工具控制台输入 openVendor() 会打开一个文件夹，里面存放着微信的基础库及工具，在里面可以找到 wcc.exe、wcsc.exe 执行文件，分别对应 wxml 和 wxss 的文件转换。该工具可以单独对小程序文件进行转换，使用方法 ./wcc -d wxml文件路径 >> 输出路径。例如，将工具复制到一个文件夹内，再将一个 wxml 放入该文件夹内，命令行输入 :Copy./wcc -d index.wxml >> index.js\r\n可能有人很好奇为什么是生成 js 文件，而不是 html 文件。原因很简单，因为需要处理 wxml 的动态绑定数据。看看这个 js 文件生成的是什么：因为这些都是混淆压缩过的代码，基本没有可读性。这里只需要注意一个函数就好，那就是 $gwx。这是个很关键的函数，它的作用是生成虚拟dom树，用于渲染真实节点。接下来回到 webview 调试窗口，在 head 内找到这段插入的 script 标签代码:有没有很熟悉，没错，就是和上面转换后的代码是同一个东西。也就是说，我们的 wxml 文件通过编译，最终在视图层中执行的就是这段 js 代码（这里只是可以大概这么理解，实际需要向逻辑层获取数据才能渲染页面）。控制台输入 $gwx 发现这个函数存在，那么这个函数如何生成虚拟dom呢？$gwx 函数的第一个参数接收一个路径参数，这个路径就是 wxml 文件路径，此时在控制台输入：Copylet generateFunc = $gwx('./pages/index/index.wxml')generateFunc()这时页面虚拟dom就生成出来了：单纯调用 generateFunc 生成出来的虚拟dom是没有动态绑定数据的，如果想要动态的绑定数据，在调用 generateFunc 时传入一个数据对象。但是数据全在逻辑层里，这时就需要进行通信了。数据通信#首先要知道小程序时运行在基础库之上的，但它们都是压缩打包好的，后面找到反编译出来的基础库代码，其中最重要的就是 WAService.js 和 WAWebview.js，它们分别是视图层和逻辑层的核心实现。它们之间需要一个桥梁来进行通信，那就是 JS Bridge。JS Bridge 提供调用原生功能的接口（摄像头，定位等），它的核心是构建原生和非原生间消息通信的通道，而且这个通信的通道是双向的。通过 JS Bridge 的发布订阅方法，视图层和逻辑层进行数据通信。通信流程#接下来看看视图层和逻辑层的交互流程：wxml 转换成对应的 js 文件，等待生成虚拟dom函数 $gwx 准备完成，使用 dispatchEvent 通知 WAWebview。WAWebview 监听到 generateFuncReady 事件触发，使用 WeixinJSBridge.publish 向逻辑层通信。逻辑层处理逻辑，也就是我们平常写的小程序 js 文件里的东西，然后通过 JS Bridge 通知并返回数据给视图层。视图层接收到数据，将数据传入生成虚拟dom的函数内，渲染页面，当然小程序也有相应的diff算法。例如在 wxml 中绑定一个动态数据 title，视图层接收到数据后，重新生成虚拟domCopygenerateFunc({  title: '标题'})初始化完成后，就会走对应的其他生命周期，或者用户触发事件，数据都会在逻辑层处理完成后通过 JS Bridge 通知到视图层，视图层再次调用生成虚拟dom的函数，更新页面。wxss如何工作#wxss 工作原理和 wxml 差不多，都是通过工具转换为 js。为什么又是转换成 js，因为有 rpx 单位，需要根据手机尺寸进行设置 px。wcsc.exe 转换命令如下：Copy./wcsc -js index.wxss >> index.js可以看到文件开头就是对 rpx 的转换之后创建 style 标签，动态添加到视图层中最后#附上 WAService.js 和 WAWebview.js 的代码作为学习参考。"}
{"title": "微信小程序实现地图marker点聚合功能", "author": "Rolan", "time": "2020-5-22 00:51", "content": "写在前面的话\r\n公司项目需求要在微信小程序上实现地图marker点聚合的功能，百度苦寻无果，故自己实现。\r\n最终效果\r\n功能演示\r\n\r\n核心思路\r\n\r\nmarker标签中的callout属性用来显示聚合点的数量\r\n点击聚合点时，以聚合点为中心放大地图，不需要再次请求后台接口\r\n根据map组件scale缩放级别将地图分成一个一个的小格子，计算小格子中marker点的数量\r\n由于小程序无法像网页端那样处理庞大的数据量，为了提高用户体验，地图状态为缩放或者范围缩小时缓存上次marker数据，无需请求后台接口\r\n\r\n关键js文件\r\n\r\nMapUtil.js （判断是否为缩放状态，根据后台接口数据格式化成地图聚合类型marker数据等）\r\nZjMarker.js（maker点基类，根据简单的参数构建单个marker及聚合marker）\r\n\r\n具体实现\r\nMapUtil.js\r\nimport {\r\n  zjMarker\r\n} from '../../utils/mapUtil/ZjMarker';\r\nimport {\r\n  transformFromWGSToGCJ\r\n} from '../WSCoordinate';\r\nexport class MapUtil {\r\n  constructor(northeast, southwest, scale) {\r\n    this.northeast = northeast;\r\n    this.southwest = southwest;\r\n    this.scale = scale;\r\n    console.log('初始化mapUtil成功');\r\n    console.log(this.northeast, 'northeast');\r\n  }\r\n  //设置初始化范围\r\n  setInitData(northeast, southwest, scale) {\r\n    this.northeast = northeast;\r\n    this.southwest = southwest;\r\n    this.scale = scale;\r\n    console.log('刷新mapUtil成功');\r\n  }\r\n  //判断是否为缩放，\r\n  checkRefresh(northeast, southwest) {\r\n    console.log('检测是否可以刷新接口');\r\n    console.log(this.northeast, 'northeast');\r\n    console.log(northeast, 'currentNortheast');\r\n    let result = true;\r\n    if (this.northeast.latitude > northeast.latitude) {\r\n      console.log('东北纬度缩小');\r\n    }\r\n    if (this.southwest.latitude < southwest.latitude) {\r\n      console.log('西南纬度增高');\r\n    }\r\n    if (this.northeast.longitude > northeast.longitude) {\r\n      console.log('东北经度增大');\r\n    }\r\n    if (this.southwest.longitude < southwest.longitude) {\r\n      console.log('西南经度缩小');\r\n    }\r\n    if (this.northeast.latitude > northeast.latitude && this.southwest.latitude < southwest.latitude &&\r\n      this.northeast.longitude > northeast.longitude && this.southwest.longitude < southwest.longitude) {\r\n      console.log('地图缩放，不请求接口');\r\n      result = false\r\n    }\r\n    return result;\r\n  }\r\n  //根据东北 西南经纬度 以及后台返回标记点 格式化成小程序marker点\r\n  getFortMatMarkerList(northeast, southwest, scale, backendMarkerList) {\r\n    //屏幕中显示的经度的长度和纬度的长度\r\n    let mapWidth = southwest.longitude - northeast.longitude;\r\n    let mapHeight = northeast.latitude - southwest.latitude;\r\n    //将屏幕中地图分割的横向 格子数和 纵向格子数\r\n    let widthSize = scale;\r\n    let heightSize = widthSize + parseInt(scale / 2);\r\n    //计算每个格子的经纬度的长度\r\n    let unitWidth = mapWidth / widthSize;\r\n    let unitHeight = mapHeight / heightSize;\r\n    let pointData = {};\r\n    backendMarkerList.forEach(latLng => {\r\n      //如果点在显示范围内\r\n      if (latLng.latitude < northeast.latitude && latLng.latitude > southwest.latitude &&\r\n        latLng.longitude < northeast.longitude && latLng.longitude > southwest.longitude) {\r\n        let relativeX = latLng.longitude - northeast.longitude;\r\n        let relativeY = latLng.latitude - southwest.latitude;\r\n        //计算出这个点，处于哪个格子\r\n        let x = parseInt(Math.floor(relativeX / unitWidth));\r\n        let y = parseInt(Math.floor(relativeY / unitHeight));\r\n        if (x < 0 || y < 0) {\r\n          console.log('点位不在格子内', '失败');\r\n        }\r\n        //生成单元格点位数据\r\n        let pointKey = x + ',' + y;\r\n        if (pointData[pointKey] == undefined) {\r\n          pointData[pointKey] = [];\r\n        }\r\n        pointData[pointKey].push(latLng);\r\n      }\r\n    });\r\n    let resultMapArray = [];\r\n    for (let y = 0; y < heightSize; y++) {\r\n      for (let x = 0; x < widthSize; x++) {\r\n        let pointKey = x + ',' + y;\r\n        //筛选没有充电站点位的格子\r\n        if (pointData[pointKey] != undefined) {\r\n          let markerItem = {};\r\n          //聚合点与单点共存 , 长度等于一 不聚合点\r\n          if (pointData[pointKey].length == 1) {\r\n            let iconPath = pointData[pointKey][0].ScanAndCharge == 1 ? '/img/scanMarkerIcon.png' : '/img/markerIcon.png';\r\n            markerItem = new zjMarker(pointData[pointKey][0].longitude, pointData[pointKey][0].latitude, pointData[pointKey][0].StationID, {\r\n              iconPath: iconPath\r\n            })\r\n            //长度大于一 聚合点\r\n          } else if (pointData[pointKey].length > 1) {\r\n            let iconPath = pointData[pointKey][0].ScanAndCharge == 1 ? '/img/cluScanMarkerIcon.png' : '/img/cluMarkerIcon.png';\r\n            markerItem = new zjMarker(pointData[pointKey][0].longitude, pointData[pointKey][0].latitude, pointData[pointKey][0].StationID, {\r\n              type: 'cluster',\r\n              iconPath: iconPath,\r\n              num: pointData[pointKey].length\r\n            })\r\n          }\r\n          resultMapArray.push(markerItem);\r\n        }\r\n      }\r\n    }\r\n    console.log(resultMapArray, 'resultMapArray');\r\n    return resultMapArray;\r\n  }\r\n  //获取中心纬度\r\n  getCenterLocation(northeast, southwest) {\r\n    let mapWidth = southwest.longitude - northeast.longitude;\r\n    let mapHeight = northeast.latitude - southwest.latitude;\r\n    let longitude = northeast.longitude + mapWidth;\r\n    let latitude = southwest.latitude + mapHeight;\r\n    return {\r\n      latitude: latitude,\r\n      longitude: longitude\r\n    }\r\n  }\r\n}\r\n\r\nZjMarker.js\r\n//地图marker标记点基类 （单点`聚合）\r\nexport class zjMarker {\r\n  constructor(longitude, latitude, id, options = {}) {\r\n    this.longitude = longitude;\r\n    this.latitude = latitude;\r\n    this.id = id;\r\n    this.width = options.width ? options.width : 30;\r\n    this.height = options.height != undefined ? options.height : 36;\r\n    let type = options.type == undefined ? 'single' : options.type;\r\n    this.iconPath = options.iconPath == undefined ? '/img/markerIcon.png' : options.iconPath;\r\n    if (type != 'single') {\r\n      this.callout = {\r\n        content: options.num, //文本\r\n        color: '#000', //文本颜色\r\n        borderRadius: 3, //边框圆角\r\n        borderWidth: 0, //边框宽度\r\n        bgColor: 'transparent', //背景色\r\n        padding: 0, //文本边缘留白,\r\n        display: 'ALWAYS',\r\n        textAlign: 'center', //文本对齐方式。有效值: left, right, center,\r\n        anchorY: 62 //可能需要根据各个手机做出相应的适配\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n最后，在map组件中实现bindregionchange方法获取东北以及西南经纬度，根据经纬度范围判断是否需要请求后台接口重新获取点位信息\r\n if (mapUtil.checkRefresh(res.northeast, res.southwest)) {\r\n                console.log('开始刷新接口');\r\n                let location = mapUtil.getCenterLocation(res.northeast, res.southwest);\r\n                that.loadMapData(location.latitude, location.longitude, markerList => {\r\n                  markerList.forEach(item => {\r\n                    item.longitude = item.StationLng;\r\n                    item.latitude = item.StationLat;\r\n                  });\r\n                  oriMarkerList = markerList;\r\n                  that.setData({\r\n                    markerList: mapUtil.getFortMatMarkerList(res.northeast, res.southwest, scale, markerList)\r\n                  });\r\n                });\r\n                mapUtil.setInitData(res.northeast, res.southwest, scale);\r\n              } else {\r\n                that.setData({\r\n                  markerList: mapUtil.getFortMatMarkerList(res.northeast, res.southwest, scale, oriMarkerList)\r\n                });\r\n              }\r\n\r\n详情请咨询我 vx:a21544182123"}
{"title": "小程序-云开发-如何对敏感词进行过滤即内容安全的检测(上)", "author": "Rolan", "time": "2020-5-25 00:26", "content": "前言内容安全检测，是每一个小程序主都面临的“头疼”问题，轻则短暂性不可访问，重则永久封号，甚至关小黑屋。本文将为您详细说明，如何在小程序中对一段文本进行合法内容检测，以判断是否含有违法违规内容。本文重点为你讲述：内容安全检测常见应用场景及解决办法学会使用小程序· 云开发的云函数+结合request-promise第三方库实现内容请求校验掌握如何在小程序端请求云函数（有别于传统的wx.request的方式(类似AJax)）在云开发的云函数端, 利用第三方https请求库(request,request-promise),获取Access_token,以及向微信官方提供的内容检测接口发请求进行校验云函数端与小程序端错误码的处理背景无论是小程序还是自行开发的一些类似社交,带有用户自行产生内容的软件应用,例如:即时通讯,社群,论坛,音视频直播等,对于接入内容安全的检测是非常有必要的。对于小程序而言,这一点在审核上是非常严格的,净化言行,做一个知法守法的人很重要...接入内容安全检测,规避输入一些违法违规低俗等内容,避免辛辛苦苦开发出来的应用。被恶意上传反动言论或上传一些违规内容(文字/图片/视频等),导致小程序或应用被下架,或遭永久禁封,或个人及公司被公安机关打电话,约喝茶等,这样的话,就得不偿失了的。应用场景检测小程序用户个人文字资料是否违规针对特点词汇（如过于商业以及营销之类的词）可以进行过滤或禁止输入在内容发布之前自动检测用户发表的信息（包括评论、留言等）是否违规解决办法围绕如何处理内容安全检测问题，一般有3种方法：方案1:引入第三方接口对内容进行校验(例如:百度AI内容审核平台,网易云盾等) 方案2: 公司后台小伙伴自行开发文本,图片,音视频等内容审核接口 方案3: 小程序服务端提供的API进行校验每一种方法各有优劣势，具体如下图。解决方案优势劣势1. 引入第三方接口对内容进行校验前端同学只需按照官方提供的第三方接口文档,进行校验即可,无需后台介入,功能强大,覆盖范围广接口调用的频次有限制,收费2. 公司后台小伙伴自行开发文本,图片,音视频等内容审核接口后台小伙伴自己造轮子,根据自己的业务需求以及用户属性,自定义内容审核机制开发周期长,成本大,难以覆盖全面3. 调用小程序服务端提供的内容安全API进行校验简单,高效想不出来,因为相比前两种方案,对于不依赖后端接口的开发者来说,简直是雪中送炭在微信小程序生态下，官方提供了2种路径帮助用户解决内容检测问题，即使用服务器开发模式，通过HTTPS调用使用小程序·云开发，通过云函数或云调用来实现。服务器开发模式，相信大家都相对比较熟悉，在此就不再赘述。接下来为大家重点介绍，如何通过小程序·云开发的云函数实现内容安全检测通过云开发的云函数+request-promise第三方库实现内容请求校验Step 1: 在小程序端先布局：完成静态页面。(pages文件夹下的文件都是属于小程序前端代码,每个文件夹目录代表的就是一个模块,一个页面) 小程序前端wxml代码示例<view class=\"container\">\r\n  <textarea class=\"content\" placeholder=\"写点文字...\" bindinput=\"onInput\" auto-focus bindfocus=\"onFocus\" bindblur=\"onBlur\">\r\n  </textarea>\r\n</view>\r\n\r\n<view class=\"footer\">\r\n  <button class=\"send-btn\" size=\"default\" bind:tap=\"send\">发布</button>\r\n</view>\r\n复制代码小程序前端wxss代码示例/* pages/msgSecCheck/msgSecCheck.wxss */\r\n.container {\r\n  padding: 20rpx;\r\n}\r\n\r\n.content {\r\n  width: 100%;\r\n  height: 360rpx;\r\n  box-sizing: border-box;\r\n  font-size: 32rpx;\r\n  border: 1px solid #ccc;\r\n}\r\n\r\n.footer {\r\n  width: 100%;\r\n  height: 80rpx;\r\n  line-height: 80rpx;\r\n  position: fixed;\r\n  bottom: 0;\r\n  box-sizing: border-box;\r\n  background: #34bfa3;\r\n}\r\n\r\n.send-btn {\r\n  width: 100% !important;\r\n  color: #fff;\r\n  font-size: 32rpx;\r\n}\r\n\r\nbutton {\r\n  width: 100%;\r\n  background: #34bfa3;\r\n  border-radius: 0rpx;\r\n}\r\n\r\nbutton::after {\r\n  border-radius: 0rpx !important;\r\n}\r\n复制代码经过wxml与wxss的编写后,UI最终长成这样Step 2: 完成小程序端业务逻辑的处理小程序端逻辑JS代码示例// pages/msgSecCheck/msgSecCheck.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    textareaVal: ''   // 页面中需要显示的数据,初始化定义在data下面\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n\r\n  },\r\n  // 监听表单时,数据有变化时\r\n  onInput(event) {\r\n    let textVal = event.detail.value;\r\n    this.setData({\r\n      textareaVal: textVal\r\n    })\r\n    \r\n  },\r\n\r\n  // 聚焦焦点时\r\n  onFocus() {\r\n    console.log('聚焦焦点时');\r\n  },\r\n\r\n  // 失去焦点时\r\n  onBlur(event) {\r\n    console.log(\"失去焦点时\");\r\n    // 前端可进行手动的弱校验,也可以在失去焦点时发送请求进行文本的校验,但是每次失去焦点就请求一次,这样是消耗云资源的,其实在发布时候与失去焦点做校验两者都可以\r\n\r\n\r\n  },\r\n\r\n  // 发布\r\n  send() {\r\n    console.log(\"触发发布按钮\")\r\n    wx.cloud.callFunction({ // 请求msgSecCheck1云函数\r\n      name: 'msgSecCheck1',\r\n      data: {\r\n        content: this.data.textareaVal // 需要向云函数msgSecCheck1传入的值\r\n      }\r\n\r\n    }).then(res => { // 成功时的响应返回结果\r\n      console.log(res);\r\n    }).catch(err => { // 失败时,返回的结果\r\n      console.error(err);\r\n    })\r\n    \r\n  }\r\n\r\n})\r\n复制代码Step 3 ：服务端逻辑处理。在小程序云函数端创建云函数 msgSecCheck1 ,这个名字你可以自定义,与小程序前端请求的名字保持一致就可以了的选中云函数,右键并打开命令行终端安装request,request-promise，因为request-promise依赖于request,两个都要安装,最后一键上传部署就可以了的npm install request\r\nnpm install request-promise\r\n复制代码如果遇到在小程序端请求云函数时,遇到类似下面的错误,找不到什么xxx模块之类的 先看错误码,然后在官方文档中找到该错误码代表的含义一看错误,没有找到模块,在云函数的目录下的package.json中查看是否有安装错误中提示的包的,要是没有的话,就安装一下就可以了的,同时记得每次更改后都要上传部署一下,也可以选择云函数中文件的增量上传 接下来是将是本文的重点内容！Step 4 :通过云函数+request-promise实现内容安全检测对于小程序开发,其实与web端开发也是类似,给元素绑定事件,然后获取元素,只是小程序端没有DOM,BOM的那一套东西,它是数据驱动视图的,吸收了Angular,Vue,React的各个框架的优点,形成了自己的一套规范。如果有这方面开发经验的小伙伴来说,平缓过度到小程序开发当中来,你会发现总会有惊人的相似,用的语言都是JavaScript,但是与web开发还是多少有很多差异的,这里就不拓展了。废话不多说,直接上代码小程序前端逻辑代码// 点击发送按钮,对输入的文本内容进行校验\r\n send() {\r\n    wx.cloud.callFunction({\r\n      name: 'msgSecCheck1', // 云函数的名称\r\n      data: { // 需要向云函数传递过去的数据\r\n        content: this.data.textareaVal // 具体要检测的内容\r\n      }\r\n    }).then(res => { // 成功时,做什么事情\r\n      console.log(res);\r\n      // 检测到文本成功时,做一些业务\r\n\r\n    }).catch(err => { // 失败时,做什么事情\r\n      // 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作\r\n\r\n      console.error(err);\r\n    })\r\n  }\r\n复制代码上面的代码还可以在优化一下,就是将请求云函数的代码封装成一个函数。如下所示,不封装也是没事的,只是我习惯性封装一下,如果其他地方也用到该云函数,那么直接调用，避免写重复的代码。下面是将请求云函数的部分核心代码：// 发布\r\n  send() {\r\n    // 请求msgSecCheck1云函数,对文本内容进行校验\r\n    this._requestCloudMsgCheck();\r\n  },\r\n\r\n  _requestCloudMsgCheck() {\r\n    let textareaVal = this.data.textareaVal;\r\n    wx.cloud.callFunction({\r\n      name: 'msgSecCheck1',\r\n      data: {\r\n        content: textareaVal // 这里可以使用官方文档测试用例,特3456书yuuo莞6543李zxcz蒜7782法fgnv级\r\n      }\r\n    }).then(res => {\r\n      console.log(res);\r\n      // 检测到文本成功时,做一些业务\r\n    }).catch(err => {\r\n      // 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作\r\n      console.error(err);\r\n    })\r\n  }\r\n复制代码至于是在失去焦点事件时发送请求还是在点击发送按钮时发送请求,两种方式都可以。 您也可以自定义文本校验,而我个人觉得在小程序端,失去焦点时,可以自定义做一些常规敏感词的弱校验,而在点击发送按钮时,做强校验。如果是放在失去焦点时就立马请求,这样请求次数会增多,而放在点击发送按钮时进行校验,一定程度上可以减少小程序端频繁请求。接下来就是处理云函数端,使用request-promise请求请求微信内容安全接口的示例代码。/*\r\n *  Description: 利用第三方库request-promise请求微信内容安全接口\r\n *\r\n * 相关文档链接:\r\n * 微信文本内容安全接口文档https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/sec-check/security.msgSecCheck.html\r\n * access_token获取调用凭证文档\r\nhttps://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\r\n *\r\n * request-promise使用文档: https://github.com/request/request-promise\r\n *\r\n */\r\n\r\nconst APPID = \"wx21baa58c6180c2eb\"; // 注意是你自己小程序的appid\r\nconst APPSECRET = \"\"; // 你自己小程序的appsecret\r\n// 安全校验接口\r\nconst msgCheckURL = `https://api.weixin.qq.com/wxa/msg_sec_check?access_token=`;\r\n// 向下面的这个地止发送请求,携带appid和appsecret参数,获取token认证\r\nconst tokenURL = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${APPID}&secret=${APPSECRET}`\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 引入request-promise\r\nconst rp = require('request-promise');\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  try {\r\n    let tokenResponse = await rp(tokenURL);\r\n    // 获取token值,因为返回的结果是字符串,需要用JSON.parse转化为json对象\r\n    let getAccessToken = JSON.parse(tokenResponse).access_token;\r\n    // 请求微信内容安全接口,post请求,返回最终的校验结果\r\n    let checkResponse = await rp({\r\n      method: 'POST',\r\n      url: `${msgCheckURL}${getAccessToken}`,\r\n      body: {\r\n        content: event.content // 这里的event.content是小程序端传过来的值,content是要向内容接口校验的内容\r\n      },\r\n      json: true\r\n    })\r\n    return checkResponse;\r\n  } catch (err) {\r\n      console.error(err);\r\n  }\r\n}\r\n复制代码当你在小程序端输入文本,发送请求时,查看控制台下的结果时,功能是没有问题的。特3456书yuuo莞6543李zxcz蒜7782法fgnv级\r\n完2347全dfji试3726测asad感3847知qwez到\r\n\r\n复制代码您可以根据官方文档中提供的测试用例,进行测试,看具体的返回结果的。云函数请求成功,看看错误信息的反馈,对于熟悉该错误码的人清楚该文本违规了,但是反馈不是很明显,即使当下自己很清楚,然而,在过几个月在回来看代码,你或许都不知道是啥意思。 Step 5 ：错误码的正确处理方式对于处理错误码,返回具体的合适信息,对于调试代码,排查问题,也是非常重要 。 这些错误码具体的含义,在官方文档里都有对应的解释,不用去记,去查文档就行。在面试中,有很多面试官喜欢问http相关状态码的问题,状态码有很多,也真的记不住,但是常见的错误http状态码还是要知道的,我觉得,具体知道怎么处理,怎么查文档就可以了。真正考验背后目的是,对于根据后端返回的状态码,判断接口哪里出了问题,定位是前端问题还是后端问题,这是一个非常常见的问题。如果你说你不知道,没有处理过,对于候选人,那肯定是没有信服力的,无论是成功状态还是失败状态,都是应该有对应的用户提示。完整文本安全校验示例代码如下是完整的云函数端代码/*\r\n *\r\n * 相关文档链接:\r\n * 微信文本内容安全接口文档https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/sec-check/security.msgSecCheck.html\r\n * access_token获取调用凭证文档\r\nhttps://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\r\n *\r\n * request-promise使用文档: https://github.com/request/request-promise\r\n *\r\n */\r\n\r\nconst APPID = \"wx21baa58c6180c2eb\";\r\nconst APPSECRET = \"\";\r\n\r\nconst msgCheckURL = `https://api.weixin.qq.com/wxa/msg_sec_check?access_token=`;\r\n// 向下面的这个地止发送请求,携带appid和appsecret参数,获取token认证\r\nconst tokenURL = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${APPID}&secret=${APPSECRET}`\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 引入request-promise\r\nconst rp = require('request-promise');\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  try {\r\n    let tokenResponse = await rp(tokenURL);\r\n    // 获取token值,因为返回的结果是字符串,需要用JSON.parse转化为json对象\r\n    let getAccessToken = JSON.parse(tokenResponse).access_token;\r\n    // 请求微信内容安全接口,post请求,返回最终的校验结果\r\n    let checkResponse = await rp({\r\n      method: 'POST',\r\n      url: `${msgCheckURL}${getAccessToken}`,\r\n      body: {\r\n        content: event.content // 这里的event.content是小程序端传过来的值,content是要向内容接口校验的内容\r\n      },\r\n      json: true\r\n    })\r\n\r\n    // 有必要根据错误码,确定内容是否违规\r\n    if (checkResponse.errcode == 87014) {\r\n      return {\r\n        code: 500,\r\n        msg: \"内容含有违法违规内容\",\r\n        data: checkResponse\r\n      }\r\n    } else {\r\n      return {\r\n        code: 200,\r\n        msg: \"内容OK\",\r\n        data: checkResponse\r\n      }\r\n    }\r\n  } catch (err) {\r\n    if (err.errcode == 87014) {\r\n      return {\r\n        code: 500,\r\n        msg: '内容含有违法违规内容',\r\n        data: err\r\n      }\r\n    } else {\r\n      return {\r\n        code: 502,\r\n        msg: '调用msgCheckURL接口异常',\r\n        data: err\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n复制代码在云函数端,经过添加错误码的判断之后,在来看看小程序端发送的请求,返回的结果至此,我们在小程序端可以根据这个返回的错误码或成功码,进行一些业务逻辑处理的,比如给一些用户提示,在数据插入数据库之前就做一些判断操作,只有内容合规时,才插入数据库,进入下一步的业务逻辑处理。_requestCloudMsgCheck() {\r\n    let textareaVal = this.data.textareaVal;\r\n    wx.cloud.callFunction({\r\n      name: 'msgSecCheck1',\r\n      data: {\r\n        content: textareaVal\r\n      }\r\n    }).then(res => {\r\n      console.log(res);\r\n      const errcode = res.result.data.errcode;\r\n      // 检测到文本错误时,做一些业务\r\n      if (87014 === errcode) {\r\n         wx.showToast({ // 当内容违规时,做一些用户提示\r\n           title: '您输入的文本内容含有敏感内容,请重新输入',\r\n         })\r\n      }else {\r\n         // 成功时做其他业务操作\r\n      }\r\n    }).catch(err => {\r\n      // 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作\r\n      console.error(err);\r\n    })\r\n  }\r\n\r\n\r\n复制代码当输入的文本有敏感词汇时,做相对应的用户提示的注意在云函数(后)端处理错误码与小程序端都是要进行处理的,两者不要混淆了的,小程序端最终的一些业务逻辑判断,是根据后端接口返回的状态,最终决定要做什么操作的。 至此,通过request-promise库就完成了文本内容校验的问题。这个request,request-promise库非常实用,功能也非常强大,类似这种库,常见什么got,axios等之类的,都是支持promise风格的 处理方式大同小异,大家可以去npm或github上阅读相关使用文档的结语在小程序中有多种解决方案,推荐使用小程序端请求云开发云函数的方式,无论是不使用云函数方式,自己有后端服务,获取 access_token 都应该是从后端返回给前端的。而小程序的秘钥 AppSecret是不应该放在小程序端的,那样不安全的,无论是服务器开发模式还是小程序·云开发模式,都绕不过后台请求微信提供的内容安全接口,然后在返回给小程序端其实在小程序·云开发中,还提供了一种更简便的方法,那就是云调用,它是小程序·云开发提供的在云函数中调用微信开放接口的能力,只需简单的进行配置一下就可以了。限于篇幅所致,放在下一节介绍。更多内容,您可关注微信itclanCoder公众号,一个只传递和分享给你带来启发智慧有用的号"}
{"title": "微信小程序图片保存到本地一次问题解决", "author": "Rolan", "time": "2020-5-25 00:33", "content": "最近接到一个小程序保存二维码到本地的需求，以保证用户分享进行推广。看看似简单的一个小需求，其实还是挺麻烦的，为大家分享下（这里项目使用了 Taro 小程序是一样的）。步骤查看 文档 发现是现成的，很简单。代码如下// 图片下载\r\nasync downloadImage() {\r\n  try {\r\n    /**\r\n    * @param {String} src  网络图片地址\r\n    */\r\n    const { path } = Taro.getImageInfo({ src })\r\n\r\n    // 保存到相册\r\n    const saveRet = await Taro.saveImageToPhotosAlbum({ filePath: path })\r\n\r\n    if(saveRet.errMsg == 'saveImageToPhotosAlbum:ok') {\r\n      Taro.showToast({\r\n        title: '图片保存成功'\r\n      })\r\n    }\r\n    \r\n  } catch (error) {\r\n    console.log(error)\r\n  }\r\n}\r\n复制代码感觉好像是完事了，但其实还早，这才刚刚开始，刺激的在后面。授权调用相册是需要用户授权的，用户授权了还好，要是没有授权（用户选择了拒绝），就不能再进行图片下载，且没有什么提示，用户体验极差，怎么办呢。最好的办法还是对用户进行引导。如果用户选择了拒绝，当用户再次打开此页面的时候，那么我们将下载的按钮进行替换成授权相册。引导用户手动打开相册权限进行图片的下载。贴上代码供各位看官参考async openSetting() {\r\n  // 打开设置（手动授权）\r\n  const ret = await Taro.openSetting()\r\n  if(ret.authSetting['scope.writePhotosAlbum']) {\r\n    this.setState({\r\n      writePhotosAlbum: true // 权限开启状态\r\n    })\r\n  }\r\n}\r\n复制代码兼容性本以为这样就结束了，奈何QA同学又过来找，在个别安卓手机上下载不了，表现为点击 保存 没有任何反应（文件类型识别失败）。发现其实是 getImageInfo 这个方法获取不到图片信息报错导致的，惊慌失措中寻找是否有替代方案。 downloadFile 是用来保存文件到本地的缓存中，存储临时地址。想到图片其实也是属于文件，尝试是否可以借助这个方法实现。// 获取临时文件路径\r\n  const filePath = `${wx.env.USER_DATA_PATH}/${Date.now()}.jpg`\r\n  // 通过获取本地临时文件路径进行图片的保存，此文件路径是我们自己指定了文件类型，所以不会出现文件类型识别失败的情况。\r\n  const { path } = await Taro.downloadFile({\r\n    url,\r\n    filePath // 强行指定文件类型（.jpg）\r\n  })\r\n  // 图片保存\r\n  const saveRet = await Taro.saveImageToPhotosAlbum({\r\n    filePath: path\r\n  })\r\n\r\n  if(saveRet.errMsg == 'saveImageToPhotosAlbum:ok') {\r\n    Taro.showToast({\r\n      title: '图片保存成功'\r\n    })\r\n\r\n    // 保存成功之后移除缓存释放机身空间\r\n    let fileMgr = Taro.getFileSystemManager()\r\n\r\n    fileMgr.unlink({ filePath })\r\n  }\r\n复制代码这样实现之后是可以的，正好避过了 getImageInfo 获取图片类型（.png|.jpg）不成功的情况，如果各位小伙伴也遇到类似的场景，可以尝试将保存的代码修改成上面这种，能避免一些不必要的问题，如果有更好的办法，也请告知，欢迎一起学习讨论。祝工作顺利！"}
{"title": "微信小程序组件间通信", "author": "Rolan", "time": "2020-5-25 00:51", "content": "前言Anjular的路由出口真是方便的很,组件共用轻轻松松,但是小程序却没有这样的概念,至今也没有找到类似的功能的实现方法,项目中的左侧导航栏就是共用的,位置固定,页面变化只改变导航栏右侧界面,目前只得使用wx:if判断显示哪个界面,如果我们把导航栏组件引入别的界面,要想点击后调用方法,就要用到组件间通信,否则无论如何界面也不会发生改变.实现组件应用首先对导航栏组件进行封装:在leftNav组件json文件夹里添加代码:\"component\": true用以表明是自定义组件.然后在index.json里面声明引入该组件:{\r\n\"component\" : true,\r\n\"usingComponents\": {\r\n\"van-row\": \"@vant/weapp/row/index\",\r\n\"van-col\": \"@vant/weapp/col/index\",\r\n\"leftNav\":\"../leftNav/leftNav\",\r\n\"orderList\": \"../orderList/orderList\",\r\n\"listDetails\": \"../listDetails/listDetails\"\r\n      }\r\n}这样就可以在index.wxml里面应用该组件了:<van-col span=\"6\"\\>\r\n<leftNav>\r\n</leftNav>\r\n</van-col>组件通信要想实现对界面的控制,还要连通组件间的通信,在控制跳转的位置添加事件 orderList(leftNav.wxml):<van-sidebar-item class=\"menu\" bindtap=\"orderList\" title=\"订单列表\" \\>具体方法如下(leftNav.ts):orderList(){\r\nthis.triggerEvent('leftNavEvent', {menu: \"orderList\"})\r\n}triggerEvent 应用于自定义组件触发事件,表示向leftNavEvent 节点对象传入: {menu: \"orderList\"}通过自定义事件的方式通知父组件,那么信息的发送就实现了,接下来就是要让父组件接收信息(index.wxml):<van-col span=\"6\">\r\n<leftNav bind:leftNavEvent=\"onGetMenu\">\r\n</leftNav>\r\n</van-col>首先要连接到leftNavEvent,当监听到子组件触发事件时,调用方法onGetMenu(index.ts):Page({\r\ndata: {\r\nmenu: \"\"\r\n},\r\nonGetMenu(e: any) {\r\nconst menuValue = e.detail.menu\r\nthis.setData({ menu: menuValue })\r\n}\r\n});打印一下参数e的值:{type: \"leftNavEvent\", timeStamp: 8233, target: {…}, currentTarget: {…}, mark: {…}, …}\r\nchangedTouches: undefined\r\ncurrentTarget: {id: \"\", dataset: {…}}\r\ndetail: {menu: \"orderList\"}\r\nmark: {}\r\nmut: false\r\ntarget: {id: \"\", dataset: {…}}\r\ntimeStamp: 8233\r\ntouches: undefined\r\ntype: \"leftNavEvent\"\r\n_requireActive: undefined\r\n__proto__: Object我们发现之前传出的值{menu: \"orderList\"} 在detail属性里,这样就获取到传出的值了,然后用传过来的值对menu进行赋值,通过判断menu在V层的值控制界面的显示:<view>\r\n<van-row>\r\n<van-col span=\"6\">\r\n<leftNav bind:leftNavEvent=\"onGetMenu\">\r\n</leftNav>\r\n</van-col>\r\n<van-col span=\"18\">\r\n<block wx:if = \"{{menu == 'orderList'}}\">\r\n<orderList bind:orderListEvent=\"onGetMenu\"></orderList>\r\n</block>\r\n<block wx:elif=\"{{menu == 'listDetails'}}\">\r\n<listDetails></listDetails>\r\n</block>\r\n</van-col>\r\n</van-row>\r\n</view>这样一来就达到了组件共用的类似Anjular路由出口的效果:缺点就是在点击返回时总是返回初始界面,而非上一级界面,后期会改进的.具体的过程缩略如下:总结感觉微信小程序的一些功能挺繁琐的,官方给的代码也不是很完美,好在官方给的有示例,一些用法还不是很熟悉,有时候用到一些方法都不知道是官方给的,看官方文档还是很有必要的.本文作者：河北工业大学梦云智开发团队 张文达"}
{"title": "微信小程序python flask发送订阅消息(服务端使用urllib发起post请求) ...", "author": "Rolan", "time": "2020-5-26 00:11", "content": "选择模板在微信后台选择对应的消息模板小程序点击订阅参考文档地址https://developers.weixin.qq.com/miniprogram/dev/api/open-api/subscribe-message/wx.requestSubscribeMessage.html在页面设置按钮,只有当用户点击,才会弹框提醒,且允许后生效.点击一次,可发送一次订阅消息订阅消息官方文档地址https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/subscribe-message/subscribeMessage.send.html订阅消息 API 参数注意 data 里面的 data 参数名和上述的模板消息字段匹配,如 thing1,thing2data = {\r\n    # 用户的openId\r\n    \"touser\": 'ok2Q65Fte6lDt7ELrXYQ-JQIx2l8',\r\n    # 订阅消息模板id\r\n    \"template_id\": \"KDyVpbwZxn09Jm9LVGrhTTSEnHceEBKI3cRFIU-Z-fE\",\r\n    # 要跳转的页面\r\n    \"page\": \"pages/mine/index\",\r\n    # 模板消息对应的内容设置\r\n    \"data\": {\r\n        \"thing1\": {\r\n            \"value\": \"您的xx服务已到期\"\r\n        },\r\n        \"thing2\": {\r\n            \"value\": \"剩余2天时间\"\r\n        },\r\n        \"thing3\": {\r\n            \"value\": \"请尽快充值续期\"\r\n        },\r\n        \"thing4\": {\r\n            \"value\": \"巴拉巴拉\"\r\n        }\r\n    }\r\n}服务端 post 请求此处使用项目为 python flask服务端token参考地址(后台接口调用凭据,全局唯一)https://developers.weixin.qq.com/miniprogram/dev/framework/server-ability/backend-api.html# 服务端token\r\nserverToken = '33_0YjkW9kCMa-0N10emqbOcEzI4G9VCWT_r9E8cU0JfKdtu8EpgAnyGe62DQix7CKvHLtyzBY3eUV1ZSMj2RyzvaPIDuckkozn_MHLahXW11pl3PvVdxxdbVgWY4If78UjYeEOUr0ZW49gUsI3RSGhAAAUVJ'\r\n# 要请求的微信API\r\nurl = 'https://api.weixin.qq.com/cgi-bin/message/subscribe/send?access_token={serverToken}'.format(serverToken = serverToken)\r\n# 数据格式化(从这里开始对上面的data进行格式化,转成符合post的json参数形式)\r\ndata = json.dumps(data)\r\n# 数据格式化\r\ndata = bytes(data, 'utf8')\r\n# 数据格式化\r\nrequest = urllib.request.Request(url)\r\n# post服务器请求\r\nresult = urllib.request.urlopen(request, data).read()\r\n# 打印结果\r\nprint(result)推送效果当服务端发起微信订阅 API 时,对应 openid 的用户就会收到指定的订阅消息效果如图END."}
{"title": "小程序顶部导航栏，可滑动，可动态选中放大", "author": "Rolan", "time": "2020-5-14 00:41", "content": "最近在研究小程序顶部导航栏时，学到了一个不错的导航栏，今天就来分享给大家。老规矩，先看效果图可以看到我们实现了如下功能1，顶部导航栏2，可以左右滑动的导航栏3，选中条目放大原理其实很简单，我这里把我研究后的源码发给大家吧。wxml文件如下<!-- 导航栏 --><scroll-view scroll-x class=\"navbar\" scroll-with-animation scroll-left=\"{{scrollLeft}}rpx\">  <view class=\"nav-item\" wx:for=\"{{tabs}}\" wx:key=\"id\" bindtap=\"tabSelect\" data-id=\"{{index}}\">    <view class=\"nav-text {{index==tabCur?'tab-on':''}}\">{{item.name}}</view>  </view></scroll-view>wxss文件如下/* 导航栏布局相关 */.navbar {  width: 100%;   height: 90rpx;  /* 文本不换行 */  white-space: nowrap;  display: flex;  box-sizing: border-box;  border-bottom: 1rpx solid #eee;  background: #fff;  align-items: center;  /* 固定在顶部 */  position: fixed;  left: 0rpx;  top: 0rpx;}.nav-item {  padding-left: 25rpx;  padding-right: 25rpx;  height: 100%;  display: inline-block;  /* 普通文字大小 */  font-size: 28rpx;}.nav-text {  width: 100%;  height: 100%;  display: flex;  align-items: center;  justify-content: center;  letter-spacing: 4rpx;  box-sizing: border-box;}.tab-on {  color: #fbbd08;  /* 选中放大 */  font-size: 38rpx !important;  font-weight: 600;  border-bottom: 4rpx solid #fbbd08 !important;}js文件如下// pages/test2/test2.jsPage({  data: {    tabCur: 0, //默认选中    tabs: [{        name: '等待支付',        id: 0      },      {        name: '待发货',        id: 1      },      {        name: '待收货',        id: 2      },      {        name: '待签字',        id: 3      },      {        name: '待评价',        id: 4      },      {        name: '五星好评',        id: 5      },      {        name: '差评订单',        id: 6      },      {        name: '编程小石头',        id: 8      },      {        name: '小石头',        id: 9      }    ]  },  //选择条目  tabSelect(e) {    this.setData({      tabCur: e.currentTarget.dataset.id,      scrollLeft: (e.currentTarget.dataset.id - 2) * 200    })  }})代码里注释很明白了，大家自己跟着多敲几遍就可以了。后面会更新更多小程序相关的知识，请持续关注。"}
{"title": "借助云开发实现小程序短信验证码的发送", "author": "Rolan", "time": "2020-5-14 00:57", "content": "最近在做小程序验证码登陆时，用到了短信发送验证码的需求，自己也研究了下，用云开发结合云函数来实现验证码短信发送还是很方便的。老规矩，先看效果图这是我调用腾讯云的短信平台发送的登陆验证码。核心代码其实只有下面这么多是不是感觉实现起来特别简单，怎么说呢，我们代码调用其实就这么几行，就可以实现短信的发送，但是腾讯云短信模板的审核比较繁琐，还有我们先去申请短信模板，短信模板审核通过后才可以使用。我们就先来说代码实现，然后再带大家简单的学习下短信模板的申请。一、安装node类库其实我们这里用到了云开发的云函数，我们是在云函数里调用短信发送的。为什么要在云函数里调用呢，因为我们做短信发送，需要用到腾讯云的一个短信发送的类库，而这个类库是node库，所以只能在云函数里调用了。在安装这个类库之前，我们需要先创建一个云函数，关于云函数的创建，我其实已经讲过很多遍了，不知道的同学，去翻看下我的历史文章，或者看下我录制的云开发入门视频《5小时零基础入门小程序云开发》我后面也会把这节内容录制出视频出来。创建完云函数后，右键点击在终端中打开，打开终端后，在终端中输入以下命令来安装qcloudsms_js类库npm install qcloudsms_js这里需要注意，我们安装类库前需要先下载node并配置npm环境变量，这里我也有写文章的《nodeJs的安装与npm全局环境变量的配置》二，编写云函数上面类库安装好以后，我们就可以来编写云函数了。其实代码编写起来很简单，就下面这些，对应的注解我也都已经写出来了。这里要发送的手机号，和随机验证码需要动态传进来的。三，调用云函数调用云函数这里也很简单，我们需要传入手机号和验证码手机号这里，我做了一个输入框，可以动态的输入。验证码的话，我写了一个方法来随机生成数字和字母的组合验证码。我等下会把完整的代码贴出来给大家。这样我们输入完手机号以后，点击发送短信按钮，就可以成功的发送短信给到对应的手机号了。可以看到我们生成的随机验证码如下我们手机接受到的短信验证码如下这样我们做登陆或者做校验时，用户手机短信收到的验证码，和我们随机生成的验证码一样，即代表用户验证成功。完整的index.js代码给大家贴出来var chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];let phone = ''Page({  //获取随机验证码，n代表几位  generateMixed(n) {    var res = \"\";    for (var i = 0; i < n; i++) {      var id = Math.ceil(Math.random() * 35);      res += chars[id];    }    return res;  },  //调用云函数发送短信  sendSMS() {    if (phone.length != 11) {      wx.showToast({        icon: 'none',        title: '输入11位手机号',      })      return    }    let code = this.generateMixed(4)    console.log('本地生成的验证码', code)    wx.cloud.callFunction({      name: \"sendSms\",      data: {        phone: phone,        code: code //生成4位的验证码      }    }).then(res => {      console.log('发送成功', res)    }).catch(res => {      console.log('发送失败', res)    })  },  //获取要发送的手机号  getPhone(event) {    console.log(event.detail.value)    phone = event.detail.value  },})index.wxml如下到这里我们的短信验证码的发送就完整的实现了，是不是很简单。短信发送参数的设置与获取首先是去腾讯云自己开通短信功能，然后需要自己去申请模板，填写签名。我这里把所需要的参数，都给大家标准出来了。大家只需要自己去官网设置对应的模板和签名，然后审核通过后，把对应的参数放到我们的云函数里即可。短信验证的原理讲解在网上找了一张短信验证的原理图，如下大家可以对照这看下，这个原理图。对应的源码我上面其实已经给大家贴出来了。如果大家觉得不完整，我也已经把完整源码放到网盘里了，有需要的同学可以到我公号里回复“短信”获取源码。"}
{"title": "微信小程序--hidden不生效原因及解决方案", "author": "Rolan", "time": "2020-5-15 00:25", "content": "微信官方文档里有提到说hidden是所有组件都有的属性，但我实际编码中发现并不是这样的！！！！例如如下布局：    <view hidden=\"true\" style=\"display:flex;flex-direction: row;\">        <text>text1</text>        <text>text2</text>    </view>你会发现hidden没生效。经我实验发现hidden元素对块状布局才生效，所以这段代码里导致hidden没生效的罪魁祸首是display:flex。把这个去掉就可以了。如果一定要用flex布局怎么办？其实这里想用hidden无非就是想影藏这个布局，display:none也能做到隐藏。这里可以用一个取巧的方法，动态设置display属性，示例如下：    <view hidden=\"true\" style=\"display:{{hideview ? none : flex}};flex-direction: row;\">        <text>text1</text>        <text>text2</text>    </view>这里的hideview是在对应的js里是一个变量，由js来动态控制。后话hidden 隐藏布局，虽然隐藏了，但是还是会占空间。display:none 隐藏不占据空间。"}
{"title": "小程序的表单的组件化封装及使用", "author": "Rolan", "time": "2020-5-15 00:32", "content": "表单一直是类web项目中开发的难点，表单涉及UI,交互，校验，接口，回填等各种坑点，设计表单模块时需要有一个统一的设计思想，在`queryUI`项目中，我们统一了表单的结构，丰富了表单的API，赋予了各种表单的联动支持配置化表单统一的表单结构丰富的API，简化出错，提示等操作支持任一表单元素之间的联动原生微信所有表单组件支持引入queryUI引入 queryUI 的核心库，请参考 GITHUB示例代码https://github.com/webkixi/aotoo-xquery \r\n=> pages/form    \r\n复制代码表单组件的使用queryUI 表单由配置文件生成，表单属性构成大致如下图文本表单使用wxml<ui-form wx:if=\"{{formConfig}}\" dataSource=\"{{formConfig}}\" /> \r\n复制代码jsconst Pager = require('../../components/aotoo/core/index')\r\nconst config = [\r\n  {\r\n    title: '文本框表单区域',\r\n    desc: '说明信息',\r\n    input: [\r\n      {\r\n        id: 'aaa', type: 'text', title: '文本', placeholder: '数字输入键盘', \r\n        error: '错误信息',\r\n        desc: '说明信息'\r\n        bindblur: 'onbindblur',\r\n        bindinput: 'onbindinput',\r\n        bindfocus: 'onbindfocus',\r\n        bindconfirm: 'onbindconfirm',\r\n        bindkeyboardheightchange: 'onbindkeyboardheightchange',\r\n      },\r\n    ]\r\n  },\r\n\r\n  {\r\n    title: '数字表单区域',\r\n    input: [\r\n      {id: 'ccc', type: 'number', title: '整数型', placeholder: '数字输入键盘', bindblur: 'onBlur'},\r\n      {id: 'ddd', type: 'idcard', title: '身份证', placeholder: '身份证输入键盘', bindblur: 'onBlur'},\r\n      {id: 'eee', type: 'password', title: '密码串', maxlength: 30, placeholder: '隐藏的密码串', bindblur: 'onBlur'}\r\n    ]\r\n  },\r\n\r\n  {\r\n    title: 'TEXTAREA',\r\n    input: [\r\n      {id: 'aaa', type: 'textarea', title: '文本域', placeholder: '输入文字', bindblur: 'onBlur'},\r\n    ]\r\n  },\r\n]\r\n\r\nconst mthSet = {\r\n  onbindblur(e) {\r\n    console.log('=====text', e.detail.value);\r\n  },\r\n  onbindinput(e) {\r\n    console.log('=====text', e);\r\n  },\r\n  onbindfocus(e) {\r\n    console.log('=====text', e);\r\n  },\r\n  onbindconfirm(e) {\r\n    console.log('=====text', e);\r\n  },\r\n  onbindkeyboardheightchange(e) {\r\n    console.log('=====text', e);\r\n  },\r\n}\r\n\r\nPager({\r\n  data: {\r\n    formConfig: {\r\n      $$id: 'myForm',\r\n      formStyle: 'width: 90vw;',\r\n      data: config,\r\n      methods: mthSet\r\n    },\r\n  }\r\n})\r\n复制代码slider表单wxml<ui-form wx:if=\"{{formConfig}}\" dataSource=\"{{formConfig}}\" />  \r\n复制代码jsconst Pager = require('../../components/aotoo/core/index')\r\nconst config = [\r\n  {\r\n    title: '事件绑定',\r\n    input: [\r\n      {\r\n        id: 'test_slider',\r\n        title: 'slider',\r\n        type: 'slider',\r\n        value: 50,\r\n        bindchange: 'onSliderChange',\r\n        bindchanging: 'onSliderChanging',\r\n      }\r\n    ]\r\n  },\r\n],\r\n\r\nconst mthSet = {\r\n  onSliderChange(e){\r\n    console.log('======= slider change', e);\r\n  },\r\n  onSliderChanging(e){\r\n    console.log('======= slider changing', e);\r\n  },\r\n}\r\n\r\nPager({\r\n  data: {\r\n    formConfig: {\r\n      $$id: 'myForm',\r\n      formStyle: 'width: 90vw;',\r\n      data: config,\r\n      methods: mthSet\r\n    },\r\n  }\r\n})\r\n复制代码复选框/单选框及表单事件绑定同步微信小程序官方原生方法wxml<ui-form wx:if=\"{{formConfig}}\" dataSource=\"{{formConfig}}\" />\r\n复制代码jsconst Pager = require('../../components/aotoo/core/index')\r\nconst config = [\r\n  {\r\n    title: '事件绑定',\r\n    input: [\r\n      {\r\n        name: 'test_checkbox1',\r\n        type: 'checkbox',\r\n        title: '复选框',\r\n        value: ['1', '3'],\r\n        values: ['1', '2', '3'],\r\n        titles: ['篮球', '足球', '羽毛球'],\r\n        bindchange: 'onbindchange'\r\n      }\r\n    ]\r\n  },\r\n],\r\n\r\nconst mthSet = {\r\n  onbindchange(e) {\r\n    console.log('======= checkbox', e);\r\n  },\r\n}\r\n\r\nPager({\r\n  data: {\r\n    formConfig: {\r\n      $$id: 'myForm',\r\n      formStyle: 'width: 90vw;',\r\n      data: config,\r\n      methods: mthSet\r\n    },\r\n  }\r\n})\r\n复制代码评分表单事件绑定原生组件不包含此类型表单，此表单类型为`queryUI`特有支持默认赋值支持点击赋值支持拖动赋值wxml<ui-form wx:if=\"{{formConfig}}\" dataSource=\"{{formConfig}}\" />  \r\n复制代码jsconst Pager = require('../../components/aotoo/core/index')\r\nconst config = [\r\n  {\r\n    itemClass: 'input-rating-list',\r\n    title: '评分表单',\r\n    input: {\r\n      id: 'ratingit',\r\n      title: '服务态度',\r\n      type: 'rating',\r\n      value: 4,  // 默认值\r\n      max: 7, // 最大星星数\r\n      tap: 'ratingChecked',  // 响应点击/滑动事件回调\r\n    }\r\n  },\r\n]\r\n\r\nconst mthSet = {\r\n  ratingChecked(e, param) {\r\n    console.log('======= rating', e);\r\n  },\r\n}\r\n\r\nPager({\r\n  data: {\r\n    formConfig: {\r\n      $$id: 'myForm',\r\n      formStyle: 'width: 90vw;',\r\n      data: config,\r\n      methods: mthSet\r\n    },\r\n  }\r\n})\r\n复制代码picker表单事件绑定wxml<ui-form wx:if=\"{{formConfig}}\" dataSource=\"{{formConfig}}\" />  \r\n复制代码jsconst Pager = require('../../components/aotoo/core/index')\r\n    const config = [\r\n      {\r\n        title: '事件绑定',\r\n        input: [\r\n          {\r\n            id: 'test_pickers2',\r\n            type: 'picker',\r\n            title: '标题',\r\n            values: [\r\n              [\r\n                {title: '猫科', id: '100', select: true},\r\n                {title: '狗科', id: '101'},\r\n              ],\r\n              [\r\n                {title: '老虎', id: '102'},\r\n                {title: '狮子', id: '103'},\r\n                {title: '豹子', id: '104', select: true},\r\n                {title: '野狗', id: '105'},\r\n              ],\r\n            ],\r\n            bindchange: 'pickerChange',\r\n            bindcolumnchange: 'columnChangeAction',\r\n          },\r\n        ]\r\n      },\r\n    ],\r\n\r\n    const mthSet = {\r\n      pickerChange(e) {\r\n        console.log(e);\r\n      },\r\n      columnChangeAction(e){\r\n        if (e.detail.column === 0) {\r\n          if (e.detail.value === 0) {\r\n            this.updateNextColumn([  // 更新下一列\r\n              {title: '老虎', id: '102'},\r\n              {title: '狮子', id: '103'},\r\n              {title: '豹子', id: '104', select: true},\r\n              {title: '野狗', id: '105'},\r\n            ])\r\n          }\r\n          if ( e.detail.value === 1) {\r\n            this.updateNextColumn([ // // 更新下一列\r\n              {title: '老虎', id: '102'},\r\n              {title: '狮子', id: '103', select: true},\r\n            ])\r\n          }\r\n        }\r\n      },\r\n    }\r\n\r\n    Pager({\r\n      data: {\r\n        formConfig: {\r\n          $$id: 'myForm',\r\n          formStyle: 'width: 90vw;',\r\n          data: config,\r\n          methods: mthSet\r\n        },\r\n      }\r\n    })\r\n复制代码this.updateNextColumn方法为更新下一列数据，输入数组取值我们可以通过事件方法(e.detail.value)取值，同时提供 getValue() 方法，一次性获取所有表单的值getValue([id])通过form的实例获取表单元素的值设置id 获取指定id的表单元素值不指定id 获取所有表单元素的值wxml<ui-form wx:if=\"{{formConfig}}\" dataSource=\"{{formConfig}}\" />  \r\n复制代码jsconst Pager = require('../../components/aotoo/core/index')\r\nconst config = [\r\n  {\r\n    title: '事件绑定',\r\n    input: [\r\n      {\r\n        id: 'aaa', type: 'text', title: '文本', placeholder: '请输入相关文字',\r\n        value: '辛辛苦苦，苦苦逼逼',\r\n        bindblur: 'onbindblur',\r\n      },\r\n    ]\r\n  },\r\n]\r\n\r\nconst mthSet = {\r\n  onbindblur(e) {\r\n    console.log('=====text', e.detail.value);\r\n    let result = this.getValue()  // 返回一个id为key名的对象，包含表单元素的实时value,type等属性\r\n  },\r\n}\r\n\r\nPager({\r\n  data: {\r\n    formConfig: {\r\n      $$id: 'myForm',\r\n      formStyle: 'width: 90vw;',\r\n      data: config,\r\n      methods: mthSet\r\n    },\r\n  }\r\n})\r\n复制代码表单赋值点击按钮给表单赋值setValue(id, value) 为某个指定id的表单赋值empty([id]) 清空所有表单，或者清空指定id的表单wxml<ui-form wx:if=\"{{formConfig}}\" dataSource=\"{{formConfig}}\" />  \r\n复制代码jsconst Pager = require('../../components/aotoo/core/index')\r\nconst config = [\r\n  {\r\n    title: '事件绑定',\r\n    input: [\r\n      {\r\n        id: 'aaa', type: 'text', title: '文本', value: '好好学习'\r\n      },\r\n      {\r\n        id: 'bbb', type: 'text', title: '文本', value: '天天向上'\r\n      },\r\n      {\r\n        id: 'ccc', type: 'button', size: 'default', value: '点击清空', placeholder: '配置为无效表单',\r\n        itemStyle: 'height: 50px; line-height: 50px; background-color: red;',\r\n        tap: 'onTap'\r\n      },\r\n    ]\r\n  },\r\n]\r\n\r\nconst mthSet = {\r\n  onTap(e) {\r\n    this.empty()  // 默认清空所有表单value, this.empty('aaa') 指定清空aaa\r\n    this.setValue('ccc', '点击清空')  // 因为button的value被清空了，重新赋值\r\n  }\r\n}\r\n\r\nPager({\r\n  data: {\r\n    formConfig: {\r\n      $$id: 'myForm',\r\n      formStyle: 'width: 90vw;',\r\n      data: config,\r\n      methods: mthSet\r\n    },\r\n  }\r\n})\r\n复制代码设置提示信息上例中请任意输入数据，或者正确输入111addWarn(id, message)添加警告信息removeWarn(id)移除警告信息addDesc(id, message)添加警告信息removeDesc(id)移除警告信息wxml<ui-form wx:if=\"{{formConfig}}\" dataSource=\"{{formConfig}}\" />  \r\n复制代码jsconst Pager = require('../../components/aotoo/core/index')\r\nconst config = [\r\n  {\r\n    title: '事件绑定',\r\n    input: [\r\n      {\r\n        id: 'aaa', type: 'text', title: '文本', placeholder: '请输入相关文字',\r\n        bindblur: 'onbindblur',\r\n      },\r\n    ]\r\n  },\r\n]\r\n\r\nconst mthSet = {\r\n  onbindblur(e) {\r\n    let value = e.detail.value\r\n    if (value !== '111') {\r\n      this.addWarn('aaa', '请输入正确信息')\r\n    } else {\r\n      this.removeWarn('aaa')\r\n    }\r\n  }\r\n}\r\n\r\nPager({\r\n  data: {\r\n    formConfig: {\r\n      $$id: 'myForm',\r\n      formStyle: 'width: 90vw;',\r\n      data: config,\r\n      methods: mthSet\r\n    },\r\n  }\r\n})\r\n复制代码"}
{"title": "小程序request 支持content-type为form-data 的两种使用方式", "author": "Rolan", "time": "2020-5-18 00:22", "content": "最近做了一个小程序上传文件的需求，在这个需求中，需要联调的接口要求请求头的content-type值需要设置为application/form-data，然而小程序提供的wx.request到目前为止（2020.05.14）暂不支持该设置，也许使用者会说能设置，但是发送请求时依旧会存在问题。。。因此，就需要去寻找各种解决方法，最终找到了两种处理方式，整理如下；当然，不排除还有其他实现思路。方式一其实小程序是有单独为上传文件做了一个定制的api去支持 application/form-data 的请求啦，所以莫慌。UploadTask wx.uploadFile(Object object)将本地资源上传到服务器。客户端发起一个 HTTPS POST 请求，其中 content-type 为 multipart/form-data。使用前请注意阅读相关说明。示例使用代码wx.chooseImage({\r\n  success (res) {\r\n    const tempFilePaths = res.tempFilePaths\r\n    wx.uploadFile({\r\n      url: 'https://example.weixin.qq.com/upload', //仅为示例，非真实的接口地址\r\n      filePath: tempFilePaths[0],\r\n      name: 'file',\r\n      formData: {\r\n        'user': 'test'\r\n      },\r\n      success (res){\r\n        const data = res.data\r\n        //do something\r\n      }\r\n    })\r\n  }\r\n})\r\n复制代码想了解更多，请点 详细文档方式二当然，我们也可以发现，微信提供的这个 uploadFile 只是比较使用上传的场景，如果是其他场景，使用起来可能就不是很舒适，所以就该进行一下form-data 的相应封装。封住方法如下：// 小程序直接设置content-type为''multipart/form-data;'无效，故需要手动封装form-data；XXX为边界值\r\nfunction formdata (obj = {}) {\r\n  let result = ''\r\n  for (let name of Object.keys(obj)) {\r\n    let value = obj[name];\r\n    result += \r\n    '\\r\\n--XXX' +\r\n    '\\r\\nContent-Disposition: form-data; name=\\\"'+ name +'\\\"'+ \r\n    '\\r\\n' +\r\n    '\\r\\n' + value\r\n  }\r\n  return result + '\\r\\n--XXX--'\r\n}\r\n复制代码注意，除了需要对传入的数据（对象）进行格式化为 form-data，之外，还需要设置header 的 content-type 为 'multipart/form-data; boundary=XXX';参考文章微信开发者文档微信开发讨论相关文章"}
{"title": "微信小程序添加卡券跳坑", "author": "Rolan", "time": "2020-5-18 00:31", "content": "引言应公司业务需求，用户可以在我方小程序里面领取合作方卡券到卡包。开发过程中发现，微信对于卡券的文档说明过于简单凌乱，以至于中间遇到了很多坑，这里做一个整理记录一下。需求这次需求主要是，合作方创建卡券，在我方小程序进行领取。这篇文章是基于卡券已经成功创建的基础上进行开发的。如何创建卡券，请参考 微信文档-创建卡券正文刚接到这个需求的时候，查看了一下微信文档，发现微信提供了一个添加卡券的APIwx.addCard({\r\n  cardList: [\r\n    {\r\n      cardId: '',\r\n      cardExt: '{\"code\": \"\", \"openid\": \"\", \"timestamp\": \"\", \"signature\":\"\"}'\r\n    }, {\r\n      cardId: '',\r\n      cardExt: '{\"code\": \"\", \"openid\": \"\", \"timestamp\": \"\", \"signature\":\"\"}'\r\n    }\r\n  ],\r\n  success (res) {\r\n    console.log(res.cardList) // 卡券添加结果\r\n  }\r\n})\r\n复制代码乍一看，感觉很简单，只要传cardId和cardExt就好了。但是cardExt是什么呢？文档只是提了一句cardExt 是卡券的扩展参数，其值是一个 JSON 字符串。看得我一脸懵逼，于是去找了公众号的官方文档，在 附录4 找到了cardExt的说明。其他字段都比较好理解，但是signature怎么获取呢？别急，文档也做了说明# 签名说明\r\n\r\n1.将 api_ticket、timestamp、card_id、code、openid、nonce_str的value值进行字符串的字典序排序。\r\n\r\n2.将所有参数字符串拼接成一个字符串进行sha1加密，得到signature。\r\n\r\n3.signature中的timestamp，nonce字段和card_ext中的timestamp，nonce_str字段必须保持一致。\r\n复制代码好不容易知道签名怎么生成，结果又出现了 api_ticket 这个不知道从哪里冒出来的参数。好在文档也进行了说明卡券 api_ticket 是用于调用卡券相关接口的临时票据，有效期为 7200 秒，通过 access_token 来获取。这里要注意与 jsapi_ticket 区分开来。由于获取卡券 api_ticket 的 api 调用次数非常有限，频繁刷新卡券 api_ticket 会导致 api 调用受限，影响自身业务，开发者必须在自己的服务全局缓存卡券 api_ticket 。\r\n\r\n1.参考以下文档获取access_token（有效期7200秒，开发者必须在自己的服务全局缓存access_token）：../15/54ce45d8d30b6bf6758f68d2e95bc627.html\r\n\r\n2.用第一步拿到的access_token 采用http GET方式请求获得卡券 api_ticket（有效期7200秒，开发者必须在自己的服务全局缓存卡券 api_ticket）：https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&type=wx_card\r\n复制代码简单来说就是get请求这个地址获取api_tickethttps://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=创建卡券公众号的ACCESSTOKEN&type=wx_card ,ok,api_ticket已经拿到了,下面就是生成签名了。这里微信提供了一个 官方校验工具 做调试，把参数 （这里注意，timestamp的单位是秒，不是毫秒） 都填进去就可以生成签名了拿到签名之后，再把它套进 cardExt 对象进行序列化，然后再放入 wx.addCard 里面就可以了到这里基本添加卡券所需要的参数就都能获取到了，顺利的话，应该可以在小程序顺利调用添加卡券的API，得到以下页面常见错误如果按照以上步骤进行依旧不能成功调用的话，别急，微信还出了一个文档总结了常见错误： 卡券签名错误排查方法 大家跟着文章说到的问题慢慢排查，基本都能成功的。"}
{"title": "Taro UI开发小程序实现 左滑喜欢 右滑不喜欢效果", "author": "Rolan", "time": "2020-5-18 00:47", "content": "摘要：      年后入职了一家新公司，与前同事交接完之后，发现公司有一个四端的项目（iOS，Android，H5，小程序），iOS和安卓都实现了左滑右滑的效果，而h5和小程序端没实现，询问得知前同事因网上没找到对应的插件，相关博客也特别少，所以没做就搁置下来了。      趁这段时间相对来说比较富裕，于是乎在网上也搜索了一下，发现确实很少，但是有人提到可以用小程序可拖动组件movable-view来实现，自己尝试来一下发现可行，于是来写这篇博客记录一下，希望能帮助到后面需要用到这个功能的人！ 先上效果图： 主要技术：Taro+Taro UI+React（如果你是小程序原生或者uniapp+vue写法都差不多，可以通用）可拖动组件文档地址：Taro: https://taro-docs.jd.com/taro/docs/components/viewContainer/movable-view.html微信小程序：https://developers.weixin.qq.com/miniprogram/dev/component/movable-view.html 思路：一，我们首先把movable-area和movable-view标签写出来；<movable-area>\r\n    <movable-view>\r\n       ......\r\n    </movable-view>\r\n</movable-area>二，我们可以看到文档里面有一个onChange方法，即拖动过程中触发的事件；<movable-area>\r\n    <movable-view onChange ={this. onChange.bind(this)}>\r\n       ......\r\n    </movable-view>\r\n</movable-area>\r\n\r\n// 触发方法，打印参数\r\nonChange(e) {\r\n   console.log('参数',e);\r\n}我们可以看到打印出了，拖动的位置和产生移动的原因等；三，我们接着加入开始onTouchstart，移动onTouchmove，结束onTouchcancel，onTouchend三个事件方法；<MovableView  \r\n  key={item.id} \r\n  onTouchcancel={this.onCancel} \r\n  onTouchend={this.onCancel} \r\n  onTouchstart={this.onTouchStart} \r\n  onTouchmove={this.onTouchMove} \r\n  x={this.state.x}  // 横坐标位置\r\n  y={this.state.y}  // 纵坐标位置\r\n  direction='all'  // 移动方向都可以\r\n  outOfBounds  // 可超过可移动区域\r\n  className='shop-imgbox' \r\n> \r\n<--中间加入图片之类的滑动内容-->\r\n</MovableView> \r\n                    初始数据如下：state = { \r\n    x: '16', \r\n    y: '16', \r\n    like: false, \r\n    unlike: false, \r\n    shopList: [ \r\n      { \r\n        img: 'https://edgefix-image.edgecom.top/ABD846F6672997A7F76CD38E8A57F954.jpg', \r\n      }, \r\n      { \r\n        img: 'https://edgefix-image.edgecom.top/F6E5801C304CC76DA63C02C9FB38B8F4.jpg', \r\n      }, \r\n      { \r\n        img: 'https://edgefix-image.edgecom.top/D518952AD1DD61B2D32556E20CC527C4.jpg', \r\n      }, \r\n      { \r\n        img: 'https://edgefix-image.edgecom.top/1D187E28B349679908A44BBE81F3D3CA.jpg', \r\n      }, \r\n      { \r\n        img: 'https://edgefix-image.edgecom.top/1129A411AC9CF5F81187CBED181B6F57.jpg', \r\n      } \r\n    ] \r\n  } 三个方法我们可以取到移动后改变的位置，来改变喜欢与不喜欢的状态css，以及实现卡片滑动的效果：1.触摸触发的时候，我们获取到刚刚开始触摸卡片的x，y的位置坐标；2.在触摸滑动时，我们通过滑动后的位置-滑动前的位置，来判断距离多少来改变喜欢和不喜欢的值；3.当手离开时，触发取消事件，我们需要把状态数据改为原始值，即回到最初的状态；// 触摸触发 \r\n  onTouchStart(e) { \r\n    console.log('222',e.touches[0].pageX); \r\n    this.setState({ \r\n      x: e.touches[0].pageX, \r\n      y: e.touches[0].pageY, \r\n    }); \r\n  } \r\n  // 触摸移动 \r\n  onTouchMove(e) { \r\n    console.log('333',e.touches[0].pageX); \r\n    let dx = e.touches[0].pageX - this.state.x; \r\n    if (dx > 50) { \r\n      this.setState({ \r\n        like: true, \r\n        unlike: false, \r\n      }); \r\n    } else if (dx < -50) { \r\n      this.setState({ \r\n        like: false, \r\n        unlike: true, \r\n      }); \r\n    } else { \r\n      this.setState({ \r\n        like: false, \r\n        unlike: false, \r\n      }); \r\n    } \r\n  } \r\n  // 取消 \r\n  onCancel(e) { \r\n    console.log('444',e.changedTouches[0].pageX); \r\n    this.setState({ \r\n      x: '16', \r\n      y: '16', \r\n      like: false, \r\n      unlike: false, \r\n    }); \r\n  } 当我们写到这里，我们去拖动我们的卡片时，你会发现确实可以拖动，并且取消的时候会回到原点，但是同样你也会发现一个问题，就是你拖动的时候，五张卡片都被触发来移动的效果，出现了触点混乱的问题，查找问题发现卡片共用了x，y，因此我们可以给每张卡片设置独立的参数；四，给每张卡片独立的参数并且设置卡片倾斜度效果；1.设置倾斜度效果style={{transform:'rotate('+this.state.tiltAngle[index]+'deg)'}}然后我们通过卡片移动位置计算出一个你决定合适的倾斜角度；// 拖动后相差距离进行换算角度\r\nlet dxangle = (e.touches[0].pageX - this.state.startX) * 45 / 500;2.设置独立的参数方法携带索引，我们取到对应的卡片index，来改变对应卡片的数据；<MovableView \r\n  key={item.id}\r\n  onTouchcancel={this.onCancel.bind(this,index)}\r\n  onTouchend={this.onCancel.bind(this,index)}\r\n  onTouchstart={this.onTouchStart.bind(this,index)}\r\n  onTouchmove={this.onTouchMove.bind(this,index)}\r\n  x={this.state.x[index]} \r\n  y={this.state.y[index]} \r\n  direction='all' \r\n  outOfBounds \r\n  className='shop-imgbox'\r\n>\r\n</MovableView>同时，我们需要改变初始参数的形式为数组，我们通过索引改变对应卡片的值；state = {\r\n    // 开始位置\r\n    startX: '',\r\n    // 开始位置-最终位置距离\r\n    placeX: '',\r\n    // 倾斜角度\r\n    tiltAngle: ['0','0','0','0','0'],\r\n    // 坐标\r\n    x: ['16','16','16','16','16'],\r\n    y: ['16','16','16','16','16'],\r\n    // 是否喜欢状态\r\n    like: [false,false,false,false,false],\r\n    unlike: [false,false,false,false,false],\r\n    // 推荐商品数组\r\n    shopList: [\r\n      {\r\n        id: 1,\r\n        img: 'https://edgefix-image.edgecom.top/ABD846F6672997A7F76CD38E8A57F954.jpg',\r\n      },\r\n      {\r\n        id: 2,\r\n        img: 'https://edgefix-image.edgecom.top/F6E5801C304CC76DA63C02C9FB38B8F4.jpg',\r\n      },\r\n      {\r\n        id: 3,\r\n        img: 'https://edgefix-image.edgecom.top/D518952AD1DD61B2D32556E20CC527C4.jpg',\r\n      },\r\n      {\r\n        id: 4,\r\n        img: 'https://edgefix-image.edgecom.top/1D187E28B349679908A44BBE81F3D3CA.jpg',\r\n      },\r\n      {\r\n        id: 5,\r\n        img: 'https://edgefix-image.edgecom.top/1129A411AC9CF5F81187CBED181B6F57.jpg',\r\n      }\r\n    ]\r\n  }方法我们就举一个例子，比如onTouchStart方法，我们遍历卡片数组，通过判断索引来得到是那张卡片，从而来改变对应值// 触摸触发\r\n  onTouchStart(index,e) {\r\n    console.log('1111',index,e.touches[0].pageX,e.touches[0].pageY);\r\n    // 重定义数组\r\n    var againX = [];\r\n    var againY = [];\r\n    // 遍历，判断拖动的该数组的位置\r\n    for (var i=0; i<this.state.shopList.length; i++){\r\n      if (i == index) {\r\n        againX[i] = e.touches[0].pageX;\r\n        againY[i] = e.touches[0].pageY;\r\n      } else {\r\n        againX[i] = '16';\r\n        againY[i] = '16';\r\n      }\r\n    }\r\n    // 赋值\r\n    this.setState({\r\n      startX: e.touches[0].pageX,\r\n      x: againX,\r\n      y: againY,\r\n    });\r\n  }这样，我们运行代码，发现拖动第一张卡片不会影响到后面卡片的位置了，同时，我们现在拖动卡片删除的是数组，在实际项目中，我们在触发删除数组的地方接入接口，调用喜欢，不喜欢改变数据参数，从而也能改变数组的长度；五，完整代码；下面我将贴出完整的代码供大家参考html文件：import Taro, { Component } from '@tarojs/taro';\r\nimport { View, Image, Button, Text, MovableArea, MovableView } from '@tarojs/components';\r\nimport { observer, inject } from '@tarojs/mobx';\r\nimport { AtButton, AtFloatLayout  } from 'taro-ui';\r\nimport userStore from '../../store/user.store';\r\n\r\nimport './stroll.scss';\r\n\r\n@inject('userStore')\r\n@observer\r\nclass Stroll extends Component {\r\n  config = {\r\n    navigationBarTitleText: '逛',\r\n  }\r\n\r\n  state = {\r\n    // 开始位置\r\n    startX: '',\r\n    // 开始位置-最终位置距离\r\n    placeX: '',\r\n    // 倾斜角度\r\n    tiltAngle: ['0','0','0','0','0'],\r\n    // 坐标\r\n    x: ['16','16','16','16','16'],\r\n    y: ['16','16','16','16','16'],\r\n    // 是否喜欢状态\r\n    like: [false,false,false,false,false],\r\n    unlike: [false,false,false,false,false],\r\n    // 推荐商品数组\r\n    shopList: [\r\n      {\r\n        id: 1,\r\n        img: 'https://edgefix-image.edgecom.top/ABD846F6672997A7F76CD38E8A57F954.jpg',\r\n      },\r\n      {\r\n        id: 2,\r\n        img: 'https://edgefix-image.edgecom.top/F6E5801C304CC76DA63C02C9FB38B8F4.jpg',\r\n      },\r\n      {\r\n        id: 3,\r\n        img: 'https://edgefix-image.edgecom.top/D518952AD1DD61B2D32556E20CC527C4.jpg',\r\n      },\r\n      {\r\n        id: 4,\r\n        img: 'https://edgefix-image.edgecom.top/1D187E28B349679908A44BBE81F3D3CA.jpg',\r\n      },\r\n      {\r\n        id: 5,\r\n        img: 'https://edgefix-image.edgecom.top/1129A411AC9CF5F81187CBED181B6F57.jpg',\r\n      }\r\n    ]\r\n  }\r\n\r\n  componentWillMount () { }\r\n\r\n  componentWillReact () { }\r\n\r\n  componentDidMount () {\r\n  }\r\n\r\n  // 触摸触发\r\n  onTouchStart(index,e) {\r\n    console.log('1111',index,e.touches[0].pageX,e.touches[0].pageY);\r\n    // 重定义数组\r\n    var againX = [];\r\n    var againY = [];\r\n    // 遍历，判断拖动的该数组的位置\r\n    for (var i=0; i<this.state.shopList.length; i++){\r\n      if (i == index) {\r\n        againX[i] = e.touches[0].pageX;\r\n        againY[i] = e.touches[0].pageY;\r\n      } else {\r\n        againX[i] = '16';\r\n        againY[i] = '16';\r\n      }\r\n    }\r\n    // 赋值\r\n    this.setState({\r\n      startX: e.touches[0].pageX,\r\n      x: againX,\r\n      y: againY,\r\n    });\r\n  }\r\n  // 触摸离开\r\n  onTouchMove(index,e) {\r\n    console.log('2222',index,e.touches[0].pageX,e.touches[0].pageY);\r\n    // 重定义数组\r\n    var tiltAngleT = [];\r\n    var againX = [];\r\n    var againY = [];\r\n    // 拖动后相差距离\r\n    let dxplace = e.touches[0].pageX - this.state.startX;\r\n    // 拖动后相差距离进行换算角度\r\n    let dxangle = (e.touches[0].pageX - this.state.startX) * 45 / 500;\r\n    console.log(dxangle);\r\n    // 遍历，判断拖动的该数组的位置\r\n    for (var i=0; i<this.state.shopList.length; i++){\r\n      if (i == index && dxplace > 50) {\r\n        tiltAngleT[i] = dxangle,\r\n        againX[i] = true;\r\n        againY[i] = false;\r\n      } else if (i == index && dxplace <= -50) {\r\n        tiltAngleT[i] = dxangle,\r\n        againX[i] = false;\r\n        againY[i] = true;\r\n      } else if (i == index && dxplace < 50 && dxplace > -50) {\r\n        tiltAngleT[i] = dxangle,\r\n        againX[i] = false;\r\n        againY[i] = false;\r\n      } else {\r\n        tiltAngleT[i] = '0',\r\n        againX[i] = false;\r\n        againY[i] = false;\r\n      }\r\n    }\r\n    // 赋值\r\n    this.setState({\r\n      placeX: dxplace,\r\n      tiltAngle: tiltAngleT,\r\n      like: againX,\r\n      unlike: againY,\r\n    });\r\n  }\r\n  // 取消\r\n  onCancel(index,e) {\r\n    console.log('3333',index,e.changedTouches[0].pageX,e.changedTouches[0].pageY);\r\n    // 赋值\r\n    this.setState({\r\n      tiltAngle: ['0','0','0','0','0'],\r\n      x: ['16','16','16','16','16'],\r\n      y: ['16','16','16','16','16'],\r\n      like: [false,false,false,false,false],\r\n      unlike: [false,false,false,false,false],\r\n    });\r\n    // 如果偏移已经达到则清除第一张图片\r\n    if (this.state.placeX > 50 || this.state.placeX < -50) {\r\n      this.setState({\r\n        shopList: this.state.shopList.splice(1,4),\r\n      });\r\n    }\r\n  }\r\n  // 不喜欢按钮点击\r\n  dislikebtn() {\r\n    // 改变按钮的状态以及图片位置及显示\r\n    this.setState({\r\n      tiltAngle: ['-18','0','0','0','0'],\r\n      x: ['-30','16','16','16','16'],\r\n      y: ['267','16','16','16','16'],\r\n      unlike: [true,false,false,false,false],\r\n    }, () => {\r\n      setTimeout( () => {\r\n        this.setState({\r\n          tiltAngle: ['0','0','0','0','0'],\r\n          x: ['16','16','16','16','16'],\r\n          y: ['16','16','16','16','16'],\r\n          unlike: [false,false,false,false,false],\r\n          shopList: this.state.shopList.splice(1,4),\r\n        });\r\n      },100);\r\n    });\r\n  }\r\n  // 喜欢按钮点击\r\n  likebtn() {\r\n    // 改变按钮的状态以及图片位置及显示\r\n    this.setState({\r\n      tiltAngle: ['18','0','0','0','0'],\r\n      x: ['284','16','16','16','16'],\r\n      y: ['267','16','16','16','16'],\r\n      like: [true,false,false,false,false],\r\n    }, () => {\r\n      setTimeout( () => {\r\n        this.setState({\r\n          tiltAngle: ['0','0','0','0','0'],\r\n          x: ['16','16','16','16','16'],\r\n          y: ['16','16','16','16','16'],\r\n          like: [false,false,false,false,false],\r\n          shopList: this.state.shopList.splice(1,4),\r\n        });\r\n      },100);\r\n    });\r\n  }\r\n\r\n  componentWillUnmount () { }\r\n\r\n  componentDidShow () {\r\n  }\r\n\r\n  componentDidHide () { }\r\n\r\n  render() {\r\n    return (\r\n      <View className='stroll-tab'>\r\n        <View className='stroll-text'>\r\n          <Text className='text-tip1'>搭配师每天为你推荐5件单品</Text>\r\n          <View className='text-tip2'>\r\n            <Text className='t1'>右滑喜欢</Text>\r\n            <Image src={require('./img/ic_like.png')} className='icon-image'></Image>\r\n            <Text className='t1'>，左滑不喜欢</Text>\r\n            <Image src={require('./img/ic_dislike.png')} className='icon-image'></Image>\r\n          </View>\r\n        </View>\r\n        {\r\n          this.state.shopList.length != 0&&\r\n          <MovableArea className='stroll-shop'>\r\n            {\r\n            this.state.shopList&&this.state.shopList.map((item,index) => {\r\n              return(\r\n                <MovableView \r\n                  key={item.id}\r\n                  onTouchcancel={this.onCancel.bind(this,index)}\r\n                  onTouchend={this.onCancel.bind(this,index)}\r\n                  onTouchstart={this.onTouchStart.bind(this,index)}\r\n                  onTouchmove={this.onTouchMove.bind(this,index)}\r\n                  x={this.state.x[index]} \r\n                  y={this.state.y[index]} \r\n                  direction='all' \r\n                  outOfBounds \r\n                  className='shop-imgbox'\r\n                >\r\n                  <View className='images-box' style={{transform:'rotate('+this.state.tiltAngle[index]+'deg)'}}>\r\n                    <Image src={item.img} className='images'></Image>\r\n                    {\r\n                      this.state.like[index]==true&&\r\n                      <Image src={require('./img/text_like.png')} className='imagelike'></Image>\r\n                    }\r\n                    {\r\n                      this.state.unlike[index]==true&&\r\n                      <Image src={require('./img/text_dislike.png')} className='imageunlike'></Image>\r\n                    }\r\n                  </View>\r\n                </MovableView>\r\n            );})\r\n            }\r\n          </MovableArea>\r\n        }\r\n        {\r\n          this.state.shopList.length === 0&&\r\n          <View className='noshop-card'>\r\n            <Image src={require('./img/noshop.png')} className='noshop-image'></Image>\r\n          </View>\r\n        }\r\n        <View className='stroll-fotter'>\r\n          {\r\n            this.state.shopList.length != 0&&\r\n            <View className='fot-twoimg'>\r\n              {\r\n                this.state.unlike[0]==false&&\r\n                <Image src={require('./img/dislike_default.png')} className='dislike-image' onClick={this.dislikebtn.bind(this)}></Image>\r\n              }\r\n              {\r\n                this.state.unlike[0]==true&&\r\n                <Image src={require('./img/dislike_click.png')} className='dislike-image'></Image>\r\n              }\r\n              {\r\n                this.state.like[0]==false&&\r\n                <Image src={require('./img/like_default.png')} className='like-image' onClick={this.likebtn.bind(this)}></Image>\r\n              }\r\n              {\r\n                this.state.like[0]==true&&\r\n                <Image src={require('./img/like_click.png')} className='like-image'></Image>\r\n              }\r\n            </View>\r\n          }\r\n          <Text className='fot-text'>查看我喜欢的</Text>\r\n        </View>\r\n      </View>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Stroll;css文件：page {\r\n  height: 100%;\r\n  background: #F6F6F6;\r\n}\r\n\r\n.stroll-tab {\r\n  width: 100%;\r\n  min-height: 100vh;\r\n  background: #F6F6F6;\r\n  .stroll-text {\r\n    width: 100%;\r\n    margin-top: 40px;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    .text-tip1 {\r\n      font-size: 28px;\r\n      color: #333333;\r\n    }\r\n    .text-tip2 {\r\n      display: flex;\r\n      flex-direction: row;\r\n      align-items: center;\r\n      .t1 {\r\n        font-size: 28px;\r\n        color: #333333;\r\n      }\r\n      .icon-image {\r\n        width:20px;\r\n        height:20px;\r\n      }\r\n    }\r\n  }\r\n  .stroll-shop {\r\n    width: 100%;\r\n    height: 700px;\r\n    margin-top: 40px;\r\n    .shop-imgbox {\r\n      height: 600px;\r\n      border-radius: 24px;\r\n      .images-box {\r\n        width: 100%;\r\n        height: 520px;\r\n        border-radius: 24px;\r\n        box-shadow: 0px 2px 5px 0px rgba(0,0,0,0.1);\r\n        background-color: #fff;\r\n        position: relative;\r\n        .images {\r\n          width: 606px;\r\n          height: 480px;\r\n          position: absolute;\r\n          left: 40px;\r\n          top: 20px;\r\n        }\r\n        .imagelike {\r\n          width: 96px;\r\n          height: 48px;\r\n          position: absolute;\r\n          right: 40px;\r\n          top: 20px;\r\n        }\r\n        .imageunlike {\r\n          width: 148px;\r\n          height: 48px;\r\n          position: absolute;\r\n          left: 40px;\r\n          top: 20px;\r\n        }\r\n      }\r\n    }\r\n    .shop-imgbox:nth-child(1) {\r\n      width: 686px;\r\n      z-index: 50;\r\n    }\r\n    .shop-imgbox:nth-child(2) {\r\n      width: 676px;\r\n      z-index: 40;\r\n      margin: 15px 0px 0px 5px;\r\n    }\r\n    .shop-imgbox:nth-child(3) {\r\n      width: 666px;\r\n      z-index: 30;\r\n      margin: 30px 0px 0px 10px;\r\n    }\r\n    .shop-imgbox:nth-child(4) {\r\n      width: 656px;\r\n      z-index: 20;\r\n      margin: 0px 0px 0px 15px;\r\n    }\r\n    .shop-imgbox:nth-child(5) {\r\n      width: 646px;\r\n      z-index: 10;\r\n      margin: 0px 0px 0px 20px;\r\n    }\r\n  }\r\n  .noshop-card {\r\n    width: 100%;\r\n    margin-top: 40px;\r\n    padding: 0px 16px;\r\n    .noshop-image {\r\n      width: 100%;\r\n      height: 806px;\r\n    }\r\n  }\r\n  .stroll-fotter {\r\n    width: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    margin-top: 20px;\r\n    .fot-twoimg {\r\n      display: flex;\r\n      flex-direction: row;\r\n      align-items: center;\r\n      .dislike-image {\r\n        width: 120px;\r\n        height: 120px;\r\n      }\r\n      .like-image {\r\n        width: 120px;\r\n        height: 120px;\r\n        margin-left: 48px;\r\n      }\r\n    }\r\n    .fot-text {\r\n      color: #368BE5;\r\n      font-size: 28px;\r\n      margin-top: 40px;\r\n      margin-bottom: 50px;\r\n    }\r\n  }\r\n}好了，小程序左滑右滑效果就说到这里了，如果大家有更好的办法请在下方留言，上述的方法可能一下拖动效果之类的还需要加以完善，有什么好的建议和改善欢迎提出，谢谢了。"}
{"title": "微信小程序直播", "author": "Rolan", "time": "2020-5-18 00:49", "content": "1.添加直播组件官方开发文档以mpvue为例//app.json\r\n\"plugins\": {\r\n  \"live-player-plugin\": {\r\n    \"version\": \"1.0.11\",\r\n    \"provider\": \"wx2b03c6e691cd7370\"\r\n  }\r\n}\r\n复制代码直播组件版本号可以在 微信开发者工具-详情-基本信息-插件信息 查看当前版本号以及最新版本号2.直播间跳转以navigateTo为例let roomId = [直播房间id] // 填写具体的房间号\r\nlet customParams = encodeURIComponent(JSON.stringify({\r\n  path: 'pages/index/index',\r\n  pid: 1 \r\n})) // 开发者在直播间页面路径上携带自定义参数\r\nlet livePath = 'plugin-private://wx2b03c6e691cd7370/pages/live-player-plugin'\r\nwx.navigateTo({// 其中wx2b03c6e691cd7370是直播组件appid不能修改\r\n    url: `${livePath}?room_id=${roomId}&custom_params=${customParams}`\r\n})\r\n复制代码3.获取直播间列表以及获取直播状态直播间列表调用限额 500 次/天，建议开发者自己做缓存，交给后端处理了！let livePlayer = requirePlugin('live-player-plugin')\r\n// 首次获取立马返回直播状态，往后间隔1分钟或更慢的频率去轮询获取直播状态\r\nconst roomId = xxx // 房间 id\r\nlivePlayer.getLiveStatus({ \r\n    room_id: roomId\r\n}).then(res => {\r\n    // 101: 直播中, 102: 未开始, 103: 已结束, 104: 禁播, 105: 暂停中, 106: 异常，107：已过期 \r\n    const liveStatus = res.liveStatus\r\n    console.log('get live status', liveStatus)\r\n}).catch(err => {\r\n    console.log('get live status', err)\r\n})\r\n复制代码4.直播订阅对于未开播场次进行订阅//页面json文件添加subscribe组件\r\nusingComponents: {\r\n    subscribe: 'plugin-private://wx2b03c6e691cd7370/components/subscribe/subscribe'\r\n}\r\n复制代码//写入直播房间id即可\r\n<subscribe room-id=\"[直播房间id]\"></subscribe>\r\n复制代码5.mpvue-config-loader大坑插件简化了页面config配置，但在 usingComponents 遍历的时候为所有属性值添加了一个 / ，就导致获取不到 subscribe 组件，暂时先对 mpvue-config-loader 插件做一下更改。//node_modules/mpvue-config-loader/index.js 46-48行\r\n//可将其3行注释掉，或者去掉47行 /\r\nif (parentKey === 'usingComponents' && !path.isAbsolute(node.value)) {\r\n  return `/${node.value}`\r\n}\r\n复制代码6.获取分享卡片链接参数以mpvue为例，在 ./src/App.vue 文件中添加以下代码onShow(options) {\r\n  // 分享卡片入口场景才调用getShareParams接口获取以下参数\r\n  if (options.scene == 1007 || options.scene == 1008 || options.scene == 1044) {\r\n      livePlayer.getShareParams().then(res => {\r\n          console.log('get room id', res.room_id) // 房间号\r\n          console.log('get openid', res.openid) // 用户openid\r\n          console.log('get share openid', res.share_openid) // 分享者openid\r\n          console.log('get custom params', res.custom_params) // 自定义参数\r\n      }).catch(err => {\r\n          console.log('get share params', err)\r\n      })\r\n  }\r\n}\r\n复制代码可以收集进入直播间的用户以及分享者的信息7.其它途径进入直播间直播间小程序码// type=9 小程序码\r\n\"plugin-private://wx2b03c6e691cd7370/pages/live-player-plugin?room_id=[直播房间id]&type=9\"\r\n\r\n// 添加自定义参数 custom_params\r\n\"...&custom_params=encodeURIComponent(JSON.stringify(custom_params))\"\r\n复制代码公众号小卡片// type=10 小卡片\r\n\"plugin-private://wx2b03c6e691cd7370/pages/live-player-plugin?room_id=[直播房间id]&type=10\"\r\n\r\n// 添加自定义参数 custom_params\r\n\"...&custom_params=encodeURIComponent(JSON.stringify(custom_params))\"\r\n复制代码"}
{"title": "小程序多种路由跳转，区别何在", "author": "Rolan", "time": "2020-5-18 00:52", "content": "前言从Anjular转换到微信小程序，从功能丰富，便捷操作的WebStorm转换到十分难用，不是很人性的微信开发者工具，一开始真的特别不适应，也许是心理作用吧，从一开始就觉得它不好用，后来也是写不下去，后来调整心态，说试试看吧，后来就是越写越顺手，感觉也挺好的，初次接触小程序也是摸着石头过河，要啥就搜啥，期间要用到页面跳转(现在可能用不到了，当时对需求不是很了解，但是以后的功能应该会用到)，然后找了很多资料，发现跳转也分很多种，当时就选了一个用上了，后来又试了试别的，发现真的是各有其用。wx.navigateTo(Object object)navigateTo 是打开新界面，打开新界面之后，当前页处于什么状态呢，点击返回返回的又是哪一页呢，打开控制台试验一下，在此之前，先了解一下页面的生命周期：函数功能onLoad监听页面加载onReady监听页面初次渲染完成onShow监听页面显示onHide监听页面隐藏onUnload监听页面关闭我们先给标签加跳转功能<van-sidebar active-key=\"{{ activeKey }}\">\r\n\r\n<van-sidebar-item class=\"menufont\" bindtap=\"food\" title=\"食材\" />\r\n\r\n<van-sidebar-item class=\"menufont\" title=\"包装\" />\r\n\r\n<van-sidebar-item class=\"menufont\" title=\"配送\" />\r\n\r\n</van-sidebar>我们给“食材”一项加跳转功能，在标签加入bindtap属性，定义的方法名是什么，它的值就是什么，然后在ts文件里添加方法：food(){\r\nwx.navigateTo({\r\nurl:'../food/food'\r\n  })\r\n},这样就实现了从index界面跳转到food界面，我们对每个界面添加了onLoad()、onShow()、onHide()、onUnload()方法监控他们的状态，index界面跳转到Page1界面，再由Page1界面跳转到Page2界面：看一下控制台的信息：通过以上信息我们可以发现，跳转后之前的界面隐藏了起来，返回时当前界面被关闭。wx.redirectTo(Object object)redirectTo是关闭当前界面，跳转到下一界面，那么此时我再返回，返回的是哪个界面呢。将之前Page1跳转到Page2的函数修改为redirectTo，然后看控制台：跳转后，之前的界面关闭，再次返回返回的最近的隐藏的界面。wx.reLaunch(Object object)reLaunch 关闭所有页面，打开到应用内的某个页面,那么返回的又是哪个界面呢。将之前Page1跳转到Page2的函数修改为reLaunch，然后看控制台：之前的所有界面关闭，返回时跳转回初始界面index。总结小程序的跳转种类真的挺多的，如果真正把握好隐藏还是关闭，返回界面是哪个，页面跳转真的能省力不少，一开始认为小程序挺难写的，后来才明白不是它难写，而是我认为它难写，心态真的挺重要的。"}
{"title": "关于对小程序网络请求的封装(详尽版)", "author": "Rolan", "time": "2020-5-19 00:24", "content": "引导读者从最基础的小程序网络请求封装到网络请求封装的最优解在使用原生小程序网络api时，有以下两个缺点：多个页面往往代表发送多个网络请求，这样对服务器的压力过大 -> 降压基于原因1，防止未来微信官方废弃了wx.request这个api而换了另外一个api时造成的重复操作 ->降低依赖,防止重复1. wx原生网络请求微信原生请求看似很清晰，但成功与失败的函数都是在 wx.request内部，假设读者对jQuery有所了解，就会发觉跟jquery很像：但这种方法已经濒临灭绝了，接下来使用基于promise对微信原生网络请求进行层层封装2. 简单封装//  ../../request/one.js\r\nexport default function reqeust(params) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: params.url,\r\n      method: params.method || 'get',\r\n      data: params.data || {},\r\n      success: res => {\r\n        resolve(res)\r\n      },\r\n      fail: err => {\r\n        reject(err)\r\n      }\r\n    })\r\n  })\r\n}如果对pomise相当了解,也可以使用进化版://  ../../request/one.js\r\nexport default function reqeust(params) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: params.url,\r\n      method: params.method || 'get',\r\n      data: params.data || {},\r\n      success: resolve,\r\n      fail: reject\r\n    })\r\n  })\r\n}页面内使用://页面内导入\r\n import reqeust from '../../request/one.js'\r\n// 页面的onload函数内使用\r\n  onLoad: function () {\r\n    reqeust({\r\n      url: 'https://xxxxxxxxxxxxxxxxxxxxxxxxxxx',\r\n    })\r\n      .then(res => {\r\n      console.log(res)\r\n    })\r\n      .catch(err => console.log(err))\r\n  }结果也是一样的3. 进化版封装回顾下es6的导入导出知识:// 常量的导出\r\n//public.js\r\nconst demo = '使用export导出的常量,不可以重命名该常量,需要用大括号';\r\nexport {\r\n  demo \r\n}\r\n//常量的导入\r\n//getdemo.js\r\nimport { demo } from './public'\r\nconsole.log(demo ) // '使用export导出的常量,不可以重命名该常量,需要用大括号'\r\n//函数的导出与导入\r\n//函数的导出\r\n//fn.js\r\nexport function fn() {\r\n  console.log(\"使用export导出的fn,不可以重命名该函数,需要用大括号\")\r\n}\r\n//函数的导入\r\n//getFn.js\r\nimport { fn } from './fn.js'\r\nfn(); // \"使用export导出的fn,不可以重命名该函数,需要用大括号\"\r\n\r\n//全部导出与导入\r\n//导出\r\n//allData.js\r\nexport default function allData() {\r\nconsole.log(\"使用export default 导出的数据,可以重命名该函数,不需要用大括号\")\r\n}\r\n//getAllData.js\r\n//导入\r\n import reName_AllData from './allData.js'\r\nreName_AllData()//\"使用export default 导出的数据,可以重命名该函数,不需要用大括号\"假设请求的url有一部分是相同的将url分为两部分:第一部分作为公共的请求地址publicURL,单独抽离成一个文件,另一部分作为单个页面请求的网络地址PageUrl在requers.js里将公共的请求地址publicURL添加进url里页面导入request.js 发起请求//抽取公共url到单独文件\r\n//publicData.js\r\nconst baseURL = 'https://jiazhuang/zheshi/yige/gonggongurl';\r\nexport {\r\n  baseURL\r\n}\r\n//封装的网络请求文件,导入上述文件\r\n//network1-0.js\r\nimport { baseURL } from './public'\r\nexport function request(params) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: baseURL + params.url,\r\n      method: params.method || 'get',\r\n      data: params.data || {},\r\n      success: resolve,\r\n      fail: reject\r\n    });\r\n  })\r\n}\r\n//页面使用时仅填入对应的网络地址即可\r\n//页面导入封装好的network1-0.js\r\nimport { request } from '../../req/newwork1-5'\r\n//onLoad函数内使用\r\n onLoad: function () {\r\n    request({\r\n      url: 'public/v1/home/swiperdata'\r\n    }).then(res => {\r\n      console.log(res)\r\n    })\r\n      .catch(err => console.log(err))\r\n  }以上就是第二层封装.但是这样还是有不太方便的一面:单个页面需要发送的请求太多,代码的可读性并不太好那么就有了终极版封装:4. 进化版封装这一步时,我们的目的就是为了分层:基于页面分层,封装单个页面需要发送的请求为一个文件getPage.js由page.js负责向request.js发送真正的网络请求,而页面要做的就是调用page.js里的单个请求方法以下为图示:解释:request.js负责将公共api与getPage.js里传入的api进行拼接,整合后向后台发送数据getPage.js向上负责向request.js发送请求,向下作为发送请求函数等待被调用,函数内部存储非公共apipage作为页面,仅调用getPage.js内部的函数即可整演示例//publicData.js 作为api的公共部分\r\n const baseUrl= 'https://jiazhuang-shiyige-api/api/';\r\nexport {\r\n  baseUrl\r\n}\r\n\r\n//request.js 作为真正发送网络请求的文件\r\nimport { publicUrl } from './publicData'\r\nexport default function reqeust(params) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: publicUrl + params.url,\r\n      method: params.method || 'get',\r\n      data: params.data || {},\r\n      success: resolve,\r\n      fail: reject\r\n    })\r\n  })\r\n}\r\n\r\n// getIndexData.js : 向上负责调用request.js,向下负责该page页面的发送网络请求的所有函数,函数的内部存储了非公共部分的请求地址\r\nimport reqeust from './request'\r\nexport function getBannerData() {\r\n  return reqeust({\r\n    url: 'wo/zhen-de/shi/api/banner',\r\n  })\r\n}\r\n//index页面导入所属的getIndexData.js,在onload函数内调用所属页面的方法\r\nimport { getBannerData} from '../../request/getIndexData'\r\nonload(){\r\n  getBannerData().then(res => {\r\n      console.log(res)\r\n      //这里就可以对数据进行操作了\r\n    }).catch(err => console.log(err))\r\n}在这个例子里,一步步解释了流程,或许有些冗余,但这些更符合了规范化,page页面不关心发送网络请求,只负责调用,getPageData.js只负责将对应的url发送给request.js处理,而request.js负责拼接整合url以及其他,最终发送向网络请求.如果愿意,还可以单个页面再细分,所作的一切都是为了服务于开发.以上就是将小程序的原生网络请求一步步封装达到最优解."}
{"title": "微信小程序国际化探索（附源码地址）", "author": "Rolan", "time": "2020-5-19 00:42", "content": "随着小程序应用越来越广泛，国际化支持逐渐成了刚需。官方文档给出了一个 国际化方案 ，但觉得配置起来稍微有点复杂，对项目结构还有一定的要求。如果是旧项目改动成本太大，遂决定自己实现一个小程序国际化方案。源码地址： github.com/cachecats/m…一、项目结构整体目录结构如下图：assets 存放资源文件，如图片constants 存放项目中用到的常量i18n 存放语言文件，中文是 zh-CN.js 英文是 en-US.js ，如果还需要支持其他语言再建一个 js 即可pages 存放业务逻辑代码utils 存放工具类。 LangUtils 是封装的国际化工具类。二、工具类封装及语言包准备2.1 语言包准备i18n 目录下的各语言包结构要一致，即对象的 key 保持一致， value 是对应的语言文本。建议每个小模块分为一个对象，单个对象的内容不宜过多。zh-CN.jsexport default {\r\n  common: {\r\n    language: '语言',\r\n    chinese: '中文',\r\n    english: '英语',\r\n  },\r\n  tabBarTitles: ['主页', '论坛', '我的'],\r\n  navTitle: {\r\n    home: '主页',\r\n    forum: '论坛',\r\n    mine: '我的',\r\n    setting: '设置'\r\n  },\r\n  home: {\r\n    motto: '我们宁愿拥有一个不完美的变革，也不愿看到一个没有希望的未来',\r\n    respect: '致勇者',\r\n    getUserInfo: '获取头像昵称'\r\n  },\r\n  forum: {\r\n    forumModule: '我是论坛模块',\r\n    tip: '下面是一个组件，用来展示组件的国际化配置'\r\n  },\r\n  comment: {\r\n    title: '评论组件',\r\n    msg: '网络一线牵，珍惜这段缘'\r\n  },\r\n  mine: {\r\n    title: '这是我的页面',\r\n    toNewPage: '跳转到新页面'\r\n  },\r\n  setting: {\r\n    title: '我是设置页面'\r\n  }\r\n}\r\n复制代码en-US.jsexport default {\r\n  common: {\r\n    language: 'Language',\r\n    chinese: 'Chinese',\r\n    english: 'English',\r\n  },\r\n  tabBarTitles: ['Home', 'Forum', 'Mine'],\r\n  navTitle: {\r\n    home: 'Home',\r\n    forum: 'Forum',\r\n    mine: 'Mine',\r\n    setting: 'setting'\r\n  },\r\n  home: {\r\n    motto: 'We would rather have an imperfect change than see a hopeless future',\r\n    respect: 'to warrior',\r\n    getUserInfo: 'Get avatar nickname'\r\n  },\r\n  forum: {\r\n    forumModule: 'I am forum module',\r\n    tip: 'The following is a component to show the international configuration of the component'\r\n  },\r\n  comment: {\r\n    title: 'Comment Components',\r\n    msg: 'The network leads, cherish this relationship'\r\n  },\r\n  mine: {\r\n    title: 'This is mine page',\r\n    toNewPage: 'Go to new page'\r\n  },\r\n  setting: {\r\n    title: 'I am setting page'\r\n  }\r\n}\r\n复制代码2.2 工具类 LangUtils 封装工具类 LangUtils 封装了国际化所需的所有方法，包括获取当前语言、设置语言、获取当前语言的资源文件、设置 TabBar 、设置 NavigationBar 等方法。实现思路是把当前设置的语言存在小程序提供的 storage 中，每次项目初始化时从 storage 中读取语言，如果没有读到则默认设置为中文。然后在每个页面或组件的 data 中将页面需要用到的文本资源引入进来， wxml 中使用 data 中绑定的变量展示文字。同时在生命周期的 onShow 方法中重新读取当前语言并设置 data ，使得每次改变语言都能正确的加载语言包。先看 LangUtils 的代码：import zh from '../i18n/zh-CN.js'\r\nimport en from '../i18n/en-US.js'\r\nimport Constants from '../constants/Constants';\r\n\r\nexport default{\r\n\r\n  //初始化语言设置。在 app.js 里调用这个方法。\r\n  initLang(){\r\n    //先获取是不是已存在语言的设置\r\n    let lang = wx.getStorageSync('lang')\r\n    if(!lang){\r\n      //如果不存在,设置默认语言为中文\r\n      this.setLang(Constants.langCN)\r\n    }\r\n  },\r\n\r\n  //设置语言\r\n  setLang(lang){\r\n    try{\r\n      wx.setStorageSync('lang', lang)\r\n    }catch(e){\r\n      console.log('设置语言失败', e)\r\n    }\r\n  },\r\n\r\n  //获取语言设置\r\n  getLang(){\r\n    try{\r\n      let lang = wx.getStorageSync('lang')\r\n      return lang;\r\n    }catch(e){\r\n      console.log('获取语言设置失败', e)\r\n    }\r\n  },\r\n\r\n  //获取当前语言下的资源文件\r\n  getLangSrc(){\r\n    let lang = this.getLang();\r\n    if(lang === Constants.langCN){\r\n      return zh;\r\n    } else if(lang === Constants.langEN){\r\n      return en;\r\n    }else{\r\n      return zh;\r\n    }\r\n  },\r\n\r\n  //设置 NavigationBarTitle\r\n  setNavigationBarTitle(title){\r\n    wx.setNavigationBarTitle({\r\n      title: title\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 设置 tabBar。因为 tabBar 是在 app.json 里写死的，需要使用 wx.setTabBarItem\r\n   * 循环设置 tabBar\r\n   */\r\n  setTabBarLang(){\r\n    let tabBarTitles = this.getLangSrc().tabBarTitles;\r\n    console.log('tabBarTitles', tabBarTitles)\r\n    tabBarTitles.forEach((item, index) => {\r\n      console.log(item, index)\r\n      wx.setTabBarItem({\r\n        index: index,\r\n        text: item,\r\n        success: (res) => {\r\n          console.log('setTabBarItem success', res)\r\n        },\r\n        fail: (err) => {\r\n          console.log('setTabBarItem fail', err)\r\n        }\r\n      });\r\n    });\r\n  },\r\n}\r\n复制代码先引入中文和英文的语言包，以便根据当前语言设置返回对应的资源包。Constants 是对常量的封装，这里保存的是中英文编码标识。Constants.js\r\n\r\n/**\r\n * 保存项目中的常量\r\n */\r\nexport default{\r\n  //中文编码\r\n  langCN: 'zh-CN',\r\n  //英文编码\r\n  langEN: 'en-US',\r\n}\r\n复制代码需要注意的是 tabBar 的处理，因为 tabBar 是写死在 app.json 中的，不能动态的改变文本，所以每次语言改变只能用小程序暴露出来的 wx.setTabBarItem 方法循环的设置 tabBar 。至此前期的准备工作已经做完啦，接下来对具体的页面和组件做处理。三、项目使用需要改动三个地方app.js 初始化语言xxx.js 的 data 添加语言属性，并在 onShow 生命周期方法中调用 setData 重新设置语言xxx.wxml 中的文本替换为 data 里绑定的变量3.1 app.js 初始化语言在项目入口文件 app.js 中做初始化。//初始化国际化语言设置\r\nimport LangUtils from './utils/LangUtils'\r\n\r\nApp({\r\n  onLaunch: function () {\r\n    // 国际化的初始化\r\n    LangUtils.initLang();\r\n    LangUtils.setTabBarLang();\r\n  }\r\n})\r\n复制代码3.2 Page 页面的国际化js 中使用js 中的使用分三步：首先引入 LangUtils.js然后在 data 中定义变量 lang ，通过 ... 对象的解构赋值，把语言文件中对应模块定义的变量都赋值给 lang ，方便调用。如果是 settings 模块，可以这样写： lang: {...LangUtils.getLangSrc().settings} 。也可以只写个空对象： lang: {} ，然后在 onShow() 方法里对 lang 赋值。onShow() 生命周期方法里，更新 lang 的值，以防语言被改变。如果需要设置小程序标题，则再调用 LangUtils.setNavigationBarTitle() 方法。// pages/setting/setting.js\r\nimport LangUtils from '../../utils/LangUtils'\r\nlet langSrc = LangUtils.getLangSrc()\r\n\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    lang: {\r\n      ...langSrc.setting\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面显示\r\n   */\r\n  onShow: function () {\r\n    this.setLanguage();\r\n  },\r\n\r\n   /**\r\n   * 重新设置语言\r\n   */\r\n  setLanguage() {\r\n    langSrc = LangUtils.getLangSrc();\r\n    this.setData({\r\n      lang: {\r\n        ...langSrc.setting\r\n      }\r\n    })\r\n    // 设置 NavigationBarTitle\r\n    LangUtils.setNavigationBarTitle(langSrc.navTitle.setting);\r\n  }\r\n})\r\n复制代码wxml 中使用wxml 里比较简单，跟普通的变量使用方法一样。<view class=\"setting-container\">\r\n\t<text class=\"title\">{{lang.title}}</text>\r\n</view>\r\n复制代码3.2 Component 组件的国际化Component 跟 Page 国际化基本上相同，但因为生命周期方法不同，稍微有点区别。Coponents 的 this.setLanguage() 在生命周期的 pageLifetimes 的 show 方法中调用。// pages/forum/components/comment.js\r\nimport LangUtils from '../../../../utils/LangUtils'\r\nlet langSrc = LangUtils.getLangSrc();\r\n\r\nComponent({\r\n  data: {\r\n    lang: {\r\n      ...langSrc.comment\r\n    }\r\n  },\r\n\r\n  pageLifetimes: {\r\n    // 组件所在页面的生命周期函数\r\n    show: function () { \r\n      console.log('page show---')\r\n      this.setLanguage();\r\n    },\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    /**\r\n     * 重新设置语言\r\n     */\r\n    setLanguage() {\r\n      langSrc = LangUtils.getLangSrc();\r\n      this.setData({\r\n        lang: {\r\n          ...langSrc.comment\r\n        }\r\n      })\r\n    }\r\n  }\r\n})\r\n复制代码3.3 切换语言切换语言放在 demo 的 home 页面中。用户更改语言后要调用 LangUtils.setLang 更改语言值，还要调用 LangUtils.setTabBarLang 重新设置 tabBar 的文本。切换后的效果//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\n\r\nimport Constants from '../../constants/Constants'\r\n// 获取对应语言的资源文件\r\nimport LangUtils from '../../utils/LangUtils'\r\nlet langSrc = LangUtils.getLangSrc();\r\n\r\n// 语言选项\r\nconst LANGUAGE_OPTIONS = [{\r\n    key: Constants.langCN,\r\n    value: '中文'\r\n  },\r\n  {\r\n    key: Constants.langEN,\r\n    value: 'English'\r\n  }\r\n]\r\n\r\nPage({\r\n  data: {\r\n    // 通过解构赋值将 common 和 home 下的变量赋值给 lang。最好每个模块建一个对象\r\n    // 对象里的属性不宜过多，否则在 data 里放入太多内容会影响性能，用到什么放什么。\r\n    lang: {\r\n      ...langSrc.common,\r\n      ...langSrc.home\r\n    },\r\n    langOptions: LANGUAGE_OPTIONS,\r\n    index: 0\r\n  },\r\n\r\n  onLoad: function () {\r\n    // 根据当前语言设置 picker 默认选中的值\r\n    let lang = LangUtils.getLang();\r\n    this.setData({\r\n      index: lang === Constants.langCN ? 0 : 1\r\n    })\r\n  },\r\n  onShow: function () {\r\n    //每次 onShow 重新设置语言，以防语言更新\r\n    this.setLanguage();\r\n  },\r\n\r\n  getUserInfo: function (e) {\r\n    console.log(e)\r\n    app.globalData.userInfo = e.detail.userInfo\r\n    this.setData({\r\n      userInfo: e.detail.userInfo,\r\n      hasUserInfo: true\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 选择语言变化回调函数\r\n   */\r\n  onLanguageChange(e) {\r\n    const index = e.detail.value\r\n    console.log(e)\r\n    this.setData({\r\n      index: index\r\n    })\r\n    // 更改语言\r\n    LangUtils.setLang(this.data.langOptions[index].key);\r\n    // 重新设置 tabBar 的语言\r\n    LangUtils.setTabBarLang();\r\n    this.setLanguage();\r\n  },\r\n\r\n  /**\r\n   * 重新设置语言\r\n   */\r\n  setLanguage() {\r\n    langSrc = LangUtils.getLangSrc();\r\n    this.setData({\r\n      lang: {\r\n        ...langSrc.common,\r\n        ...langSrc.home\r\n      }\r\n    })\r\n    // 设置 NavigationBarTitle\r\n    LangUtils.setNavigationBarTitle(langSrc.navTitle.home);\r\n  }\r\n})\r\n复制代码四、总结代码乍一看还挺多的，但优点是不用引入第三方模块，也不用按要求改项目结构。其实把前期的准备工作做完后，后期维护起来还是很方便的。当然这个方案还有可优化的地方，比如每个页面的 onShow 方法里都要执行相似的逻辑，以后有时间会做优化。项目地址： github.com/cachecats/m…"}
{"title": "微信小程序项目问题优化", "author": "Rolan", "time": "2020-5-19 00:53", "content": "情景和联动模式情景模式是通过把一系列设备控制放在一起，然后触发设备按设定的延迟时间执行，如进入家中手动点击触发回家情景模式，该模式设置了客厅灯打开，亮度、颜色和色温多少，窗帘拉开百分之多少，还可以设置设备的各种控制属性和设备延时执行；联动模式是选择一个主设备的属性触发该模式，相当于时刻监听该主设备的属性变化，一旦设备达到设置条件则触发联动模式，联动可以添加一系列的设备和情景模式，如回家联动模式，主设备设置人体传感器触发则执行联动其中处理比较复杂的是选中的设备列表数据，其中存储的有设备ID、设备属性以及延时时间（设备列表展示和执行都是根据延时时间来表现）而显示的数据则是设备的名称以及控制属性名字，并且同一设备可以重复添加（所以设备ID 不能做编辑设备属性的唯一标识，每次新增设备时新增一个标识为设备ID 加上在设备列表的索引），相当于给设备添加了定时功能触发。开始处理方式是对设备列表循环获取设备详情在组合一起，不同的属性转化方式会有很大的不同，如颜色，模式，风速类别，所以需要很多的判断来转化成对应的名称。后期的处理优化，通过 map 结构来把情景列表和联动列表来缓存起来，key 为情景或联动标识并且把设备属性选择抽离出组件来实现共用，所以当数据量操作对比很复杂的时候通过 map 结构来缓存数据是一个比较不错的选择swiper 滑动组件小程序设备详情展示是通过 swiper 滑动组件展示，每次左右滑动一下更换当前数据，前期是获取该设备类型列表，直接显示所有的 swiper-item 组件，当该设备数量不多时还可以，但当设备（如：灯）过多时会出现滑动卡顿或者卡死的情况，后期的处理优化是进入设备展示时判断该设备类型列表数量大于8时，每次显示三个 swiper-item 或者更换成九宫格展示界面。所以对于有些界面显示方式需要考虑过多或者没有时的展示处理设备默认值以及状态改变设备属性展示优化，设备的开关等属性状态默认值以及无法获取值时统一设置为关而不是随意设置。设备控制等判断请求成功后在改变对应界面状态（如开关状态），否则回到改变的初始值（如滑动条）设备属性递归当设备列表通过九宫格全部展示在同一界面时，而设备的状态和其它属性又需要通过属性查询接口来获取显示在界面，前期使用 for 循环通过设备ID 遍历来查找对应的设备属性，因为for 循环中为异步操作，所以第一个返回的数据不一定对应设备列表中的第一个，所以又通过设备ID 去对比设备列表所在的索引再进行赋值，后期的处理优化是用递归来取代 for 循环，所以在对循环的顺序要求比较严格而循环的内部又是一个个异步操作的时候，可以考虑使用递归的处理方法，只需要找到递归的终止条件即可（如批量控制设备、批量查询属性等）icon 字体图标如开关按钮一系统图标，开始会有大量不同颜色图片，后期优化把许多图片上传到阿里 icon 字体图标库，一方面字体图标大小和颜色控制灵活，另一方面减少了http请求点击区域当存在图标点击事件时，点击热点区域尽量增大一点，确保点击的执行成功率（如左上角返回按钮点击）canvas 和 swiper 滑动偏移滑动 swiper，定位的 canvas 会出现偏移，将 swiper 标签中的 duration 改成了0，即取消了滑动的渐变效果，canvas 便不再偏移，canvas 使用 wx:if 会在滑动回返时缺少 canvas 线条，应使用 hidden 来代替，wx:if 在隐藏的时候不渲染，而 hidden 在隐藏时仍然渲染，只是不呈现，注意 canvas 等属性单位为 pxtab 切换某些 tab 切换是通过点击 tab 栏来达到切换，后期把 tab 栏内容通过 swiper 包裹（scroll-view 组件也可以）来实现左右滑动来切换 tab 内容，但需注意如果内容中也存在滑动事件则会存在冲突深层次对象值当使用某个深层次对象时需要判断对象是否存在再进行赋值，不然会出现取不到对象中的值而报错导致后续步骤直接停止在 wxml 中可以通过逻辑运算&&（如：deviceObj && deviceObj.attrObj && deviceObj.attrObj.power）或 wx:if 来判断整个对象（如：deviceObj.attrObj）或逻辑运算||（如：deviceObj.attrObj.power || ‘--’）在js中可以通过封装公共函数来判断，如：let objProp = (data, path) => {  if (!data || !path) {    return null  }  let tempArr = path.split('.');  for (let i = 0; i < tempArr.length; i++) {    let key = tempArr[i];    if (data[key]) {      data = data[key];    } else {      return null;    }  }  return data;}let data = { deviceObj: { attrObj: { power: 'on' } } }console.log(objProp(data, 'deviceObj.attrObj.power'))    //onconsole.log(objProp(data, 'deviceObj.propObj'))    //nullconsole.log(objProp(data, 'deviceObj.attrObj.wind'))    //null\r\n复制代码浮动按钮浮动按钮中有对设备名称，区域更改以及设备解绑，放置在右下角，但因为不同页面浮动按钮放置位置可能会遮挡部分操作内容，所以在不同页面它的 bottom 不同，但是还是不够灵活，后期使浮动按钮在竖直一定范围内进行拖拽，开始考虑过使用小程序 movable-view 自带组件，但是必须放在一定区域 movable-area 中，但 movable-area 又会遮挡页面内容的操作，所以还是通过 catchtouchmove 事件来进行拖拽"}
{"title": "小程序瀑布流组件:支持翻页与图片懒加载", "author": "Rolan", "time": "2020-5-20 00:35", "content": "电商小程序中，用到瀑布流的地方非常多，每次都写一个瀑布流，重复一次逻辑，作为程序员，肯定是非常不愿意的。瀑布流的形式都是大同小异，不同的是瀑布流中每个模块的内容，随业务而变化。所以，我们把瀑布流框架抽象成组件，瀑布流的内容由业务确定。这样即可实现组件化和自定义的最大平衡， 微信小程序组件源码 。首先，我们来看一下瀑布流组件在实际项目中的实际效果。1 实际效果瀑布流组件实际效果如下图所示，左侧为用户交互效果，右侧为图片懒加载实际效果。2 什么是瀑布流？瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局， waterfall-item 宽度固定，高度不定，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。如下图所示:3 实现功能该瀑布流组件实现了以下几个功能：支持图片懒加载支持上拉数据翻页支持自定义样式支持瀑布流Item间隔底层自动计算原生组件模式：即类 swiper 和 swiper-item 组件用法组件与数据完全解耦4 实现原理4.1 waterfall 和 waterfall-item 实现原理第一步：在 waterfall-layout 目录下创建 waterfall 和 waterfall-item 组件，目录结构如下：.\r\n├── query-node.js\r\n├── waterfall-item.js\r\n├── waterfall-item.json\r\n├── waterfall-item.wxml\r\n├── waterfall-item.wxss\r\n├── waterfall.js\r\n├── waterfall.json\r\n├── waterfall.wxml\r\n└── waterfall.wxss第二步：分别在 waterfall.js 和 waterfall-item.js 的 relations 选项中指定组件父、子级关系：// waterfall.js\r\nComponent({\r\n    // ... other code\r\n    relations: {\r\n    './waterfall-item': {\r\n      type: 'child',\r\n    },\r\n    // ... other code\r\n  }\r\n})// waterfall-item.js\r\nComponent({\r\n    // ... other code\r\n    relations: {\r\n    '././waterfall': {\r\n      type: 'parent',\r\n    },\r\n    // ... other code\r\n  }\r\n})指定彼此的父、子组件的关系后，即可通过 this.getRelationNodes 原生 API，就能访问彼此实例对象及其属性和方法。第三步：实现 waterfall.wxml 和 waterfall-item.wxml 代码：waterfall.wxml 代码实现非常简单，只有5行代码：<view class=\"waterfall custom-class\">\r\n  <view class=\"waterfall-inner\">\r\n    <slot ></slot>\r\n  </view>\r\n</view>同样， waterfall-item.wxml 代码实现也非常简单，只有5行代码：<view\r\n  class=\"waterfall-item custom-class\"\r\n  style=\"{{position}}:0;top:{{(top >= 0 ? top + 'px' : 0 + 'rpx')}};\"\r\n>\r\n  <slot ></slot>\r\n</view>不知道 slot 用法的童鞋，请参考 微信小程序自定义组件模板和样式 文档。4.2 瀑布流原理其实，不管是微信小程序、web、还是原生APP，瀑布流的实现原理都是一样的。都可以 绝对定位 和 位置计算 来实现。瀑布流的大体过程如下图所示：第一步：数据通过 this.setData 从逻辑层传输到视图层，进行第一渲染，由于每个 waterfall-item 的 top:0; 和 position:left; ，所以都重叠了在一起。第二步：通过节点查询API获取每个 waterfall-item 元素信息，并且计算出正确的 top 和 position 值。第三步： setData 每个 waterfall-item 的 top 和 position ，实现重排。具体逻辑实现如下：首先，我们来实现一个节点查询API querySelector ，之后会用到：// query-node.js\r\n/**\r\n * 获取当前页面中，选择器为 selector 的第一个node节点\r\n * @param {String} selector 符合微信小程序规范的选择器\r\n * @param {Object} context 调用环境，普通页面中为wx，自定义组件中为this；默认值为wx.\r\n * @return {Array} 返回一个数组，第一个元素为 node 节点\r\n */\r\nexport const querySelector = function (selector, context = wx) {\r\n  return new Promise((resolve, reject) => {\r\n    context.createSelectorQuery()\r\n    .select(selector)\r\n    .boundingClientRect((res) => {\r\n      if (res) {\r\n        resolve(res);\r\n      } else {\r\n        reject(`不存在选择器为 ${selector} 的节点`);\r\n      }\r\n    })\r\n    .exec();\r\n  })\r\n};接着，看一下组件 waterfall 和 waterfall-item 在实际项目中的用法：<waterfall\r\n      loading=\"{{loadMorePending}}\"\r\n      isAllLoaded=\"{{isAllLoaded}}\"\r\n    >\r\n      <block wx:for=\"{{data.sections}}\" wx:key=\"id\" wx:for-item=\"product\">\r\n        <waterfall-item\r\n          index=\"{{index}}\"\r\n          custom-class=\"flow-item-wrapper\"\r\n        >\r\n          <view class=\"product-item\">\r\n            业务代码\r\n          </view>\r\n        </waterfall-item>\r\n      </block>\r\n    </waterfall>当第一个 waterfall-item 组件，在视图层布局完成后会执行 ready 生命周期钩子。在 ready 生命周期钩子中，我们需要做两件事：获取父组件 waterfall 的实例对象，并挂载在 waterfall-item 组件的 this 实例对象上。因为之后我们需要在 waterfall-item 组件中修改 waterfall 上的数据。获取 waterfall-item 组件的高度，计算 waterfall-item 组件的位置信息 top 和 position 。// waterfall-item.js\r\nimport { querySelector } from './query-node';\r\nComponent({\r\n  // ... other code\r\n  lifetimes: {\r\n    ready() {\r\n      const [waterfall] = this.getRelationNodes('./waterfall');\r\n      this.parent = waterfall;\r\n      this.setWaterfallItemPosition();\r\n    },\r\n  }\r\n  methods:{\r\n    async setWaterfallItemPosition() {\r\n      querySelector('.waterfall-item', this)\r\n        .then(async (node) => {\r\n          const { top, position } = await this.parent.getWaterfallItemPostionInfo(node);\r\n          this.setData({\r\n            top,\r\n            position\r\n          })\r\n        })\r\n    },  \r\n  }\r\n  // ... other code\r\n})在 setWaterfallItemPosition 方法中，我们调用了父组件上的方法 this.parent.getWaterfallItemPostionInfo ，获取当前 waterfall-item 组件的 top 和 position 信息。并把已经渲染好的 waterfall-item 组件的累计高度缓存在 waterfall 的 leftHeights 和 rightHeights 属性上，用于计算下一个 waterfall-item 组件位置，主要逻辑如下：// waterfall.js\r\nconst POSITION_LEFT = 'left';\r\nconst POSITION_RIGHT = 'right';\r\n\r\nComponent({\r\n  // ... other code\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    lifetimes: {\r\n      ready() {\r\n        this.initParams();\r\n      }\r\n     },\r\n    initParams() {\r\n      this.leftHeights = 0;\r\n      this.rightHeights = 0;\r\n    },\r\n    /**\r\n     * 设置 waterfall-item 的高度值\r\n     * @param {Object} node waterfall-item 组件位置尺寸数据\r\n     */\r\n    async getWaterfallItemPostionInfo(node) {\r\n      let top = 0;\r\n      let position = POSITION_LEFT;\r\n      const { height } = node;\r\n      const { itemGap } = this;\r\n      if (this.leftHeights <= this.rightHeights) {\r\n        top = this.leftHeights;\r\n        if(this.leftHeights === 0) {\r\n          this.leftHeights += height;\r\n        } else {\r\n          top += itemGap;\r\n          this.leftHeights += (height + itemGap);\r\n        }\r\n      } else {\r\n        position = POSITION_RIGHT;\r\n        top = this.rightHeights;\r\n        if(this.rightHeights === 0) {\r\n          this.rightHeights += height;\r\n        } else {\r\n          top += itemGap;\r\n          this.rightHeights += (height + itemGap);\r\n        }\r\n      }\r\n      return {\r\n        top,\r\n        position,\r\n      }\r\n    }\r\n    // ... other code\r\n  }\r\n})当所有的 waterfall-item 重排结束后，瀑布流渲染完成。4.3 图片懒加载原理微信小程序中， <image> 标签本身是支持懒加载的，当 lazy-load={{true}} ，且在即将进入一定范围（上下三屏）时才开始加载。也就是说，当 lazy-load={{true}} ， <image> 标签初次渲染在视口上下三屏之外时，是不会请求图片资源的，当 <image> 即将进入三屏之内时，才会加载。在4.2小节的图3中， <waterfall-item> 的初始化位置设置成了 top:0; 和 position:left; ，所以，都在视口中。如果将 top 的值成三屏之外的数值，例如， 400vh 或者更大，则 <waterfall-item> 重排之后，任然在三屏之外的图片即会自动懒加载。<view\r\n  class=\"waterfall-item custom-class\"\r\n  style=\"{{position}}:0;top:{{(top >= 0 ? top + 'px' : itemCount * 100 + 'vh')}};\"\r\n>\r\n  <slot ></slot>\r\n</view>Component({\r\n  // waterfall-item.js\r\n  // ... other code\r\n  lifetimes: {\r\n    ready() {\r\n      const { itemCount } = this.data;\r\n      const [waterfall] = this.getRelationNodes('./waterfall');\r\n      waterfall.childCount += 1;\r\n      this.parent = waterfall;\r\n      this.setData({\r\n        itemCount: itemCount + waterfall.childCount,\r\n      })\r\n    },\r\n  },\r\n  // ... other code\r\n})4.4 数据翻页因为实现了 wx:for <waterfall-item> 功能，和 <swiper-item> 组件一样，因此翻页逻辑完全由用户自己定制， <waterfall> 和 <waterfall-item> 只给你提供翻页的功能，组件就可以和瀑布流数据结构完全解耦。4.5 瀑布流Item间隔底层自动计算将列和行中，两个 <waterfall-item> 组件之间的距离定义为 itemGap ，则:itemGap = waterfall宽度 - （waterfall-item宽度 * 2）在 <waterfall> 的 ready 钩子中，可以获取到 <waterfall> 组件的宽度；同理，在 <waterfall-item> 的 ready 钩子中，可以获取到 <waterfall-item> 组件的宽度。在调用 getWaterfallItemPostionInfo 之前，获取到 itemGap 的值即可。这样，在计算 <waterfall-item> 的 top 值时，除了第一行的 <waterfall-item> 的 top 值等于0之外，其他所有 <waterfall-item> 的 top 值等于：// this.leftHeights += height + itemGap;\r\n// or \r\n// this.rightHeights += height + itemGap;具体代码实现 请查看源码5 总结通过瀑布流框架抽象，使 <waterfall> 和 <waterfall-item> 接近原生组件使用体验，同时使组件与数据完全解耦。通过巧妙的初始化位置 top 设置，使瀑布流具图片有懒加载的功能。"}
{"title": "通过微信小程序来实现 “钉钉打卡”", "author": "Rolan", "time": "2020-5-7 00:33", "content": "历史总结：\r\n\r\n微信小程序自定义组件 - 表格组件来啦\r\n记一次微信小程序项目分包，以及分包预下载\r\n微信小程序实战\r\n\r\n需求背景\r\n产品希望统计我们公司线下人员的考勤情况，钉钉的功能目前不能满足一天多次外勤打卡的需求，于是我们打算自己开发一套打卡系统。我们的线下工作人员日常使用的是我们内部的一个微信小程序，产品希望将外勤打卡的功能在小程序上实现。方便线下人员在同一个平台上操作。\r\n微信小程序外勤打卡\r\n我们线下工作人员遍布全国各地，每个人的工作地点可能各不一样，怎样让线下工作人员在指定的地方打卡呢？\r\n1.如何确定打卡的对象和范围\r\n为了方便统一打卡管理，添加一个模块给志愿者管理人员，由管理者添加外勤对象，线下工作者根据当前的定位，选择匹配到方圆1公里的外勤对象，选择对应要打卡的对象进行打卡。\r\n\r\n外勤对象: 线下工作者打卡的目标地\r\n\r\n2.如何保证一天多次打卡\r\n外勤打卡呢，一个线下工作一天要跑多个工作地点，每个地点都要进行打卡，如何保证一天多次打卡呢？产品希望他们每次出勤都有对应的签到和签退，没完成签退，不可以新建一次外勤，每次签到成功就创建了一次外勤，签退不限制地点，可以进行随时签退，这样就保证了每次出勤都是成对的。\r\n\r\n一次外勤：一对签到和签退，要先完成签退，才能到下个地点进行签退。\r\n\r\n3.打卡定位\r\n针对打卡功能，我们选用微信小程序开发里面的位置api：定位、和选点定位。\r\n\r\n\r\n位置api调用前需要 先 用户授权 scope.userLocation。\r\n\r\n这次主要使用的两个位置api:\r\n\r\nwx.chooseLocation 打开地图选择位置；\r\nwx.getLocation 获取当前的地理位置。\r\n\r\n\r\n对经纬度进行逆解析需要申请腾讯地图的 key，申请开发者密钥（Key）。\r\n\r\n来来来，签到了：\r\n\r\n4.如何防止通过刷接口打卡？\r\n\r\nMD5加密\r\n\r\n考虑到有可能通过抓包提交经纬度来进行打卡，我们前后端统一指定了一套打卡加密机制。我们采用的 MD5加密，对经纬度、时间戳、小程序密钥等组合加密，前端每次打卡，都要加密后32密钥传给后端，后端校验通过后，才可以打卡。这样就可以阻止部分通过接口打卡的骚操作了。\r\n\r\n打卡自拍\r\n\r\n我们要求每次签到签退都要进行自拍，虽然不能完全杜绝刷打卡，但却可以 避免一部分作弊。\r\n最终我们的打卡：\r\n小结\r\n最后对于开发团队的总结， 前端主动驱动，需求评估后，提前想好解决方案，尽量减少非预知问题，需求评估后可以提前做个demo，对技术选型、功能的实现程度，以及需求的开发周期的有个大致预期。\r\n参考\r\n\r\n微信小程序文档-位置api\r\n腾讯地图-申请key\r\n腾讯地图-微信小程序插件-地图选点插件"}
{"title": "旋转动画效果", "author": "Rolan", "time": "2020-5-9 00:11", "content": "问题描述在小程序中，如果可以用一个动画效果展现一句话或一段文字，会比普通文字呈现更具吸引力，这不仅是体现更多样的文字效果，更是突出这段文字的一个方法。那么接下来就来看一下如何实现一个文字旋转的动画效果吧。效果图：解决方案1  wxml：这部分很容易实现，只需要设置一个点击旋转标签button以及对一条需要旋转的文字进行数据绑定即可。<view>   <view animation=\"{{animation}}\">我在做动画</view></view><button type=\"primary\"  bindtap=\"rotate\">旋转</button>2  js：js中需要先了解一个animation的api，其中的参数和方法如下：（1）duration: 动画持续多少毫秒。（2）timingFunction:“运动”的方式，本例中的“linear”代表动画以匀速的效果来呈现。（3）delay:多久后动画开始运行，也就是动画延迟开始的时间translate(100,-100)向X轴移动100的同时向Y轴移动-100。（4）step():一组动画完成，例如想让本例中的文字旋转，用this.animation.rotate(360).step()，其中360就表示旋转一周360°。代码如下：Page({   data: {     text: \"Page animation\",     animation: ''   },   onLoad: function (options) {   },   onReady: function () {     //实例化一个动画     this.animation = wx.createAnimation({       // 动画持续时间，单位ms，默认值 400       duration: 1500,       timingFunction: 'linear',       // 延迟多长时间开始       delay: 100,       transformOrigin: 'left top 0',       success: function (res) {         console.log(res)       }     })   },   //旋转   rotate: function () {     //顺时针旋转10度     this.animation.rotate(360).step()     this.setData({       //输出动画       animation: this.animation.export()     })  }})结语文字的动画效果远不止这一种，它可以实现很多样很丰富的形式，本篇只是一个基础的动画效果演示，后续将介绍更丰富的动画效果，欢迎持续关注。"}
{"title": "微信小程序 ｜ 开发常用事例 2", "author": "Rolan", "time": "2020-5-9 00:42", "content": "前言\r\n小程序断断续续搞了有一段时间了，发现在某些情况下，第一次消耗 30 分钟，而后则几分钟即可。\r\n短暂微小积累，做一个积累，也希望帮助有需要的小伙伴～\r\n一起来看关于小程序常用事例\r\n话不多说，立刻开搞～\r\n一、 实现底部 Tab 栏\r\n\"tabBar\": {\r\n    \"color\": \"#515151\",\r\n    \"selectedColor\": \"#01509F\",\r\n    \"list\": [\r\n      {\r\n        \"pagePath\": \"pages/index/index\",\r\n        \"text\": \"预约\",\r\n        \"iconPath\": \"/images/tab_yuyue.png\",\r\n        \"selectedIconPath\": \"images/tab_yuyue_selected.png\"\r\n      },\r\n      {\r\n        \"pagePath\": \"pages/records/records\",\r\n        \"text\": \"记录\",\r\n        \"iconPath\": \"/images/tab_record.png\",\r\n        \"selectedIconPath\": \"/images/tab_record_selected.png\"\r\n      },\r\n      {\r\n        \"pagePath\": \"pages/mine/mine\",\r\n        \"text\": \"我的\",\r\n        \"iconPath\": \"/images/tab_mine.png\",\r\n        \"selectedIconPath\": \"/images/tab_mine_selected.png\"\r\n      }\r\n    ]\r\n  }\r\n复制代码二、 设置 Button 透明无边框\r\n.price_detail .img_info button::after {\r\n  border: none;\r\n}\r\n\r\n.price_detail .img_info button {\r\n  background: none;\r\n}\r\n复制代码三、 设置 CheckBox 样式为圆形 \r\n/* 重写 checkbox 样式 */\r\n\r\n/* 未选中的 背景样式 */\r\ncheckbox .wx-checkbox-input {\r\n  border-radius: 50%;\r\n  width: 46rpx;\r\n  height: 46rpx;\r\n}\r\n\r\n/* 选中后的 背景样式 （红色背景 无边框 可根据UI需求自己修改） */\r\ncheckbox .wx-checkbox-input .wx-checkbox-input-checked {\r\n  border: 1rpx solid #ff783b;\r\n  background: #ff783b;\r\n}\r\n\r\n/* 选中后的 对勾样式 （白色对勾 可根据UI需求自己修改） */\r\ncheckbox .wx-checkbox-input .wx-checkbox-input-checked ::before {\r\n  border-radius: 50%;\r\n  width: 40rpx;\r\n  height: 40rpx;\r\n  line-height: 40rpx;\r\n  text-align: center;\r\n  font-size: 30rpx;\r\n  color: #fff;\r\n  /* 对勾颜色 白色 */\r\n  background: transparent;\r\n  transform: translate(-50%, -50%) scale(1);\r\n  -webkit-transform: translate(-50%, -50%) scale(1);\r\n}\r\n复制代码如下所示：\r\n\r\n四、 Text 文本内显示空格\r\n先来看下效果：\r\n\r\n使用全角空格即可，Mac 上使用方式如下：\r\n\r\nShift + option + B： 选择全角空格即可\r\n\r\n<van-field clearable label=\"微&emsp;&emsp;信\" placeholder=\"请输入微信号码\" />\r\n复制代码五、 点击左上角返回直接返回首页\r\n方式一：\r\n/**\r\n   * 生命周期函数--监听页面卸载\r\n   */\r\n  onUnload: function() {\r\n    wx.navigateBack({\r\n      delta: 6\r\n    })\r\n  },\r\n复制代码方式二：\r\n /**\r\n   * 返回首页\r\n   */\r\n   goBackHome: function() {\r\n    wx.switchTab({\r\n      url: '/pages/index/index',\r\n    })\r\n  },\r\n  \r\n /**\r\n  * 生命周期函数--监听页面卸载\r\n  */\r\n  onUnload: function() {\r\n    wx.switchTab({\r\n      url: '/pages/index/index',\r\n    })\r\n  },\r\n复制代码六、 跳转传值\r\n传值的话，一般可概括为如下俩种：\r\n\r\n下级页面需要得到上级页的 ID （传单值）；\r\n下级页面需要得到上级页例如订单信息以便与下级页填充 （传对象或者 Array 数组 等）。\r\n\r\n首先来看单值传值方式：\r\n<navigator url='/pages/order/order?type=4'>\r\n    <view>\r\n      <image src='../../images/ic_pay_error.png' />\r\n      <text>已退款</text>\r\n    </view>\r\n</navigator>\r\n复制代码接受值方式如下：\r\n/**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function(options) {\r\n    console.log(\"Get Value:\" + options.type)\r\n  },\r\n复制代码而数组或者对象传值类似，区别在于传递对象 or 数组需要对传递的数据转换为字符串类型的 Json 串，如下：\r\nwx.navigateTo({\r\n      url: '/pages/xx/xx?activeTempList=' + JSON.stringify(this.data.activeTempList),\r\n    })\r\n复制代码而取值的地方则是需要将值再次转回去，这里需要注意传递值 key 是什么，获取的时候就 options. 什么：\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function(options) {\r\n    this.setData({\r\n      orderInfo: JSON.parse(options.orderInfo),\r\n    })\r\n  },\r\n复制代码官方地址：developers.weixin.qq.com/miniprogram…\r\n七、 兼容 iPhone X\r\n附上一张未兼容和已兼容的效果图：\r\n\r\n适配步骤：\r\nStep 1： App.js 中检测当前设备是否为 iPhone X\r\n  globalData: {\r\n    // 是否为 iPhoneX 以上版本\r\n    isIphoneX: false\r\n  },\r\n  \r\n  /**\r\n   * 检测当前设备是否为 iPhone X 及以上\r\n   */\r\n  checkIsiPhoneX: function() {\r\n    const self = this\r\n    wx.getSystemInfo({\r\n      success: function(res) {\r\n        // 根据 model 进行判断\r\n        if (res.model.search('iPhone X') != -1) {\r\n          self.globalData.isIphoneX = true\r\n        }\r\n        // 或者根据 screenHeight 进行判断\r\n        // if (res.screenHeight == 812) {\r\n        //   self.globalData.isIphoneX = true\r\n        // }\r\n      }\r\n    })\r\n  },\r\n  \r\n  onLaunch: function() {\r\n    // 判断设备是否为 iPhone X 及以上\r\n    this.checkIsiPhoneX()\r\n  }\r\n复制代码Step 2： 设置兼容以及普通机型下的样式\r\n/* 提交按钮 */\r\n.submit_btn {\r\n  background: #d04801;\r\n  color: #fff;\r\n  border-radius: 50rpx;\r\n  margin: 30rpx;\r\n  font-size: 32rpx;\r\n  padding: 15rpx;\r\n  bottom: 0;\r\n  left: 0;\r\n  right: 0;\r\n  position: absolute;\r\n}\r\n\r\n/* 点击效果 */\r\n.submit_btn:active {\r\n  opacity: 0.6;\r\n}\r\n\r\n/* 提交按钮 iPhone X */\r\n.submit_btn_iPhoneX {\r\n  margin-bottom: 68rpx;\r\n}\r\n复制代码Step 3： 具体的 Page.js 中匹配\r\nconst app = getApp()\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    isIphoneX: app.globalData.isIphoneX,\r\n  },\r\n}\r\n复制代码Step 4： 未指定的控件设置对应的样式兼容\r\n<button class=\"{{ isIphoneX ? 'submit_btn submit_btn_iPhoneX' :'submit_btn'}}\" bindtap=\"{{phone.length ? 'confirmOrder' : ''}}\" open-type=\"{{phone.length ? '' : 'getPhoneNumber'}}\" bindgetphonenumber='bindgetphonenumber'>下一步</button>\r\n复制代码以上内容参考自如下链接：\r\n\r\nkangzubin.com/wxapp-iphon…\r\n\r\n八、来一个弹窗领优惠卷效果\r\n先来看一波效果：\r\n\r\n模拟器有毒，不要在意细节啦～\r\n分布拆解实现步骤：\r\n\r\n弹出层，采用 Vant Popup：youzan.github.io/vant-weapp/… ；\r\n一张红包背景图，扣的累死；\r\n一小撮洋码子。\r\n\r\n此处忽略集成 Vant 步骤。\r\n此处忽略集成 Vant 步骤。\r\n此处忽略集成 Vant 步骤。\r\nStep 1： 在所需要的页面的 json 文件中添加 popup 引用：\r\n  \"usingComponents\": {\r\n    \"van-popup\": \"/miniprogram_npm/vant-weapp/popup/index\"\r\n  }\r\n复制代码Step 2： 拼接红包效果\r\n首先附上样式内容：\r\n.van-popup {\r\n  background: transparent !important;\r\n}\r\n\r\n.red_packet_info {\r\n  position: absolute;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  width: 100%;\r\n}\r\n\r\n.red_packet_title {\r\n  font: 28rpx;\r\n  line-height: 72rpx;\r\n  color: #999;\r\n  margin-top: 16rpx;\r\n}\r\n\r\n.red_packet_price {\r\n  font-size: 72rpx;\r\n  line-height: 56rpx;\r\n  color: #666;\r\n  font-weight: bold;\r\n}\r\n\r\n.give_money_now {\r\n  border-radius: 50rpx;\r\n  margin: 0 100rpx;\r\n  position: relative;\r\n  color: rgb(0, 0, 0);\r\n  top: -200rpx;\r\n}\r\n复制代码随后附上实际码子：\r\n<van-popup show=\"{{ isShow }}\" bind:close=\"getHaveOffer\" close-on-click-overlay=\"true\" custom-class=\"van-popup\">\r\n  <div>\r\n    <div class=\"red_packet_info\">\r\n      <text class='red_packet_title'>优惠卷</text>\r\n      <text class='red_packet_price'>¥{{ offerPrice }}</text>\r\n    </div>\r\n    <image src='/images/bg_red_packet.png' style='height:800rpx;'></image>\r\n    <button class='give_money_now' bindtap='giveMoneyNow'>立即领取</button>\r\n  </div>\r\n</van-popup>\r\n复制代码Step 3： 事件搞起来\r\n  data: {\r\n    offerPrice: 100, // 优惠卷价格，为了演示，后续直接接口获取\r\n  },\r\n  。。。\r\n    /**\r\n   * 点击空白消失\r\n   */\r\n  getHaveOffer: function() {\r\n    console.log(\"---> getHaveOffer\")\r\n    this.setData({\r\n      isShow: false\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 点击获取优惠卷\r\n   */\r\n  giveMoneyNow: function() {\r\n    console.log(\"---> giveMoneyNow\")\r\n    this.setData({\r\n      isShow: false\r\n    })\r\n  },\r\n复制代码就这样，Bye～"}
{"title": "微信小程序 扩展组件 tabs 中的 swiper 部分高度自适应", "author": "Rolan", "time": "2020-5-11 00:09", "content": "由于官方给了 swiper 固定高度150，且 swiper-item 都是 absolute 定位，所以实际应用中经常会碰到问题，在此记录一下修改方式。一、正常 npm 下载 tabs 包，并用开发者工具构建 npm二、修改构建出的目录 miniprogram_npm 目录下的 tabs 插件源码1、修改 tabs 插件的 wxml 文件，添加 style 属性，看下图位置2、修改 tabs 插件的 js 文件，添加 swiperStyle 属性3、使用 tabs 插件的页面添加 swiperStyle 属性，并动态计算高度赋值<mp-tabs \r\n  tabs=\"{{tabs}}\" \r\n  activeTab=\"{{activeTab}}\" \r\n  swiperClass=\"weui-tabs-swiper\"\r\n  bindtabclick=\"onTabCLick\"\r\n  bindchange=\"onChange\"\r\n  activeClass=\"tab-bar-title__selected\"\r\n  swiperStyle=\"height: {{tabSwiperHeight}}px\"\r\n>\r\n  <block wx:for=\"{{tabs}}\" wx:for-item=\"tab\" wx:for-index=\"index\" wx:key=\"index\">\r\n    <view class=\"tab-content tab-content-{{index}}\" slot=\"tab-content-{{index}}\" >\r\n        {{tab.title}}\r\n    </view>\r\n  </block>\r\n</mp-tabs>Page({\r\n  data: {\r\n    tabs: [{title: '首页'}, {title: '外卖'}, {title: '商超生鲜'}, {title: '购物'}, {title: '美食饮品'}, {title: '生活服务'}, {title: '休闲娱乐'}],\r\n    activeTab: 0,\r\n    tabSwiperHeight: 0\r\n  },\r\n  tabsSwiperHeight() {\r\n    // tab 组件内的swiper高度自适应问题\r\n    let index = this.data.activeTab;\r\n    let queryDom = wx.createSelectorQuery()\r\n    queryDom.select('.tab-content-' + index).boundingClientRect().exec(rect => {\r\n      this.setData({\r\n        tabSwiperHeight: rect[0].height\r\n      })\r\n    })\r\n  },\r\n  onTabCLick(e) {\r\n    const index = e.detail.index\r\n    this.setData({activeTab: index})\r\n  },\r\n  onChange(e) {\r\n    const index = e.detail.index\r\n    this.setData({activeTab: index})\r\n    this.tabsSwiperHeight();\r\n  }\r\n}"}
{"title": "智能小程序--四种方式快速实现上拉触底加载更多效果", "author": "Rolan", "time": "2020-5-11 00:12", "content": "在智能小程序的开发过程中，上拉加载是一种十分常见的加载效果，最近也收到了一些开发者在开发上拉加载时遇到的问题，今天的内容就为您介绍一下如果想实现下述效果的上拉加载，我们需要如何去做。以下是为大家总结的四种常见的实现方式：使用 onReachBottom 实现使用 scroll-view 组件实现使用信息流模板实现上拉加载使用 swiper 组件配合 onReachBottom 实现上拉加载使用 onReachBottom 实现智能小程序提供了 onReachBottom ，即页面上拉触底事件的处理函数。可以拿在 Page 中定义 onReachBottom 处理函数，监听该页面用户上拉触底事件，从而实现上拉加载。为方便大家直接使用看到效果，将下述代码片段，直接导入开发者工具中运行查看即可：swanide://fragment/7e944c0c3785bbdf4437c672dd0dc8e41584413934361工具下载链接： Windows / mac代码解析swan 文件是每个智能小程序页面的展现模板，类似于 Web 开发中的 HTML，所以我们先在 swan 文件中设置商品的展现样式：<view class=\"goodsList\">\r\n    <block s-for=\"item,index in goods\">\r\n        <view class=\"goodsItem\">\r\n            <view class=\"goodsImage\">\r\n                <image src=\"{{item.img}}\"></image>\r\n            </view>\r\n            <view class=\"goodsTitle\">\r\n                <text>{{item.title}}</text>\r\n            </view>\r\n        </view>\r\n    </block>\r\n</view>\r\n<view class=\"loading\">努力加载中...</view>在 js 文件中使用 onReachBottom 事件，当页面滑动到页面底部时，请求下一页展示数据，即实现上拉加载的效果。...\r\n...\r\nonReachBottom() {\r\n    //触底时继续请求下一页展示的数据\r\n    this.initData();\r\n}更多内容参见 onReachBottom使用 scroll-view 组件实现利用 scroll-view 组件实现上拉加载也是一种十分常见的方法，实现步骤与使用 onReachBottom 事件类似。scroll-view 是百度智能小程序提供的组件，可实现试图区域的横向滚动和竖向滚动。使用它的 bindscrolltolower 属性，当页面滚动到底部或右边的时候，则会触发scrolltolower事件，从而实现上拉加载的效果。为方便大家直接使用看到效果，将下述代码片段，直接导入开发者工具中运行查看即可：swanide://fragment/fccd71b098a7d3921b9958ccd9dba1071584414516291代码解析在 swan 文件中使用 scroll-view 组件，设置商品的展现样式。当页面滑动至底部时，触发 scrolltolower 事件，实现试图区域的竖向滚动。<view class=\"intro\">\r\n    <scroll-view\r\n     class=\"scrollview\"\r\n     scroll-y\r\n     bindscrolltolower=\"scrolltolower\"\r\n    >\r\n        <view class=\"goodsList\">\r\n            <view s-for=\"item,index in goods\">\r\n                <view class=\"goodsItem\">\r\n                    <view class=\"goodsImage\">\r\n                        <image src=\"{{item.img}}\"></image>\r\n                    </view>\r\n                    <view class=\"goodsTitle\">\r\n                        <text>{{item.title}}</text>\r\n                    </view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n        <view class=\"loading\">努力加载中...</view>\r\n    </scroll-view>\r\n</view>使用信息流模板实现上拉加载信息流模版 是百度智能小程序提供的组件，可配置上拉刷新、列表加载、上拉加载功能，适用于列表信息展示，并可放置在页面的任何部分。与其它组件功能不同，使用信息流模板时需执行下述命令行，引入页面模板。npm i @smt-ui-template/page-feed并在进入page-feed文件夹后，执行下述命令行安装所有模板依赖。npm i为方便大家直接使用看到效果，将下述代码片段，直接导入开发者工具中运行查看即可：swanide://fragment/71af2b7f470b29b13f792c417fc5f03c1588757790402代码解析在 swan 文件中使用信息流模板，通过 smt-spin 组件加载更多数据。<smt-feed\r\n        class=\"smt-feed pull-down-refresh\"\r\n        pull-to-refresh\r\n        bind:scrolltolower=\"scrollToLower\"\r\n        text=\"{{text}}\"\r\n        style=\"height: 100vh\" <!-- 信息流组件作为局部滚动组件，必须在它的父级或本身指定高度 -->\r\n    >\r\n        <view class=\"goodsList\">\r\n            <view s-for=\"item,index in goods\">\r\n                <view class=\"goodsItem\">\r\n                    <view class=\"goodsImage\">\r\n                        <image src=\"{{item.img}}\"></image>\r\n                    </view>\r\n                    <view class=\"goodsTitle\">\r\n                        <text>{{item.title}}</text>\r\n                    </view>\r\n                </view>\r\n            </view>\r\n        </view>\r\n        <smt-spin status=\"{{status}}\" bind:tap=\"reload\"></smt-spin>\r\n</smt-feed>在js文件中，利用在smt-spin组件上绑定的事件，实现加载更多的数据。...\r\n    ...\r\n    async scrollToLower() {\r\n        const goods = await this.initData();\r\n        await syncSetData(this, {\r\n            goods: goods.concat(this.data.goods || [])\r\n        });\r\n    },\r\n    ...\r\n    ...使用 swiper 组件配合 onReachBottom 实现上拉加载使用 swiper 组件配合 onReachBottom 的实现方法也比较常见，相较上边两种实现方式有些复杂，但同时也可以实现更加复杂的上拉加载场景。swiper 组件是智能小程序提供的滑块视图组件，与 swiper-item 组件配合使用，可实现 swiper 组件内 swiper-item 的滑动。需要动态设置 swiper 组件的高度，来保证每次滑动到底时都能触发 onReachBottom 。为方便大家直接使用看到效果，将下述代码片段，直接导入开发者工具中运行查看即可：swanide://fragment/20e8fd8c561418df7c4f24a850bf43461585224391100代码解析根据实际场景需要在 swan 文件中设置 tab，当设置多个tab时，实现效果如下：<view class=\"swiper-tab\">\r\n       <view class=\"tab-item {{currentTab==0 ? 'on' : ''}}\" data-current=\"0\" bindtap=\"swiperNav\">Tab1</view> \r\n       <view class=\"tab-item {{currentTab==1 ? 'on' : ''}}\" data-current=\"1\" bindtap=\"swiperNav\">Tab2</view>\r\n   </view>在 swan 文件中使用 swiper、swiper-item 组件。<swiper class=\"swiper\" style=\"height: {{swiperH}}\" current=\"{{currentTab}}\" bindchange=\"swiperChange\">\r\n        <swiper-item class=\"item\">\r\n            <view class=\"goodsList\">\r\n                <view s-for=\"item,index in goods\">\r\n                    <view class=\"goodsItem\">\r\n                        <view class=\"goodsImage\">\r\n                            <image bindload=\"imageLoad\" src=\"{{item.img}}\"></image>\r\n                        </view>\r\n                        <view class=\"goodsTitle\">\r\n                            <text>{{item.title}}</text>\r\n                        </view>\r\n                    </view>\r\n                </view>\r\n            </view>\r\n            <view class=\"loading\">努力加载中...</view>\r\n        </swiper-item>\r\n        <swiper-item class=\"item\">\r\n            <view class=\"goodsList\">\r\n                <view s-for=\"item,index in goods\">\r\n                    <view class=\"goodsItem\">\r\n                        <view class=\"goodsImage\">\r\n                            <image src=\"{{item.img}}\"></image>\r\n                        </view>\r\n                        <view class=\"goodsTitle\">\r\n                            <text>{{item.title}}</text>\r\n                        </view>\r\n                    </view>\r\n                </view>\r\n            </view>\r\n            <view class=\"loading\">努力加载中...</view>\r\n        </swiper-item>\r\n</swiper>在 js 文件中设置 swiper 组件的高度。// 给image添加load事件，保证图片全部加载出来再计算swiper-item的高度并赋值给swiper\r\nimageLoad() {\r\n       \r\n       let len = this.data.goods.length;\r\n        this.setData({\r\n            imgLoadNum: ++ this.data.imgLoadNum\r\n        })\r\n        if(this.data.imgLoadNum === len){\r\n            this.queryNodeInfo();\r\n        }\r\n    },\r\n    // 设置swiper的高度，如果不动态设置swiper的高度，当页面滑动到底部时，不会触发onReachBottom\r\n    queryNodeInfo: function(){\r\n        let currentTab = this.data.currentTab;\r\n        swan.createSelectorQuery().selectAll('.item').boundingClientRect((rect) => {  \r\n            this.setData({\r\n                swiperH: rect[currentTab].height + 'px'\r\n            })\r\n        }).exec();\r\n}在 js 文件中使用 onReachBottom 事件，当页面滑动到页面底部时，请求下一页展示数据，即实现上拉加载的效果。onReachBottom() { \r\n            this.initData();\r\n    },总结使用方法 1、2、3 可快速实现简单页面的上拉加载；而使用方法 4 可实现页面中存在多个 tab 的场景，比如：最新、最热列表的切换。开发者可根据实际情况选择不同的实现方法。最后，感谢各位开发者积极投身百度小程序的开发当中，在开发过程中有任何问题都可以在社区与官方或其他开发者进行互动，也可将您的意见发送邮件至smartprogramtech@baidu.com，期待您的参与！"}
{"title": "从小程序不支持DOM操作开始深入分析小程序运行机制", "author": "Rolan", "time": "2020-5-11 00:20", "content": "小程序现在如日中天，各大公司都推出了自己的小程序平台，目前看来运行机制都差不多，数据形成视图，渲染和逻辑分成两个线程，交互通过线程通信实现。刚开始接触小程序开发的时候，看到小程序的语法觉得很奇怪。看着像react和vue的结合体，疑惑为什么要这么费力的实现这么一套机制。难道是为了体现技术nb？ 用了一会就发现问题了，照搬pc开发的那套思想，特么小程序里不支持dom相关的api，很不方便。翻了很多遍微信和支付宝小程序的官方文档，终于有了一点理解。本文大部分是官方文档引用加上自己一点总结。web开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应。开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。 而在小程序中，二者是分开的，分别运行在不同的线程中，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。由于支付宝官方文档说明过于简略，本文结合了微信和支付宝小程序的特点总结，结合如有差异，欢迎指正。这部分在 微信 和支付宝小程序官方文档都有说明浏览器环境中渲染线程和js线程是互斥的由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和GUI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。小程序页面文件结构小程序分为 app 和 page 两层。app 用来描述整个应用，page 用来描述各个页面。app 由三个文件组成，必须放在项目的根目录。文件必需作用app.js是小程序逻辑app.json是小程序全局设置app.acss否小程序全局样式表page 由四个文件组成，分别是：文件必需作用app.js是页面逻辑app.axml是页面结构app.json否页面配置app.acss否页面样式为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。单逻辑线程与多webview渲染线程小程序的逻辑层和渲染层是分开的两个线程,小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS脚本工作在逻辑层。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面。小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由客户端做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。从逻辑组成来说，一个小程序是由多个“页面”组成的“程序”。宿主环境提供了 App() 构造器用来注册一个程序App，需要留意的是App() 构造器必须写在项目根目录的app.js里，App实例是单例对象，在其他JS脚本中可以使用宿主环境提供的 getApp() 来获取程序实例。小程序开发框架的逻辑层使用 JavaScript 引擎为小程序提供开发者 JavaScript 代码的运行环境以及微信小程序的特有功能。 逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。 开发者写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 ServiceWorker，所以逻辑层也称之为 App Service。const app = getApp(); \r\n复制代码参考资料: 微信1 、 微信2 、 微信3小程序的运行环境js运行引擎小程序的 JavaScript 代码分为逻辑层脚本和 sjs/wxs 脚本支付宝文档 说sjs和逻辑层运行在相同的 JavaScript 引擎的不同线程中。微信文档 又表示wxs是运行在webview中的，并且提供了更为强大的功能：如果在 iOS 设备上小程序内的 WXS 会比 JavaScript 代码快 2 ~ 20 倍，在 android 设备上二者运行效率无差异；减少通信的次数，让事件在视图层（Webview）响应；用来响应小程序事件，目前只能响应内置组件的事件，不支持自定义组件事件；还能调用逻辑层的事件；对两者sjs/wxs差别表示吃瓜状态，支付宝的sjs明显功能弱了很多，毕竟鸡肋，一般用来模拟vue里的compued功能使用，无法作为事件回调。微信的wxs提供了更强大的支持。试了下sjs不带类似computed缓存功能两个平台都会对新预发的代码进行 babel 转换，使 JavaScript 引擎支持绝大多数 ES6 的新特性，但是对于内置对象未提供完全的Polyfill，具体支持情况可以查阅 支付宝 、 微信。在 iOS 上，小程序逻辑层的 javascript 代码运行在 JavaScriptCore 中；在 Android 上，小程序逻辑层的 javascript 代码运行在 V8 中；视图层渲染在 iOS 上，视图层是由 WKWebView 来渲染的在 Android 上，微信是由自研 XWeb 引擎基于 Mobile Chrome 内核来渲染的，支付宝未找到说明，猜测是UC小程序渲染native组件原理小程序中，有一些组件其实是调用原生组件的，如map、video等，这些复杂交互的控件，原生能带来更好的性能与原生体验。简单说就是在期望插入原生控件的位置渲染一个HTML元素，拿到此DOM的位置，客户端在相同的位置上，根据宽高插入一块原生区域，位置或宽高发生变化时，组件会通知客户端做相应的调整。 可以直接看 官方文档为什么这么设计微信小程序的官方介绍 很全面了回到标题的问题。因为逻辑层Service中的代码与WebView中的代码完全隔离，JavaScriptCore中并没有document，window等对象（ECMAScript标准没有规定DOM，这其实是浏览器提供的）。js和视图（dom所在）没有运行在同一容器中。小程序开发可做的优化减少包的大小很好理解，小程序初次启动时，客户端需要从 CDN 下载小程序资源包，此后，如果小程序代码包未更新且还被保留在缓存中，则下载小程序代码包的步骤会被跳过。可以做的：减少在代码包中直接嵌入的资源文件，建议从 CDN 渠道上传清理无用代码和结构提升首屏，可以使用分包减少setData次数，合并setData每一次setData都是线程通信this.setData({ a: 1 })\r\nthis.setData({ b: 2 })\r\n//可优化为\r\nthis.setData({ a: 1, b: 2 })\r\n复制代码支付宝小程序提供了$batchedUpdatesthis.$batchedUpdates(() => {\r\n    this.setData({\r\n      counter: this.data.counter + 1,\r\n    });\r\n    this.setData({\r\n      counter: this.data.counter + 1,\r\n    });\r\n  });\r\n复制代码优化setDatasetData是线程通信传递数据，传输时数据需要序列化，框架提供了指定路径设置数据的方便，避免一次传输完整数据。this.setData({\r\n  'array[0]': 1,\r\n  'obj.x':2,\r\n});\r\n复制代码针对长列表， 支付宝小程序 提供了优化方法$spliceData，使用方式对应js数组的splicethis.$spliceData({ 'a.b': [1, 0, 5, 6] })\r\n复制代码针对长列表做优化，避免每次传递整个列表，只会从对应组件节点开始做差异比较使用 wxs /sjs小程序中事件响应也需要通过线程通信，如果频繁的触发可能会造成卡顿。例如页面有 2 个元素 A 和 B，用户在 A 上做 touchmove 手势，要求 B 也跟随移动。一次 touchmove 事件的响应过程为：a、touchmove 事件从视图层（Webview）抛到逻辑层（App Service）b、逻辑层（App Service）处理 touchmove 事件，再通过 setData 来改变 B 的位置微信小程序里可以使用wxs响应事件优化，wxs是运行在webview中的，不需要跨线程通信。WXS 函数的除了纯逻辑的运算，还可以通过封装好的ComponentDescriptor 实例来访问以及设置组件的 class 和样式，对于交互动画，设置 style 和 class 足够了：const wxsFunction = function(event, ownerInstance) {\r\n    const instance = ownerInstance.selectComponent('.classSelector') // 返回组件的实例\r\n    instance.setStyle({\r\n        \"font-size\": \"14px\" // 支持rpx\r\n    })\r\n    instance.getDataset()\r\n    instance.setClass(className)\r\n    // ...\r\n    return false // 不往上冒泡，相当于调用了同时调用了stopPropagation和preventDefault\r\n}\r\n复制代码一次 touchmove 的响应需要经过 2 次的逻辑层和渲染层的通信以及一次渲染，通信的耗时比较大。此外 setData 渲染也会阻塞其它脚本执行，导致了整个用户交互的动画过程会有延迟。 官方性能优化文档： 微信 、 支付宝 ;"}
{"title": "Node.js+Express+Mysql+Vue+ElementUI 实现登录注册列表 增删改查 全栈开发一个自己的 ...", "author": "Rolan", "time": "2020-5-11 00:52", "content": "前言记得雷布斯曾经说过：“我们要做米粉心中最牛逼的科技公司“。说实话，小米对我的影响很大（虽然我是个假米粉，但不是为了给小米打广告），小米这几年做出了很多用心的作品，使得大众能买到更高性价比的科技产品。虽然小米跟我没什么直接关系，但是他们的精神，是积极的的、充满力量的，是鼓舞并深深影响着我的，因为我也想做一个很牛逼的产品，我会因此感到自豪。有个灵魂拷问：程序员35岁能干嘛？前江后浪推前浪，我们如果没有爬上去管理层，那就会变成 又贵又没用的东西， 也就是职场中的奢侈品 ， 35岁之后，要明白我们终将被时代抛弃。 35岁以上的职场，只有两种人，职场中的奢侈品，和吃草的万里马。 把体力存进去，换成经验，换成智慧，换成钱的同同时，你要有一个梦想，你能喜欢并且35岁后可以赖此为生。我想要做的产品，是希望能帮助自己更好的规划人生，甚至希望能够造福所有迷茫中的人。所以自己琢磨着尝试开发一个全栈产品，可是，光靠激情没用，我只是一个前端，不是后台，不会写接口，也不会操作服务器，更不要说部署上线了。。。想想实在是太多不会的了。不巧的是，遇上疫情，这更让我想迫切实现我的产品梦。人还是要有梦想的，当你有了这个梦想，自然会有一股非三分钟热度的冲劲，万事都是开头难，管他呢，试了再说。于是，我的个人产品开始了。产品简介我的梦想，想做一个很牛逼的产品： 微信小程序《有梦必达》。有梦必达初衷是一个帮助迷茫的、还没有梦想的、还在寻找梦想的、有梦想却还不知道怎么实现的童鞋更好的寻找或实现梦想的微信小程序。有梦必达的初始设计功能有：登录、注册、找回密码、梦想列表、梦想详情、推荐课程、收藏、浏览记录、阅读数。产品不够完善，仍需要完善，不喜勿喷。开发流程备注：如果有同学完全按照此博客开发产品，可能会遇到坑，例如版本问题导致一些未知bug或者安装系统限制等等。在我开发过程中就遇到过很多小问题，不过只要坚持解决问题，这些问题都难不倒我。即使一开始遇到未知bug还是有点慌，但是后面通过各种方法寻找答案，解决完毕时会很自豪。总体开发流程如下：1、有一颗完成梦想的决心2、购买阿里云域名并且备案3、购买阿里云服务器Cent Os4、服务器安装Node、Npm、Cnpm、Mysql、Nginx并配置、PM25、本地安装Navicat Premium，连接远程服务器的Mysql、创建数据表、安装Xshell连接远程服务器、Xftp查看服务器文件6、Node+Express创建功能接口7、Vue+Element创建后台管理系统8、部署后台管理系统至域名服务器下9、微信小程序+Vant前端展示10、发布微信小程序一、有一颗完成梦想的决心如果想做一个产品，就应该把他当做一个梦想来看待，因为有了梦想，就会有冲劲，自己会觉得有意义，从而时刻保持冲劲，有热情去完成他，而不是三天打鱼两天晒网，顶多坚持几天就半途而废，到最后，产品没完成，自己也觉得自己能力有问题。所以，即使梦想再难，我们也要完成他，即使会慢一点！二、购买阿里云域名并且备案此处较为简单，直接去阿里云官网-购买域名即可 阿里云万网链接地址备注：购买域名后，需要做域名备案才能在线上访问（咱们要做就做正规的） 阿里云首次备案参考链接地址亦可参考其他博客方法备案，能实现备案目的就行三、购买阿里云服务器Cent Os四、服务器安装Node、Npm、Cnpm、Mysql、Nginx并配置、PM2五、本地安装Navicat Premium，连接远程服务器的Mysql、创建数据表、安装Xshell连接远程服务器、Xftp查看服务器文件由于三、四、五步骤篇幅过长， 直接移驾到开源中国预览六、Node+Express创建功能接口nodejs部分:1、package.json{\r\n  \"name\": \"nodeDream\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"app.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"author\": \"parchments\",\r\n  \"license\": \"MIT\",\r\n  \"dependencies\": {\r\n    \"body-parser\": \"^1.19.0\",\r\n    \"cors\": \"^2.8.5\",\r\n    \"express\": \"^4.17.1\",\r\n    \"jsonwebtoken\": \"^8.5.1\",\r\n    \"multer\": \"^1.4.2\",\r\n    \"mysql\": \"^2.17.1\",\r\n    \"nodemon\": \"^2.0.2\",\r\n    \"request\": \"^2.88.2\"\r\n  }\r\n}\r\n复制代码2、connect.jsconst path = require(\"path\");\r\nconst mysql = require(\"mysql\");\r\nconst express = require(\"express\");\r\nconst app = express();//实例化一个app\r\nconst router = express.Router();\r\nconst cors = require('cors');\r\nconst jwt = require('jsonwebtoken');  //用来生成token\r\nconst request = require('request');\r\nconst bodyParser = require('body-parser');\r\napp.use(bodyParser.json());//post请求req.body为空的处理 json请求\r\napp.use(bodyParser.urlencoded({extended: false}));// 表单请求\r\n\r\n// 全局配置跨域\r\napp.use(cors());\r\n\r\n//本地访问不了已上传的图片，需要开启静态资源路径访问\r\nconst pathname = __dirname;\r\n//静态文件访问\r\napp.use(express.static(pathname));\r\n// 使用静态文件   这样可以获取静态文件的东西\r\napp.use(express.static('vueDream/dist'))\r\n\r\n\r\n//校验token\r\nfunction verifyToken(req, res, next){\r\n\tlet secretOrPrivateKey = 'jwtDream';//密钥\r\n\tjwt.verify(req.headers.token, secretOrPrivateKey, function (__err, decode) {\r\n\t\t//时间失效的时候/ 伪造的token\r\n\t\tif (__err) {\r\n\t\t\treturn res.status(401).send({\r\n\t\t\t\tcode: 401,\r\n\t\t\t\tdata: null,\r\n\t\t\t\tmessage: \"登录过期,请重新登录\"\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tnext();\r\n\t\t}\r\n\t})\r\n}\r\n//这里处理全局拦截，一定要写在最上面\r\napp.all('*', (req, res, next) => {\r\n\t//设置响应头\r\n    res.header(\"Access-Control-Allow-Origin\", \"*\"); //*表示允许的域名地址，本地则为'http://localhost'\r\n    res.header(\"Access-Control-Allow-Headers\", \"*\");\r\n    res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\");\r\n    res.header(\"Content-Type\", \"application/json;charset=utf-8\");\r\n\t\r\n\t//如果是登录 注册 找回密码  需要放行  无需校验token\r\n\tlet isLogin = req.url.indexOf('login');\r\n\tlet isRegister = req.url.indexOf('register');\r\n\tlet isForgotPassword = req.url.indexOf('forgotPassword');\r\n\tlet isCollection = req.url.indexOf('collection');\r\n\tlet isHistory = req.url.indexOf('history');\r\n\t// let isWechatLogin = req.url.indexOf('wechatLogin');\r\n\t// let isGetWxAccessToken = req.url.indexOf('getWxAccessToken');\r\n\t//微信小程序  并且是收藏接口需要校验token\r\n\tlet systype = req.headers.systype;\r\n\tif(systype === 'wechat'){\r\n\t\tif(isCollection !== -1 || isHistory !== -1){\r\n\t\t\tverifyToken(req, res, next)\r\n\t\t} else {\r\n\t\t\tnext();\r\n\t\t}\r\n\t} else if(systype === 'pc'){\r\n\t\t//pc   登录注册找回密码放行\r\n\t\tif(isLogin !== -1 || isRegister !== -1 || isForgotPassword !== -1){\r\n\t\t\tnext();\r\n\t\t}else{\r\n\t\t\tverifyToken(req, res, next)\r\n\t\t}\r\n\t}\r\n})\r\n\r\n//这一步目的是，当访问根路径时，把前端代码读取出来并显示\r\napp.get('/', (req, res) => {\r\n\t//服务器地址vueDream/dist/index.html\r\n    res.sendFile(path.resolve(__dirname, 'vueDream', 'dist', 'index.html'));\r\n})\r\n\r\n//配置mysql\r\nconst option = {\r\n\thost: \"www.yousit\",\r\n\t// host: \"49.985.02.01\",\r\n\tuser: 'admin',\r\n\tport: '3306', \r\n    password: \"mmmmmmmm.\",\r\n    database: \"node\",\r\n    connectTimeout: 5000, //连接超时\r\n    //multipleStatements: false //是否允许一个query中包含多条sql语句\r\n}\r\n\r\nlet pool;\r\nrepool();\r\nfunction Res ({ code = 200, message = '', data = {} }) {\r\n    this.code = code;\r\n    this.message = message;\r\n    this.data = data;\r\n}\r\nfunction resJson (_res, result) {\r\n    return _res.json(new Res(result))\r\n}\r\n\r\n//断线重连机制\r\nfunction repool() {\r\n    //创建连接池\r\n    pool = mysql.createPool({\r\n        ...option,\r\n        waitForConnections: true, //当无连接池可用时，等待（true）还是抛错（false）\r\n        connectionLimit: 200, //连接数限制\r\n        queueLimit: 0 //最大连接等待数（0为不限制）\r\n    })\r\n    pool.on('error', err => {\r\n        err.code === 'PROTOCOL_CONNECTION_LOST' && setTimeout(repool, 2000)\r\n    })\r\n    app.all('*', (_,__, next) => {\r\n        pool.getConnection( err => {\r\n            err && setTimeout(repool, 2000) || next()\r\n        })\r\n    })\r\n}\r\n\r\nmodule.exports = { app, pool, router, resJson , jwt , request}复制代码3、app.jsconst { app, pool } = require('./connect');\r\n\r\n//test\r\napp.all('/api', (req, res) => {\r\n    pool.getConnection((err, conn) => {\r\n        res.json({ type: 'test success'})\r\n        pool.releaseConnection(conn) // 释放连接池，等待别的连接使用\r\n    })\r\n})\r\n\r\n//引入上传路由\r\nconst multerUpload = require('./routes/upload');\r\nconst user = require('./routes/user');\r\nconst dreamList = require('./routes/dream');\r\nconst collectionList = require('./routes/collection');\r\nconst historyList = require('./routes/history');\r\n//使用路由\r\napp.use('/upload', multerUpload);\r\napp.use('/user', user);\r\napp.use('/dream', dreamList);\r\napp.use('/collection', collectionList);\r\napp.use('/history', historyList);\r\n\r\n//查看链接成功\r\napp.get('/api/test', function (req, res) {\r\n    res.json({ message: \"连接成功\" })\r\n});\r\n\r\n//开启监听\r\napp.listen(8888, () => {\r\n\tconsole.log(\"服务器端口8888开启中...\");\r\n})复制代码express接口部分:1、其中列表增删改查接口//梦想接口\r\nconst {app, pool, router, resJson, jwt } = require('../connect');\r\n\r\n// 查询\r\n/* \r\n  按分页显示账号列表的路由 /getData\r\n*/\r\napp.post(\"/api/dream/getData\", (req, res) => {\r\n\t\t//后期需要补充校验\r\n\t\tconsole.log(\"前端传过来的\",req.body)\r\n\t\t// 接收前端参数\r\n\t\tlet { pageSize, pageNo , name , userId} = req.body;\r\n\t\t// 默认值\r\n\t\tpageSize = pageSize ? pageSize : 5;\r\n\t\tpageNo = pageNo ? pageNo : 1;\r\n\t\tname = name ? name : null;\r\n\t\t   \r\n\t\t// 构造sql语句 （查询所有数据 按照时间排序）\r\n\t\tlet sqlStr = `select * from dream`;\r\n\t\t// 执行sql语句\r\n\t\tpool.getConnection((err, conn) => {\r\n\t\t\tconn.query(sqlStr, (err, data) => {\r\n\t\t\t  if (err) throw err;\r\n\t\t\t  // 计算数据总条数\r\n\t\t\t  let total = data.length;\r\n\t\t   \r\n\t\t\t  // 分页条件 (跳过多少条)\r\n\t\t\t  let n = (pageNo - 1) * pageSize;\r\n\t\t\t  //   sqlStr += ` limit ${n}, ${pageSize}`;//表示从pageNo条数据取，取pageSize条数据  此处空格不能去掉不然无响应\r\n\t\t\t  // 拼接分页的sql语句\r\n\t\t\t\tif(name){\r\n\t\t\t\t\tsqlStr += ` where name like '%${name}%'`;\r\n\t\t\t\t\t// 执行sql语句 （查询对应页码的数据）\r\n\t\t\t\t\tconn.query(sqlStr, (_err, _data) => {\r\n\t\t\t\t\t  if (_err) throw _err;\r\n\t\t\t\t\t  res.send({\r\n\t\t\t\t\t\t  code: 1,\r\n\t\t\t\t\t\t  data: {\r\n\t\t\t\t\t\t\t  rows: _data,\r\n\t\t\t\t\t\t\t  total: _data.length,\r\n\t\t\t\t\t\t\t  pageNo: pageNo,\r\n\t\t\t\t\t\t\t  pageSize: pageSize,\r\n\t\t\t\t\t\t  },\r\n\t\t\t\t\t\t  message: '查询成功！'\r\n\t\t\t\t\t  });\r\n\t\t\t\t\t});\r\n\t\t\t\t}else{\r\n\t\t\t\t\tsqlStr += ` limit ${n} , ${pageSize}`;\r\n\t\t\t\t\tconn.query(sqlStr, (_err, data) => {\r\n\t\t\t\t\t  if (_err) throw _err;\r\n\t\t\t\t\t  res.send({\r\n\t\t\t\t\t\t  code: 1,\r\n\t\t\t\t\t\t  data: {\r\n\t\t\t\t\t\t\t  rows: data,\r\n\t\t\t\t\t\t\t  total: total,\r\n\t\t\t\t\t\t\t  pageNo: pageNo,\r\n\t\t\t\t\t\t\t  pageSize: pageSize,\r\n\t\t\t\t\t\t  },\r\n\t\t\t\t\t\t  message: '查询成功！'\r\n\t\t\t\t\t  });\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tpool.releaseConnection(conn) // 释放连接池，等待别的连接使用\r\n\t\t})\r\n  });\r\n\r\n//添加接口\r\napp.post('/api/dream/add', (req, res) => {\r\n    //后期需要补充校验\r\n    const data = req.body;\r\n    const name = req.body.name;\r\n    const sqlSameName = `select name from dream where name='${name}'`;\r\n    //先查询数据库 dream 表里是否有前端传来的name值了 如果有返回重复提示 否则插入数据库\r\n\tpool.getConnection((err, conn) => {\r\n\t\tconn.query(sqlSameName, data, (_err, _results) => {\r\n\t\t\tif(_err){console.log(_err); return false;}\r\n\t\t\t//根据查询表结果个数判断，如果1为数据库已经存在此名称，不可插入   0代表数据库不存在此名称，可插入\r\n\t\t\tif(_results.length > 0){\r\n\t\t\t\treturn res.json({\r\n\t\t\t\t\tcode: 0, \r\n\t\t\t\t\tmessage: \"不可重复添加！\", \r\n\t\t\t\t\tdata: null\r\n\t\t\t\t})\r\n\t\t\t}else{\r\n\t\t\t\tconst sqlStr = 'insert into dream set ?';\r\n\t\t\t\tconn.query(sqlStr, data, (err, results) => {\r\n\t\t\t\t\tconsole.log(data)\r\n\t\t\t\t\tif (err) throw err;\r\n\t\t\t\t\tres.json({\r\n\t\t\t\t\t\tcode: 1,\r\n\t\t\t\t\t\tmessage: '添加成功',\r\n\t\t\t\t\t\tdata: results\r\n\t\t\t\t\t});\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n        pool.releaseConnection(conn) // 释放连接池，等待别的连接使用\r\n    })\r\n});\r\n\r\n//修改\r\napp.post('/api/dream/edit', function (req, res) {\r\n    //后期需要补充校验\r\n    const data = req.body;\r\n    const id = req.body.id;\r\n    // let { name, collectionStatus, price, age, experience, education, analysis, introduce, duty, ask, coverImagePath, planImagePathArray, viedoUrl}  = req.body;\r\n    let { name, coverImagePath, content, viedoUrl , recommend}  = req.body;\r\n    let modSql = `update dream set \r\n\t\t\t\t\tname='${name}', \r\n\t\t\t\t\tcoverImagePath='${coverImagePath}', \r\n\t\t\t\t\tcontent='${content}', \r\n\t\t\t\t\tviedoUrl='${viedoUrl}',\r\n\t\t\t\t\trecommend='${recommend}'\r\n\t\t\t\t\twhere id ='${id}'`;\r\n\tlet nameSql = `select * from dream where name='${name}' and id !='${id}'`;\r\n\t//先查询数据库 dream 表里是否有前端传来的name值了 如果有返回重复提示 否则更新数据库\r\n\tpool.getConnection((err, conn) => {\r\n\t\tconn.query(nameSql, data, (err, results) => {\r\n\t\t\tconsole.log(results)\r\n\t\t\tif(results.length >= 1){\r\n\t\t\t\treturn res.json({\r\n\t\t\t\t\tcode: 0, \r\n\t\t\t\t\tmessage: \"名称已经存在！\", \r\n\t\t\t\t\tdata: null\r\n\t\t\t\t})\r\n\t\t\t}else{\r\n\t\t\t\tconn.query(modSql, data, (err, results) => {\r\n\t\t\t\t\tres.json({\r\n\t\t\t\t\t\tcode: 1,\r\n\t\t\t\t\t\tmessage: '修改成功',\r\n\t\t\t\t\t\tdata: results\r\n\t\t\t\t\t});\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n        pool.releaseConnection(conn) // 释放连接池，等待别的连接使用\r\n    })\r\n});\r\n//查看\r\napp.post('/api/dream/show', function (req, res) {\r\n    //后期需要补充校验\r\n    let data = req.body;\r\n\t//id是商品id\r\n    let { id , userId}  = req.body;\r\n    let modSql = `select * from dream where id='${id}'`;\r\n\tpool.getConnection((err, conn) => {\r\n\t\tconn.query(modSql, data, (err, results) => {\r\n\t\t\tif (err) {\r\n\t\t\t\tconsole.log(\"查询失败原因\",err)\r\n\t\t\t\treturn res.json({\r\n\t\t\t\t\tcode: 0, \r\n\t\t\t\t\tmessage: \"查询失败\", \r\n\t\t\t\t\taffectedRows: err\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\t// 1.查询出当前readCount\r\n\t\t\tresults[0].readCount = results[0].readCount+1;\r\n\t\t\tlet newReadCount = results[0].readCount;\r\n\t\t\t\r\n\t\t\t// 2.更新列表的id readCount\r\n\t\t\tlet sqlDreamCountStr = `update dream set readCount='${newReadCount}' where id ='${id}'`;\r\n\t\t\tconn.query(sqlDreamCountStr, data, (_err, _data) => {\r\n\t\t\t  if (_err) throw _err;\r\n\t\t\t  console.log('更新列表的id readCount成功');\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t// 返回\r\n\t\t\tres.json({\r\n\t\t\t\tcode: 1,\r\n\t\t\t\tmessage: '查询成功',\r\n\t\t\t\tdata: results\r\n\t\t\t});\r\n\t\t})\r\n        pool.releaseConnection(conn) // 释放连接池，等待别的连接使用\r\n    })\r\n});\r\n\r\n//  删除\r\napp.post('/api/dream/del', (req, res) => {\r\n    //后期需要补充校验\r\n    console.log(req.body)\r\n    // let sqlStr = `DELETE FROM dream WHERE id = ${req.body.id}`;//单个删除\r\n    let sqlStr = `DELETE FROM dream WHERE id in (${req.body})`;\r\n\tpool.getConnection((err, conn) => {\r\n\t\tconn.query( sqlStr, (err , results) => {\r\n\t\t\tif(err) {\r\n\t\t\t\tconsole.log(err);\r\n\t\t\t}else {\r\n\t\t\t\tres.json({\r\n\t\t\t\t\tcode: 1,\r\n\t\t\t\t\tmessage: '删除成功',\r\n\t\t\t\t\tdata: results\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t})\r\n        pool.releaseConnection(conn) // 释放连接池，等待别的连接使用\r\n    })\r\n})\r\n\r\nmodule.exports = router;复制代码2、更多功能接口 请前往github预览七、Vue+Element创建后台管理系统以vue-admin-template作为基础后台框架， 查看vue-admin-template地址 ，搭建我的小程序后台管理系统，为实现登录、注册、用户列表增删改查、梦想列表增删改查、梦想详情、收藏、收藏列表增删改查、浏览记录等功能八、部署后台管理系统至域名服务器下由于三、四、五步骤篇幅过长， 直接移驾到开源中国预览九、成果展示"}
{"title": "做好内容安全检测，和风险说「再见」！", "author": "Rolan", "time": "2020-5-12 00:11", "content": "前言内容安全检测，是每一个小程序主都面临的“头疼”问题，轻则短暂性不可访问，重则永久封号，甚至关小黑屋。本文将为您详细说明，如何在小程序中对一段文本进行合法内容检测，以判断是否含有违法违规内容。本文重点为你讲述：内容安全检测常见应用场景及解决办法学会使用小程序·云开发的云函数+结合request-promise第三方库实现内容请求校验掌握如何在小程序端请求云函数（有别于传统的wx.request的方式(类似AJax)）在云开发的云函数端,利用第三方https请求库(request,request-promise),获取Access_token,以及向微信官方提供的内容检测接口发请求进行校验云函数端与小程序端错误码的处理01.背景无论是小程序还是自行开发的一些类似社交,带有用户自行产生内容的软件应用,例如:即时通讯,社群,论坛,音视频直播等,对于接入内容安全的检测是非常有必要的。对于小程序而言,这一点在审核上是非常严格的,净化言行,做一个知法守法的人很重要...接入内容安全检测,规避输入一些违法违规低俗等内容,避免辛辛苦苦开发出来的应用。被恶意上传反动言论或上传一些违规内容(文字/图片/视频等),导致小程序或应用被下架,或遭永久禁封,或个人及公司被公安机关打电话,约喝茶等,这样的话,就得不偿失了的。02.应用场景检测小程序用户个人文字资料是否违规针对特点词汇（如过于商业以及营销之类的词）可以进行过滤或禁止输入在内容发布之前自动检测用户发表的信息（包括评论、留言等）是否违规03.解决办法围绕如何处理内容安全检测问题，一般有3种方法：方案1****:引入第三方接口对内容进行校验(例如:百度AI内容审核平台,网易云盾等)方案2: 公司后台小伙伴自行开发文本,图片,音视频等内容审核接口方案3: 小程序服务端提供的API进行校验每一种方法各有优劣势，具体如下图。解决方案优势劣势1引入第三方接口对内容进行校验前端同学只需按照官方提供的第三方接口文档,进行校验即可,无需后台介入,功能强大,覆盖范围广接口调用的频次有限制,收费2公司后台小伙伴自行开发文本,图片,音视频等内容审核接口后台小伙伴自己造轮子,根据自己的业务需求以及用户属性,自定义内容审核机制开发周期长,成本大,难以覆盖全面3调用小程序服务端提供的内容安全API进行校验简单,高效想不出来,因为相比前两种方案,对于不依赖后端接口的开发者来说,简直是雪中送炭在微信小程序生态下，官方提供了2种路径帮助用户解决内容检测问题，即使用服务器开发模式，通过HTTPS调用使用小程序·云开发，通过云函数或云调用来实现。服务器开发模式，相信大家都相对比较熟悉，在此就不再赘述。接下来为大家重点介绍，如何通过小程序·云开发的云函数实现内容安全检测。04.通过云开发的云函数+request-promise第三方库实现内容请求校验Step 1: 在小程序端先布局：完成静态页面。(pages文件夹下的文件都是属于小程序前端代码,每个文件夹目录代表的就是一个模块,一个页面)小程序前端wxml代码示例<view class=\"container\">\r\n  <textarea class=\"content\" placeholder=\"写点文字...\" bindinput=\"onInput\" auto-focus bindfocus=\"onFocus\" bindblur=\"onBlur\">\r\n  </textarea>\r\n</view>\r\n\r\n<view class=\"footer\">\r\n  <button class=\"send-btn\" size=\"default\" bind:tap=\"send\">发布</button>\r\n</view>小程序前端wxss代码示例/* pages/msgSecCheck/msgSecCheck.wxss */\r\n.container {\r\n  padding: 20rpx;\r\n}\r\n\r\n.content {\r\n  width: 100%;\r\n  height: 360rpx;\r\n  box-sizing: border-box;\r\n  font-size: 32rpx;\r\n  border: 1px solid #ccc;\r\n}\r\n\r\n.footer {\r\n  width: 100%;\r\n  height: 80rpx;\r\n  line-height: 80rpx;\r\n  position: fixed;\r\n  bottom: 0;\r\n  box-sizing: border-box;\r\n  background: #34bfa3;\r\n}\r\n\r\n.send-btn {\r\n  width: 100% !important;\r\n  color: #fff;\r\n  font-size: 32rpx;\r\n}\r\n\r\nbutton {\r\n  width: 100%;\r\n  background: #34bfa3;\r\n  border-radius: 0rpx;\r\n}\r\n\r\nbutton::after {\r\n  border-radius: 0rpx !important;\r\n}经过wxml与wxss的编写后,UI最终长成这样Step 2: 完成小程序端业务逻辑的处理小程序端逻辑JS代码示例// pages/msgSecCheck/msgSecCheck.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    textareaVal: ''   // 页面中需要显示的数据,初始化定义在data下面\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n\r\n  },\r\n  // 监听表单时,数据有变化时\r\n  onInput(event) {\r\n    let textVal = event.detail.value;\r\n    this.setData({\r\n      textareaVal: textVal\r\n    })\r\n    \r\n  },\r\n\r\n  // 聚焦焦点时\r\n  onFocus() {\r\n    console.log('聚焦焦点时');\r\n  },\r\n\r\n  // 失去焦点时\r\n  onBlur(event) {\r\n    console.log(\"失去焦点时\");\r\n    // 前端可进行手动的弱校验,也可以在失去焦点时发送请求进行文本的校验,但是每次失去焦点就请求一次,这样是消耗云资源的,在发布时候与失去焦点做校验两者都可以\r\n\r\n\r\n  },\r\n\r\n  // 发布\r\n  send() {\r\n    console.log(\"触发发布按钮\")\r\n    wx.cloud.callFunction({ // 请求msgSecCheck1云函数\r\n      name: 'msgSecCheck1',\r\n      data: {\r\n        content: this.data.textareaVal // 需要向云函数msgSecCheck1传入的值\r\n      }\r\n\r\n    }).then(res => { // 成功时的响应返回结果\r\n      console.log(res);\r\n    }).catch(err => { // 失败时,返回的结果\r\n      console.error(err);\r\n    })\r\n    \r\n  }\r\n\r\n})Step 3 ：服务端逻辑处理。在小程序云函数端创建云函数msgSecCheck1,这个名字你可以自定义,与小程序前端请求的名字保持一致就可以了。选中云函数,右键并打开命令行终端安装request,request-promise，因为request-promise依赖于request,两个都要安装,最后一键上传部署就可以了npm install request\r\nnpm install request-promise如果遇到在小程序端请求云函数时,遇到类似下面的错误,找不到什么xxx模块之类的 先看错误码,然后在官方文档中找到该错误码代表的含义一看错误,没有找到模块,在云函数的目录下的package.json中查看是否有安装错误中提示的包的,要是没有的话,就安装一下就可以了的,同时记得每次更改后都要上传部署一下,也可以选择云函数中文件的增量上传接下来是将是本文的重点内容！Step 4 :通过云函数+****request-promise实现内容安全检测对于小程序开发,其实与web端开发也是类似,给元素绑定事件,然后获取元素,只是小程序端没有DOM,BOM的那一套东西,它是数据驱动视图的,吸收了Angular,Vue,React的各个框架的优点,形成了自己的一套规范。如果有这方面开发经验的小伙伴来说,平缓过度到小程序开发当中来,你会发现总会有惊人的相似,用的语言都是JavaScript,但是与web开发还是多少有很多差异的,这里就不拓展了。废话不多说,直接上代码 ：小程序前端逻辑代码：// 点击发送按钮,对输入的文本内容进行校验\r\n send() {\r\n    wx.cloud.callFunction({\r\n      name: 'msgSecCheck1', // 云函数的名称\r\n      data: { // 需要向云函数传递过去的数据\r\n        content: this.data.textareaVal // 具体要检测的内容\r\n      }\r\n    }).then(res => { // 成功时,做什么事情\r\n      console.log(res);\r\n      // 检测到文本成功时,做一些业务\r\n\r\n    }).catch(err => { // 失败时,做什么事情\r\n      // 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作\r\n\r\n      console.error(err);\r\n    })\r\n  }上面的代码还可以在优化一下,就是将请求云函数的代码封装成一个函数。如下所示,不封装也是没事的,只是我习惯性封装一下,如果其他地方也用到该云函数,那么直接调用，避免写重复的代码。下面是将请求云函数的部分核心代码：// 发布\r\n  send() {\r\n    // 请求msgSecCheck1云函数,对文本内容进行校验\r\n    this._requestCloudMsgCheck();\r\n  },\r\n\r\n  _requestCloudMsgCheck() {\r\n    let textareaVal = this.data.textareaVal;\r\n    wx.cloud.callFunction({\r\n      name: 'msgSecCheck1',\r\n      data: {\r\n        content: textareaVal // 这里可以使用官方文档测试用例,特3456书yuuo莞6543李zxcz蒜7782法fgnv级\r\n      }\r\n    }).then(res => {\r\n      console.log(res);\r\n      // 检测到文本成功时,做一些业务\r\n    }).catch(err => {\r\n      // 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作\r\n      console.error(err);\r\n    })\r\n  }至于是在失去焦点事件时发送请求还是在点击发送按钮时发送请求,两种方式都可以。您也可以自定义文本校验,而我个人觉得在小程序端,失去焦点时,可以自定义做一些常规敏感词的弱校验,而在点击发送按钮时,做强校验 。如果是放在失去焦点时就立马请求,这样请求次数会增多,而放在点击发送按钮时进行校验,一定程度上可以减少小程序端频繁请求。接下来就是处理云函数端,使用request-promise请求请求微信内容安全接口的示例代码。/*\r\n *  Description: 利用第三方库request-promise请求微信内容安全接口\r\n *\r\n * 相关文档链接:\r\n * 微信文本内容安全接口文档https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/sec-check/security.msgSecCheck.html\r\n * access_token获取调用凭证文档\r\nhttps://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\r\n *\r\n * request-promise使用文档: https://github.com/request/request-promise\r\n *\r\n */\r\n\r\nconst APPID = \"wx21baa58c6180c2eb\"; // 注意是你自己小程序的appid\r\nconst APPSECRET = \"\"; // 你自己小程序的appsecret\r\n// 安全校验接口\r\nconst msgCheckURL = `https://api.weixin.qq.com/wxa/msg_sec_check?access_token=`;\r\n// 向下面的这个地止发送请求,携带appid和appsecret参数,获取token认证\r\nconst tokenURL = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${APPID}&secret=${APPSECRET}`\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 引入request-promise\r\nconst rp = require('request-promise');\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  try {\r\n    let tokenResponse = await rp(tokenURL);\r\n    // 获取token值,因为返回的结果是字符串,需要用JSON.parse转化为json对象\r\n    let getAccessToken = JSON.parse(tokenResponse).access_token;\r\n    // 请求微信内容安全接口,post请求,返回最终的校验结果\r\n    let checkResponse = await rp({\r\n      method: 'POST',\r\n      url: `${msgCheckURL}${getAccessToken}`,\r\n      body: {\r\n        content: event.content // 这里的event.content是小程序端传过来的值,content是要向内容接口校验的内容\r\n      },\r\n      json: true\r\n    })\r\n    return checkResponse;\r\n  } catch (err) {\r\n      console.error(err);\r\n  }\r\n}当你在小程序端输入文本,发送请求时,查看控制台下的结果时,功能是没有问题的。特3456书yuuo莞6543李zxcz蒜7782法fgnv级\r\n完2347全dfji试3726测asad感3847知qwez到您可以根据官方文档中提供的测试用例,进行测试,看具体的返回结果的。（控制台错误码）(合规内容)云函数请求成功,看看错误信息的反馈,对于熟悉该错误码的人清楚该文本违规了,但是反馈不是很明显,即使当下自己很清楚,然而,在过几个月在回来看代码,你或许都不知道是啥意思。Step 5 ：错误码的正确处理方式对于处理错误码,返回具体的合适信息,对于调试代码,排查问题,也是非常重要 。这些错误码具体的含义,在官方文档里都有对应的解释,不用去记,去查文档就行。在面试中,有很多面试官喜欢问http相关状态码的问题,状态码有很多,也真的记不住,但是常见的错误http状态码还是要知道的,我觉得,具体知道怎么处理,怎么查文档就可以了。真正考验背后目的是,对于根据后端返回的状态码,判断接口哪里出了问题,定位是前端问题还是后端问题,这是一个非常常见的问题。如果你说你不知道,没有处理过,对于候选人,那肯定是没有信服力的,无论是成功状态还是失败状态,都是应该有对应的用户提示。05.完整文本安全校验示例代码/*\r\n *\r\n * 相关文档链接:\r\n * 微信文本内容安全接口文档https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/sec-check/security.msgSecCheck.html\r\n * access_token获取调用凭证文档\r\nhttps://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\r\n *\r\n * request-promise使用文档: https://github.com/request/request-promise\r\n *\r\n */\r\n\r\nconst APPID = \"wx21baa58c6180c2eb\";\r\nconst APPSECRET = \"\";\r\n\r\nconst msgCheckURL = `https://api.weixin.qq.com/wxa/msg_sec_check?access_token=`;\r\n// 向下面的这个地止发送请求,携带appid和appsecret参数,获取token认证\r\nconst tokenURL = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${APPID}&secret=${APPSECRET}`\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 引入request-promise\r\nconst rp = require('request-promise');\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  try {\r\n    let tokenResponse = await rp(tokenURL);\r\n    // 获取token值,因为返回的结果是字符串,需要用JSON.parse转化为json对象\r\n    let getAccessToken = JSON.parse(tokenResponse).access_token;\r\n    // 请求微信内容安全接口,post请求,返回最终的校验结果\r\n    let checkResponse = await rp({\r\n      method: 'POST',\r\n      url: `${msgCheckURL}${getAccessToken}`,\r\n      body: {\r\n        content: event.content // 这里的event.content是小程序端传过来的值,content是要向内容接口校验的内容\r\n      },\r\n      json: true\r\n    })\r\n\r\n    // 有必要根据错误码,确定内容是否违规\r\n    if (checkResponse.errcode == 87014) {\r\n      return {\r\n        code: 500,\r\n        msg: \"内容含有违法违规内容\",\r\n        data: checkResponse\r\n      }\r\n    } else {\r\n      return {\r\n        code: 200,\r\n        msg: \"内容OK\",\r\n        data: checkResponse\r\n      }\r\n    }\r\n  } catch (err) {\r\n    if (err.errcode == 87014) {\r\n      return {\r\n        code: 500,\r\n        msg: '内容含有违法违规内容',\r\n        data: err\r\n      }\r\n    } else {\r\n      return {\r\n        code: 502,\r\n        msg: '调用msgCheckURL接口异常',\r\n        data: err\r\n      }\r\n    }\r\n  }\r\n}在云函数端,经过添加错误码的判断之后,在来看看小程序端发送的请求,返回的结果。（这与没有添加错误码判断,是不一样的,有具体的错误信息内容）至此,我们在小程序端可以根据这个返回的错误码或成功码,进行一些业务逻辑处理的,比如给一些用户提示,在数据插入数据库之前就做一些判断操作,只有内容合规时,才插入数据库,进入下一步的业务逻辑处理。_requestCloudMsgCheck() {\r\n    let textareaVal = this.data.textareaVal;\r\n    wx.cloud.callFunction({\r\n      name: 'msgSecCheck1',\r\n      data: {\r\n        content: textareaVal\r\n      }\r\n    }).then(res => {\r\n      console.log(res);\r\n      const errcode = res.result.data.errcode;\r\n      // 检测到文本错误时,做一些业务\r\n      if (87014 === errcode) {\r\n         wx.showToast({ // 当内容违规时,做一些用户提示\r\n           title: '您输入的文本内容含有敏感内容,请重新输入',\r\n         })\r\n      }else {\r\n         // 成功时做其他业务操作\r\n      }\r\n    }).catch(err => {\r\n      // 失败时,也就是违规做一些用户提示,或者禁止下一步操作等之类的业务逻辑操作\r\n      console.error(err);\r\n    })\r\n  }(当输入的内容有违规时,给一些用户提示或者阻止下一步操作等的)注意在云函数(后)端处理错误码与小程序端都是要进行处理的,两者不要混淆了的,小程序端最终的一些业务逻辑判断,是根据后端接口返回的状态,最终决定要做什么操作的。至此,通过request-promise库就完成了文本内容校验的问题。这个request,request-promise库非常实用,功能也非常强大,类似这种库,常见什么got,axios等之类的,都是支持promise风格的 处理方式大同小异,大家可以去npm或github上阅读相关使用文档的。06.结语在小程序中有多种解决方案,推荐使用小程序端请求云开发云函数的方式,无论是不使用云函数方式,自己有后端服务,获取access_token都应该是从后端返回给前端的。而小程序的秘钥 AppSecret是不应该放在小程序端的,那样不安全的,无论是服务器开发模式还是小程序·云开发模式,都绕不过后台请求微信提供的内容安全接口,然后在返回给小程序端 。其实在小程序·云开发中,还提供了一种更简便的方法,那就是云调用,它是小程序·云开发提供的在云函数中调用微信开放接口的能力,只需简单的进行配置一下就可以了。限于篇幅所致,放在下一节介绍。reference:方案1参考链接:微信内容安全:https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/sec-check/security.msgSecCheck.html云调用https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/capabilities.html#%E4%BA%91%E5%87%BD%E6%95%B0百度文本审核https://ai.baidu.com/tech/textcensoring网易云盾https://dun.163.com/product/text-detection公众号：腾讯云云开发腾讯云云开发： https://cloudbase.net云开发控制台： https://console.cloud.tencent.com/tcb?from=12304"}
{"title": "小程序 Button图标样式 实现悬浮按钮效果", "author": "Rolan", "time": "2020-5-12 00:31", "content": "buttonbutton是小程序中重要的组件微信官方api但是这样的效果都不具备很好的美观性类似于Android开发中的悬浮按钮表单中的使用非表单中实现悬浮按钮效果将一个 矢量图图标 用小程序控件封装即可这里使用text控件 将矢量图作为其 background-Image代码wxml <text class=\"icon\"></text>wxss                这里使用的是 position fixed 所以可以实现   位置固定   类似悬浮按钮.icon {    bottom: 88rpx;  right: 50rpx;  position: fixed;  width: 100rpx;  height: 100rpx;  background-color: white;  border-radius: 50%;  background-size: 72% 72%;  background-position: center;  background-repeat: no-repeat;  background-image: url(\"data:image/svg+xml,%3Csvg t='1587350579334' class='icon' viewBox='0 0 1024 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='3978' width='32' height='32'%3E%3Cpath d='M488 488V192a16 16 0 0 1 16-16h16a16 16 0 0 1 16 16v296H832a16 16 0 0 1 16 16v16a16 16 0 0 1-16 16H536V832a16 16 0 0 1-16 16h-16a16 16 0 0 1-16-16V536H192a16 16 0 0 1-16-16v-16a16 16 0 0 1 16-16h296z' p-id='3979'%3E%3C/path%3E%3C/svg%3E\");}background-image资源网站海量精美矢量图复制 svg 代码注意这里直接使用该url在小程序中是不行的，存在编码错误 下面是一个转编码的网站转换工具网站转换后的 就可以在小程序中使用粘贴到 wxss中必须使用Button 又想 实现 图标效果button有一些其他控件不具备的属性 比如 form 组件中 添加的 button 可以设置 重置表单 提交表单使用 text 就不行此时我们使用 button 包裹一个 text （前面的实现方法的text）代码wxml <button class=\"submitClass\" form-type=\"submit\" bindtap=\"submitForm\">            <text class=\"circle\"></text>        </button>        <button form-type=\"reset\" bindtap=\"resetForm\" class=\"submitClass\">            <text class=\"circleL\"></text>        </button>wxss.submitClass{  margin-top: 160rpx;  margin-bottom: 25rpx;  background: none !important;  color: #000 !important;}这里的button的wxss 让 button 没有边框 看得见内部的 text的样式。"}
{"title": "小程序实现全屏幕高斯模糊背景图", "author": "Rolan", "time": "2020-5-12 00:48", "content": "老规矩，先看效果图1，用网络图片实现2，用本地图片实现通过上面两张图可以看出来，我们既可以用网络图片来实现高斯模糊，有可以用本地图片来实现。一，先来用本地图片做全屏背景1，先在wxml文件里引入本地图片2，然后设置wxss样式通过下图几段样式代码，就可以轻松实现全屏背景这个图片大家应该熟悉吧，这是石头哥的头像。原本是哥正方形，我们要想实现全屏背景，就要用到下面这几行代码了。.gaoshi-bendi {  /* 这一步设置是关键设置 */  position: absolute;  width: 100%;  height: 100%;  top: 0;  bottom: 0;  left: 0;  right: 0;}这样我们就实现了全屏背景（图片背景）了，接下来我们来做模糊效果二，实现模糊效果这里主要用到了 CSS3的 filter(滤镜) 属性通过上面这张图和下面这张图对比，可以看到filter的值越大越模糊。这样我们就轻松的实现了本地图片的高斯模糊效果。但是有时候我们不仅仅是用到本地图片，我们还需要用到网络图片。那这时候该怎么办呢？三，网络图片实现高斯模糊效果1，不管是本地图片还是网络图片，首先我们还是要让图片做全局拉伸。原图长这样，可以看到我们做全屏背景的时候把这个图片从中间裁剪拉伸了background属性里的 center/cover起了主要作用。2，然后就是用filter做模糊效果了到这里我们小程序就轻松的实现高斯模糊效果了。是不是很简单。今天就到这里了，后面我还会分享更多小程序相关的知识出来。请持续关注。"}
{"title": "从0到1使用python开发一个半自动答题小程序的实现", "author": "Rolan", "time": "2020-5-13 00:21", "content": "前言最近每天都有玩微信读书上面的每日一答的答题游戏，完全答对12题后，可以瓜分无限阅读卡。但是从小就不太爱看书的我，很难连续答对12道题，由此，产生了写一个半自动答题小程序的想法。我们先看一张效果图吧(ps 这里主要是我电脑有点卡，点击左边地选项有延迟)项目GIthub地址： 微信读书答题python小程序觉得对你有帮助的请点个⭐来支持一下吧。演示图：做前准备mumu模拟器 因为手边没有安卓手机，所以只能在模拟器上进行模拟，如果手上有安卓手机地，可以适当地修改一下程序。需要安装微信和微信读书这两个软件python工具包：BeautifulSoup4、Pillow、urllib、requests、re、base64、time思路截屏含有题目和答案的图片(范围可以自己指定)使用百度的图片识别技术将图片转化为文字，并进行一系列处理，分别将题目和答案进行存储调动百度知道搜索接口，将题目作为搜索关键字进行答案搜索将搜索出来的内容使用BeautifulSoup4进行答案提取，这里可以设置答案提取数量将搜索结果进行输出显示附：这里我还加了一个自动推荐答案，利用百度短文本相似接口和选项是否出现在答案中这两种验证方法进行验证，推荐相似度最高的答案。准确度还可以，但是比较耗时间，比正常情况下时间要多上一倍。开始写代码1. 导入工具包import requests #访问网站\r\nimport re\t\t#正则表达式匹配\r\nimport base64\t#编码\r\nfrom bs4 import BeautifulSoup #处理页面数据\r\nfrom urllib import parse #进行url编码\r\nimport time #统计时间\r\nfrom PIL import ImageGrab #处理图片2. 编写类和初始化方法class autogetanswer():\r\n  def __init__(self,StartAutoRecomment=True,answernumber=5):\r\n    self.StartAutoRecomment=StartAutoRecomment\r\n    self.APIKEY=['BICrxxxxxxxxNNI','CrHGxxxxxxxx3C']\r\n    self.SECRETKEY=['BgL4jxxxxxxxxxGj9','1xo0jxxxxxx90cx']\r\n    self.accesstoken=[]\r\n    self.baiduzhidao='http://zhidao.baidu.com/search?'\r\n    self.question=''\r\n    self.answer=[]\r\n    self.answernumber=answernumber\r\n    self.searchanswer=[]\r\n    self.answerscore=[]\r\n    self.reanswerindex=0\r\n    self.imageurl='answer.jpg'\r\n    self.position=(35,155,355,680)\r\n    self.titleregular1=r'(10题|共10|12题|共12|翻倍)'\r\n    self.titleregular2=r'(\\?|\\？)'\r\n    self.answerregular1=r'(这题|问题|跳题|换题|题卡|换卡|跳卡|这有)'self.StartAutoRecomment 是否开启自动推荐答案，默认为Trueself.APIKEY 百度图像转文字、百度短文本相似度分析 这两个接口的apikeyself.SECRETKEY 百度图像转文字、百度短文本相似度分析 这两个接口的secretkey这两个key值我就没法提供给大家了，大家可以自己去百度云官方申请，免费额度大概有5万，足够我们使用了。申请过程大家可以参考这个博客，很简单的如何申请百度文字识别apikey和Secret Keyself.accesstoken 存储申请使用接口的accesstoken值self.baiduzhidao 百度知道搜索接口地址self.imageurl 图片地址self.position 截图方位信息，依次分别是左间距、上间距、右间距、下间距self.titleregular1、.titleregular2、answerregular1 这些是进行题目和答案处理的条件3. 获得accesstoken值def GetAccseetoken(self):\r\n    for i in range(len(self.APIKEY)):\r\n      host = 'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&client_id={}&client_secret={}'.format(self.APIKEY[i],self.SECRETKEY[i])\r\n      response = requests.get(host)\r\n      jsondata = response.json()\r\n      self.accesstoken.append(jsondata['access_token'])这是官方提供的获取accesstoken的摸板，大家直接使用就行了。4. 图像转文字以及相关处理def OCR(self,filename):\r\n    request_url = \"https://aip.baidubce.com/rest/2.0/ocr/v1/accurate_basic\"\r\n    # 二进制方式打开图片文件\r\n    f = open(filename, 'rb')\r\n    img = base64.b64encode(f.read())\r\n    params = {\"image\":img}\r\n    access_token = self.accesstoken[0]\r\n    request_url = request_url + \"?access_token=\" + access_token\r\n    headers = {'content-type': 'application/x-www-form-urlencoded'}\r\n    response = requests.post(request_url, data=params, headers=headers)\r\n    #===上面是使用百度图片转文字接口转化，返回格式为json\r\n    if response:\r\n      result = response.json()\r\n      questionstart=0\r\n      answerstart=0\r\n      self.question=''\r\n      self.answer=[]\r\n      #确定题目和答案所在的位置\r\n      for i in range(result['words_result_num']):\r\n        if(re.search(self.titleregular1,result['words_result'][i]['words'])!=None):\r\n          questionstart=i+1\r\n        if(re.search(self.titleregular2,result['words_result'][i]['words'])!=None):\r\n          answerstart=i+1\r\n       #下面是进行题目和答案的处理\r\n      if(answerstart!=0):\r\n        for title in result['words_result'][questionstart:answerstart]:\r\n          if(re.search(self.answerregular1,title['words'])!=None):\r\n            pass\r\n          else:\r\n            self.question+=title['words']\r\n        for answer in result['words_result'][answerstart:]:\r\n          if(re.search(self.answerregular1,answer['words'])!=None):\r\n            pass\r\n          else:\r\n            if(str(answer['words']).find('.')>0):\r\n              answer2 = str(answer['words']).split('.')[-1]\r\n            else:\r\n              answer2=answer['words']\r\n            self.answer.append(answer2)\r\n      else:\r\n        for title in result['words_result'][questionstart:]:\r\n          if(re.search(self.answerregular1,title['words'])!=None):\r\n            pass\r\n          else:\r\n            self.question+=title['words']\r\n      print(\"本题问题：\",self.question)\r\n      print(\"本题答案：\",self.answer)\r\n    return response.json()#可有可无此方法是将图片转化为文字，进行图片中的文字识别，格式如下：{\r\n  \"log_id\": 2471272194,\r\n  \"words_result_num\": 2,\r\n  \"words_result\":\r\n\t  [\r\n\t\t  {\"words\": \" TSINGTAO\"},\r\n\t\t  {\"words\": \"青島睥酒\"}\r\n\t  ]\r\n}下面我们以下面的图为例，我们是如何去除掉干扰信息的：上图就是程序在实际运行中的情况，黄色框内就是程序截取的图像(这个通过初始化方法的参数中的position可以进行设置)，我们需要的是红色框内的信息，这包含题目和答案选项。文字识别后，白色框里面的字也会和红色框里的字一同被识别，并以json形式输出，这些信息对我们就是干扰信息，所以，我通过建立了初始化方法里titleregular1、titleregular2、answerregular1 这三个标准进行判定，白色框里的文字与对应，如果判断包含的话，就不添加到题目中或者答案中。5. 百度知道进行答案搜索def BaiduAnswer(self):\r\n    request = requests.session()\r\n    headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36'}\r\n    data = {\"word\":self.question}\r\n    url=self.baiduzhidao+'lm=0&rn=10&pn=0&fr=search&ie=gbk&'+parse.urlencode(data,encoding='GB2312')\r\n    ress = request.get(url,headers=headers)\r\n    ress.encoding='gbk'\r\n    if ress:\r\n      soup = BeautifulSoup(ress.text,'lxml')\r\n      result = soup.find_all(\"dd\",class_=\"dd answer\")\r\n      if(len(result)!=0 and len(result)>self.answernumber):\r\n        length=5\r\n      else:\r\n        length=len(result)\r\n      for i in range(length):\r\n        self.searchanswer.append(result[i].text)这里是模拟浏览器进行百度知道搜索答案，将返回的文本交给BeautifulSoup进行处理，提取出我们需要的部分。后面最后几句有一个判定，如果查询到的答案数量超过我们设置的答案数，比如是5，那么就将前5个答案放入searchanswer列表中，如果查询到的答案数量要少于我们设置的，返回所有答案。6. 短文本相似度分析def CalculateSimilarity(self,text1,text2):\r\n    access_token = self.accesstoken[1]\r\n    request_url=\"https://aip.baidubce.com/rpc/2.0/nlp/v2/simnet\"\r\n    request_url = request_url + \"?access_token=\" + access_token\r\n    headers = {'Content-Type': 'application/json'}\r\n    data={\"text_1\":text1,\"text_2\":text2,\"model\":\"GRNN\"}\r\n    response = requests.post(request_url, json=data, headers=headers)\r\n    response.encoding='gbk'\r\n    if response:\r\n      try:\r\n        result = response.json()\r\n        return result['score']\r\n      except:\r\n        return 0这里调用的是百度短文本相似度分析的接口，用于分析选项与查询到的答案的相似度，以此来推荐一个参考答案。这个是官方给的摸板，直接调用，更换一下参数即可。7. 自动给出一个参考答案def AutoRecomment(self):\r\n    if(len(self.answer)==0):\r\n      return\r\n    for i in range(len(self.answer)):\r\n      scores=[]\r\n      flag=0\r\n      for j in range(len(self.searchanswer)):\r\n        if(j!=0and (j%2==0)):\r\n          time.sleep(0.1)\r\n        score = tools.CalculateSimilarity(tools.answer[i],tools.searchanswer[j])\r\n        if(tools.answer[i] in tools.searchanswer[j]):\r\n          score=1\r\n        scores.append(score)\r\n        if(score>0.8):\r\n          flag=1\r\n          self.answerscore.append(score)\r\n          break\r\n      if(flag==0):\r\n        self.answerscore.append(max(scores))\r\n    self.reanswerindex = self.answerscore.index(max(self.answerscore))这里调用了咱们第六步的CalculateSimilarity()方法，统计每一个选项与搜索到的答案相似度，取最高的存入answerscore列表中。这里我又加了一个操作，我发现这个相似度匹配有时正确率比较低，所以这里加了一个判定，若选项在搜索到的答案中出现，给予一个最大相似值，也就是1，这就大大提高了推荐的准确度。8. 初始化参数def IniParam(self):\r\n    self.accesstoken=[]\r\n    self.question=''\r\n    self.answer=[]\r\n    self.searchanswer=[]\r\n    self.answerscore=[]\r\n    self.reanswerindex=0相关参数的初始化，因为每进行完一道题，要对存储题和答案以及相关信息的数组进行清空，否则会对后面题的显示产生影响。9. 主方法def MainMethod(self):\r\n    while(True):\r\n      try:\r\n        order = input('请输入指令（1=开始，2=结束):')\r\n        if(int(order)==1):\r\n          start = time.time()\r\n          self.GetAccseetoken()\r\n          img = ImageGrab.grab(self.position)#左、上、右、下\r\n          img.save(self.imageurl)\r\n          self.OCR(self.imageurl)\r\n          self.BaiduAnswer()\r\n          if(self.StartAutoRecomment):\r\n            self.AutoRecomment()\r\n          print(\"======================答案区======================\\n\")\r\n          for i in range(len(self.searchanswer)):\r\n            print(\"{}.{}\".format(i,self.searchanswer[i]))\r\n          end = time.time()\r\n          print(self.answerscore)\r\n          if(self.StartAutoRecomment and len(self.answer)>0):\r\n            print(\"\\n推荐答案:\",self.answer[self.reanswerindex])\r\n          print(\"\\n======================答案区======================\")\r\n          print(\"总用时：\",end-start,end=\"\\n\\n\")\r\n          self.IniParam()\r\n        else:\r\n          break\r\n      except:\r\n        print(\"识别失败，请重新尝试\")\r\n        self.IniParam()\r\n        pass这里主要是一个while循环，通过输入指定来判断是否结束循环。这里说一下下面这两个语句：img = ImageGrab.grab(self.position)#左、上、右、下\r\nimg.save(self.imageurl)这两个语句是用来截取我们指定位置的图片，然后进行图片的保存。总结上述呢，就是整个项目完成的流程，整体运行是几乎每什么问题，但是还是存在许多可优化的空间。也欢迎大家对此感兴趣的留言，说说你的改进意见，我会非常感谢，并认真考虑进去。期待与大家的讨论!到此这篇关于从0到1使用python开发一个半自动答题小程序的实现的文章就介绍到这了,更多相关python 半自动答题小程序内容请搜索我们以前的文章或继续浏览下面的相关文章希望大家以后多多支持我们！"}
{"title": "python小程序实现刷票功能详解", "author": "Rolan", "time": "2020-5-13 00:31", "content": "刷票一般要突破以下限制：1、验证码识别2、同一ip不可连续投票解决办法1、用tesseract工具，链接在此 https://code.google.com/p/tesseract-ocr/ (人人还是加不了https链接)2、使用代理，国内可以的代理服务器可以从这里找到 http://cn-proxy.com/程序语言当然用python浏览器投票的流程如下1、向服务器发送请求，服务器返回验证码和表单2、填好表单，发送到服务器可以用firefox+httpfox插件查看整个事件过程，以及发送请求的POST和GET数据格式使用python的urllib2库实现上述过程1、向服务器请求验证码可以用import urllib\r\nurllib.urlretrieve(imgurl,imgfile)#imgurl可以从页面源代码找到但是由于每次请求服务器，都会重新生成验证码，所以这样请求道的验证码即便识别出来，再POST进去时也会提示错误。解决办法时使用cookieimport cookie\r\nimport urllib2\r\ncookiejar=cookielib.MozillaCookieJar(cookieFilename)\r\nopener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cookiejar))\r\nresponse=opener.open(imgurl)如果需要使用代理服务器，则可以这样写import cookie\r\nimport urllib2\r\nproxy_line='127.0.0.1:8087'\r\ncookieFilename='cookie.txt'\r\ncookiejar=cookielib.MozillaCookieJar(cookieFilename)\r\nopener=urllib2.build_opener(urllib2.ProxyHandler({'http':proxy_line}),urllib2.HTTPCookieProcessor(cookieFileJar))\r\nresponse=opener.open(imgurl,timeout=2)#设置超时时间这样就是以本机8087端口带有cookie验证访问服务器，下一步识别出验证码，依然带cookie POST进服务器即可。2、保存验证码到本地上面response即返回得到的验证码二进制流，写入文件用下面代码content=response.read()\r\nfp=file(imgfile,'wb')#将二进制图片保存\r\nfp.write(content)\r\nfp.close()3、验证码识别验证码识别用tesseract，由于tesseract没有提供python接口，这里用系统调用外部命令用法为import os\r\nimgfile='img.jpg'\r\nout用python刷票代码如下# -*- coding: utf-8 -*-\r\n\r\nimport os\r\nimport urllib\r\nimport urllib2\r\nimport string\r\nimport socks\r\nimport httplib2\r\nimport cookielib\r\nimport time\r\nimport random\r\ntes='tesseract.exe'\r\nfilepath='./'\r\nimgurl='http://example.com/vote/img.jsp'\r\nmyurl=\"http://example.com/vote\"\r\nvoteInfoId='xxxxxxxx'\r\nheaders={'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:25.0) Gecko/20100101 Firefox/25.0'}#,\r\n#     'Cookie':'324E661DE12427BD71CE63DF436A80D1'}\r\nimgfile=filepath + '/img.jpg'\r\noutfile=filepath + '/out'\r\nproxy_file=filepath+'/proxy.txt'\r\nuser_file=filepath+'/user2.txt'\r\ncookieFilename=filepath +'/cookies.txt'\r\n#myproxy_line='211.142.236.137:80'\r\n#cookieJarFileLWP=cookielib.LWPCookieJar(cookieFilename)\r\ncookieFileJar=cookielib.FileCookieJar(cookieFilename)\r\n#opener=urllib2.build_opener(urllib2.ProxyHandler({'http':myproxy_line}),urllib2.HTTPCookieProcessor(cookieMozillaJar))\r\nopener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cookieFileJar))\r\nf_user=open(user_file)\r\n\r\nf_proxy=open(proxy_file)\r\nproxy_all=f_proxy.read().split('\\n')\r\nf_user=open(user_file)\r\nuser_all=f_user.read().split('\\n')\r\ncount=1\r\ncookieFileJar=cookielib.FileCookieJar(cookieFilename)#使用cookie登陆\r\n\r\nwhile True:\r\n  i=random.randint(1,100)\r\n  j=random.randint(1,60)\r\n  #print user_all.length()\r\n  user_line=user_all[i]\r\n  myproxy_line=proxy_all[j]\r\n\r\n  for myproxy_line in [myproxy_line]:#f_proxy:\r\n\r\n    #使用代理和cookie\r\n    opener=urllib2.build_opener(urllib2.ProxyHandler({'http':myproxy_line}),urllib2.HTTPCookieProcessor(cookieFileJar))\r\n    try:\r\n      response2=opener.open(imgurl,timeout=1)#返回二进制图片\r\n    except Exception,e:\r\n      print 'I can not connect the server,try again'\r\n      continue\r\n\r\n    content=response2.read()\r\n    fp=file(imgfile,'wb')#将二进制图片保存\r\n    fp.write(content)\r\n    fp.close()\r\n    outcmd=\"%s %s %s -l eng digits -psm 7\" %(tes,imgfile,outfile)\r\n    print 'I begin to recognize the CAPTCHA code ..'\r\n    os.system(outcmd)\r\n    code_file=open(filepath+'/out.txt')\r\n    mycode_line=code_file.readline()\r\n    code_file.close()\r\n\r\n    if len(mycode_line)<=3:\r\n      print 'I guess the CAPTCHA code is %s,but I think it\\'s error.' % (mycode_line)\r\n      continue\r\n    mycode=mycode_line[0:4]\r\n    print 'I guess the CAPTCHA code is %s' % (mycode)\r\n    mylist=user_line.split('----')\r\n    proxy_list=myproxy_line.split(':')\r\n    myid=mylist[0]#.decode('utf-8')\r\n    myname=mylist[1]#.decode('utf-8')\r\n    mycomm=mylist[2]#.decode('utf-8')\r\n    data={'method':'vote',\r\n       'voteInfoId':voteInfoId,\r\n       'forward':'***',\r\n       'info1':myid,\r\n       'info2':myname,\r\n       'info3':mycomm,\r\n       'inputCode':mycode,\r\n       'submit':'确定'}\r\n    print 'Now I begin to vote...'\r\n    print 'the user is %s' % (myid)\r\n    print 'the name is %s' % (myname)\r\n    print 'the comment is %s' % (mycomm)\r\n    post_data=urllib.urlencode(data)\r\n    try:\r\n      response=opener.open(myurl,post_data)\r\n    except Exception,e:\r\n      print 'I can\\'t connect the server ,so vote is failure'\r\n      continue\r\n    content=response.read()\r\n  #img_req=opener.open(imgurl)\r\n  #cookieFileJar.save(cookieFilename)\r\n  #req=opener.open(myurl,post_data)\r\n  #req=urllib2.Request(myurl,data=post_data,headers=headers)\r\n    fp=file('test.html','w')\r\n    print 'I put the received html to the file test.html'\r\n    fp.write(content)\r\n    fp.close()\r\n    #outcmd=\"%s %s %s\" %(tes,imgfile,outfile)\r\n  #count+=1\r\n    #print cookieFileJar以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持我们。"}
{"title": "微信小程序分页", "author": "Rolan", "time": "2020-5-13 00:45", "content": "本文主要介绍微信小程序如何分页获取数据。Git项目地址扫码体验Demo小程序一、表数据suject题目表{\"_id\":\"0ayVvucaRNEceEzD4dMn1tUS1pZG3VcrqXdpXfrtmk9YHyDD\",\"question\":\"正方形是有角的图形，这个图形没有角。所以，这个图形是个圆。\",\"option\":[{\"key\":\"A\",\"value\":\"Yes\"},{\"key\":\"B\",\"value\":\"No\"}],\"answer\":\"B\",\"analysis\":\"没有角的图形有很多\",\"status\":\"1\",\"position\":70,\"create_at\":\"2020-05-11 15:46:36\",\"update_at\":\"2020-05-11 15:46:36\"}\r\n{\"_id\":\"0e5d9911-34cd-4e83-b056-ba0d6c634878\",\"answer\":\"C\",\"analysis\":\"两个孩子可能情况为（男，男）（男，女）（女，男）（女，女），又已知其中一个是女的，故排除（男，男），剩下三种情况两个是符合的，故2/3\",\"status\":\"1\",\"create_at\":\"2020-03-27 15:46:36\",\"update_at\":\"2020-03-27 15:46:36\",\"question\":\"有一对夫妇，先后生了两个孩子，其中一个孩子是女孩，另一个孩子是男孩的概率是多少?\",\"option\":[{\"key\":\"A\",\"value\":\"1/2\"},{\"key\":\"B\",\"value\":\"1/3\"},{\"key\":\"C\",\"value\":\"2/3\"},{\"key\":\"D\",\"value\":\"3/4\"}],\"position\":5.0}\r\n{\"_id\":\"1AylrC3OIgv2nrQEe2v6qBRqPZxZKR5LkOuggoqbkJnfwmP6\",\"question\":\"韦利是个和斯坦一样强的棒球击球手，斯坦是个比大多数人都要强的棒球击球手。所以，斯坦应是这些选手中最出色的。\",\"option\":[{\"key\":\"A\",\"value\":\"Yes\"},{\"key\":\"B\",\"value\":\"No\"}],\"answer\":\"B\",\"analysis\":\"斯坦只比大多数人强，中等偏上\",\"status\":\"1\",\"position\":65,\"create_at\":\"2020-05-11 15:46:36\",\"update_at\":\"2020-05-11 15:46:36\"}\r\n{\"_id\":\"1fWuVJVFUKOUmjfdRaqnAiLPr15XlNtZwKtru3ctduX48fcn\",\"question\":\"绿色深时，红色就浅；黄色浅时，蓝色就适中；但是要么绿色深，要么黄色浅。所以，红色浅，或者蓝色适中。\",\"option\":[{\"key\":\"A\",\"value\":\"Yes\"},{\"key\":\"B\",\"value\":\"No\"}],\"answer\":\"A\",\"analysis\":\"无\",\"status\":\"1\",\"position\":78,\"create_at\":\"2020-05-11 15:46:36\",\"update_at\":\"2020-05-11 15:46:36\"}\r\n{\"_id\":\"29ca2b1c-ebab-4b7d-bd96-8b0b668089c2\",\"status\":\"1\",\"create_at\":\"2020-03-27 15:46:36\",\"update_at\":\"2020-03-27 15:46:36\",\"analysis\":\"排列组合，C(45,2)\",\"question\":\"一次朋友聚会，大家见面时总共握手45次。如果参加聚会的人和其余的每个人只握手一次，问参加聚会的共有多少人？\",\"option\":[{\"key\":\"A\",\"value\":\"22\"},{\"key\":\"B\",\"value\":\"11\"},{\"key\":\"C\",\"value\":\"12\"},{\"key\":\"D\",\"value\":\"10\"}],\"answer\":\"D\",\"position\":3.0}\r\n{\"_id\":\"2G1Yeqpw97xK7iIsq89qBZmlgq2GFOdBNg8sopjHS63UrDTT\",\"question\":\"前进不见得死得光荣,后退没死也不见得是耻辱。所以,后退意为死得光荣。\",\"option\":[{\"key\":\"A\",\"value\":\"Yes\"},{\"key\":\"B\",\"value\":\"No\"}],\"answer\":\"B\",\"analysis\":\"可能是耻辱\",\"status\":\"1\",\"position\":99,\"create_at\":\"2020-05-11 15:46:36\",\"update_at\":\"2020-05-11 15:46:36\"}\r\n{\"_id\":\"2NqPCHgKe4Gej83LAK6tDq44OCGrQhgzFSGrU4ItYJqi1zlB\",\"question\":\"一个在运动中骨折的患者（女性）康复出院了，家里庆祝并大摆宴席。喝饮料的时候，患者的哥哥说今天的可乐怎么味道有点怪，然后患者的父亲和母亲也喝了纷纷表示可乐味道的确不对。但患者喝后坚称味道正常。患者死于当天晚上洗澡的澡盆里。为什么？\",\"option\":[{\"key\":\"A\",\"value\":\"已知，下一题\"},{\"key\":\"B\",\"value\":\"查看解析\"}],\"answer\":\"A\",\"analysis\":\"患者在受伤过程中，把感觉神经也给弄坏了，感觉不到味道和疼痛，在泡澡过程中，水太热，被烫死了\",\"status\":\"1\",\"position\":56,\"create_at\":\"2020-05-07 15:46:36\",\"update_at\":\"2020-05-07 15:46:36\"}\r\n{\"_id\":\"2c8JA7ky2BNmiSlpIQRcktzvZ53KHe2h8zlbPkt5T3puoXvV\",\"question\":\"从前有一个女人，他的老公非常喜欢搞外遇，这个女人实在忍受不了这种状况，就决定吃药自杀，自杀前他留了一封遗书给她的初恋情人。初恋情人看到遗书后，十万火急地赶到女人家里，还好女人没有死，女人看到初恋情人来了表现得很激动，二人缠绵不已。初恋情人对女人说他一定帮忙教训她的老公。第二天，警察登门，告诉女人说她老公已经死了，在和情妇幽会的时候死了。请问这是怎么一回事？\",\"option\":[{\"key\":\"A\",\"value\":\"已知，下一题\"},{\"key\":\"B\",\"value\":\"查看解析\"}],\"answer\":\"A\",\"analysis\":\"女人将毒药藏在普通瓶子里以掩饰毒药，然后把药服了。她等待着死亡的到来，可是她的身体没有出现丝毫痛苦的征兆，相反，却有一种微妙的藏东在上升。这时她的初恋男友来了，女人见了男友表现的十分热情，主动和他唱秒。而在另一个角落，女人的老公和情妇也要将上演另一幕激情戏的时候，男人拿出了事先准备好的秘密武器---平日藏在柜子里装在普通瓶子里以掩饰的春药，这一次，他像往常一样吞了一粒，可是没过多久，他突然全身痉挛，表情极为痛苦，过了一会就死了。\",\"status\":\"1\",\"position\":46,\"create_at\":\"2020-05-07 15:46:36\",\"update_at\":\"2020-05-07 15:46:36\"}\r\n{\"_id\":\"2f826e24-397c-43d6-8193-1014ce858759\",\"status\":\"1\",\"create_at\":\"2020-03-27 15:46:36\",\"update_at\":\"2020-03-27 15:46:36\",\"question\":\"36匹马赛跑，跑道同时只能容许6匹马。而且36匹马速度不同，但是每次跑的速度恒定。问不计时跑多少次可以选出第一，第二，第三名？\",\"option\":[{\"key\":\"A\",\"value\":\"7\"},{\"key\":\"B\",\"value\":\"8\"},{\"key\":\"C\",\"value\":\"9\"},{\"key\":\"D\",\"value\":\"6\"}],\"answer\":\"B\",\"analysis\":\"36匹马，分6组，赛6次，留下每组前3名；6个小组的第一名赛一次，选出前三，这3组可以去争夺前3名，从第一组选出3名，从第二名组选出前2名，从第三名组选第一名赛一次，前三就是第一名、第二名、第三名\",\"position\":12.0}\r\n{\"_id\":\"33242856-03df-49ad-b409-75e20455fbea\",\"status\":\"1\",\"create_at\":\"2020-03-27 15:46:36\",\"update_at\":\"2020-03-27 15:46:36\",\"question\":\"在一个平面上有三个不在一条直线上的点。请问在这个平面能够作出几条与这些点距离相同的线？\",\"option\":[{\"key\":\"A\",\"value\":\"1\"},{\"key\":\"B\",\"value\":\"0\"},{\"key\":\"C\",\"value\":\"2\"},{\"value\":\"3\",\"key\":\"D\"}],\"answer\":\"D\",\"analysis\":\"三角形的三条中垂线的交点到三个点的距离相等\",\"position\":4.0}\r\n{\"_id\":\"33d27b4d-d22d-4def-ac32-49e7a0a1fcdf\",\"update_at\":\"2020-03-27 15:46:36\",\"question\":\"1元钱一瓶汽水，喝完后两个空瓶换1瓶汽水，你有20元钱，最多可以喝到几瓶水？(可以借)\",\"option\":[{\"key\":\"A\",\"value\":\"40\"},{\"key\":\"B\",\"value\":\"38\"},{\"key\":\"C\",\"value\":\"39\"},{\"key\":\"D\",\"value\":\"37\"}],\"answer\":\"A\",\"analysis\":\"先买20瓶，再借20个空瓶去换20瓶，再还20个空瓶，所以可以喝40瓶水\",\"status\":\"1\",\"create_at\":\"2020-03-27 15:46:36\",\"position\":10.0}\r\n{\"_id\":\"3FSAYgEna4l1uyLaZvk7tU9s97hH8ikBiAZyH0EnrPHHaFsI\",\"question\":\"水平高的音乐家演奏古典音乐，要成为水平高的音乐家就得练习演奏。所以演奏古典音乐比演奏爵士乐需要更多的练习时间。\",\"option\":[{\"key\":\"A\",\"value\":\"Yes\"},{\"key\":\"B\",\"value\":\"No\"}],\"answer\":\"B\",\"analysis\":\"看天赋\",\"status\":\"1\",\"position\":67,\"create_at\":\"2020-05-11 15:46:36\",\"update_at\":\"2020-05-11 15:46:36\"}\r\n{\"_id\":\"3HeRjxEADVVhVxoAHWKuyFq4y51rWQelhMXtI3UHoDoPCDW9\",\"question\":\"我住在农场和城市之间，农场位于城市和机场之间。所以，我的住处到农场比到机场要近。\",\"option\":[{\"key\":\"A\",\"value\":\"Yes\"},{\"key\":\"B\",\"value\":\"No\"}],\"answer\":\"A\",\"analysis\":\"无\",\"status\":\"1\",\"position\":84,\"create_at\":\"2020-05-11 15:46:36\",\"update_at\":\"2020-05-11 15:46:36\"}\r\n{\"_id\":\"5MWFCg2NYcxbXA06AeTN3Inv6AHh9zwoDfgFUBYi8QK2NYAF\",\"question\":\"当B等于Y时,A等于Z;当A不等于Z时,E要么等于Y,要么等于Z。所以, 当B不等于Y时,E不等于Y也不等于Z。\",\"option\":[{\"key\":\"A\",\"value\":\"Yes\"},{\"key\":\"B\",\"value\":\"No\"}],\"answer\":\"B\",\"analysis\":\"当B不等于Y时，A不等于Z，E要么等于Y,要么等于Z\",\"status\":\"1\",\"position\":90,\"create_at\":\"2020-05-11 15:46:36\",\"update_at\":\"2020-05-11 15:46:36\"}\r\n二、首页分页1. 在index.json文件里设置页面上拉触底事件触发时距页面底部距离为50px\r\n2. 创建list云函数，获取分页数据。请求参数为startId(从哪条记录开始，默认为0)，每页数据为15条，只获取所需要的列(_id,question,position)，减轻流量。```备注：创建新的云函数后一定要执行 npm install --save wx-server-sdk@latest```\r\n// 云函数入口文件\r\ncloud = require('wx-server-sdk')\r\ncloud.init()\r\n\r\nconst db = cloud.database()\r\nconst _ = db.command\r\nconst $ = db.command.aggregate\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n    var startId = parseInt(event.startId)\r\n    \r\n    const subject = await getListByStartId(startId)\r\n    return {subject:subject.result.list}\r\n}\r\n\r\nfunction getListByStartId(startId, size=15, field={ question: 1, position: 1 }) {\r\n  if (startId > 0) {\r\n    return db.collection('subject').aggregate()\r\n      .match({\r\n        position: _.lt(startId)\r\n      })\r\n      .sort({ position: -1 })\r\n      .limit(size)\r\n      .project(field).end()\r\n  }\r\n\r\n  return db.collection('subject').aggregate()\r\n    .sort({ position: -1 })\r\n    .limit(size)\r\n    .project(field).end()\r\n}3. 设置页面初始数据，questionList-题目列表，lastId-题目最后一个Id，noMore-全部加载\r\nPage({\r\n  data: {\r\n    questionList: null,\r\n    lastId: 0,\r\n    noMore: false\r\n  }\r\n )}4. 获取列表数据。当列表数据为空时，设置noMore为true; 当列表不空时，lastId为list[list.length - 1].position(position为排序的值), 将获取到的list数据concat进questionList。Page({\r\n  data: {\r\n    questionList: null,\r\n    lastId: 0,\r\n    noMore: false\r\n  },\r\n  onShow: function () {\r\n    this.setData({ \r\n      questionList: null,\r\n      lastId: 0,\r\n      noMore: false\r\n     });\r\n    this.getList()\r\n  },\r\n  getList: function () {\r\n    wx.cloud.callFunction({\r\n      name: 'list',\r\n      data: {\r\n        startId: this.data.lastId\r\n      },\r\n    })\r\n      .then(res => {\r\n        if (res.result == null || res.result.subject.length <= 0) {\r\n          this.setData({ noMore: true })\r\n          return;\r\n        }\r\n\r\n        let list = res.result.subject\r\n        this.setData({lastId: list[list.length - 1].position}) \r\n        if (this.data.questionList !== null) {\r\n          this.setData({\r\n            questionList: this.data.questionList.concat(list)\r\n          })\r\n        } else {\r\n          this.setData({ questionList: list });\r\n        }\r\n      })\r\n      .catch(res => {\r\n        wx.showToast({\r\n          title: '系统异常，请稍后重试',\r\n          icon: 'none',\r\n          duration: 2000\r\n        })\r\n      })\r\n  }\r\n})5. 设置触底事件，当noMore为true时，不再请求数据\r\n\r\nPage({\r\n  data: {\r\n    questionList: null,\r\n    lastId: 0,\r\n    noMore: false\r\n  },\r\n  onShow: function () {\r\n    this.setData({ \r\n      questionList: null,\r\n      lastId: 0,\r\n      noMore: false\r\n     });\r\n    this.getList()\r\n  },\r\n  onReachBottom: function (e) {\r\n    if (this.data.noMore) {\r\n      return;\r\n    }\r\n    this.getList()\r\n  },\r\n  getList: function () {\r\n    wx.cloud.callFunction({\r\n      name: 'list',\r\n      data: {\r\n        startId: this.data.lastId\r\n      },\r\n    })\r\n      .then(res => {\r\n        if (res.result == null || res.result.subject.length <= 0) {\r\n          this.setData({ noMore: true })\r\n          return;\r\n        }\r\n\r\n        let list = res.result.subject\r\n        this.setData({lastId: list[list.length - 1].position}) \r\n        if (this.data.questionList !== null) {\r\n          this.setData({\r\n            questionList: this.data.questionList.concat(list)\r\n          })\r\n        } else {\r\n          this.setData({ questionList: list });\r\n        }\r\n      })\r\n      .catch(res => {\r\n        wx.showToast({\r\n          title: '系统异常，请稍后重试',\r\n          icon: 'none',\r\n          duration: 2000\r\n        })\r\n      })\r\n  }\r\n})6. 页面wxml展示\r\nindex.wxml<view class=\"title\">题目</view>\r\n<view class = \"list-body\">\r\n  <block wx:for=\"{{questionList}}\" wx:key=\"_id\">\r\n    <navigator class=\"navigator-block\"  url=\"../question/detail?id={{item._id}}&type=all\">\r\n     <view class=\"question-redirect\">{{item.question}}</view>\r\n    </navigator>\r\n  </block>\r\n</view>\r\n<view class=\"no-more\">\r\n      <view wx:if=\"{{noMore}}\">我们是有底线的呦～</view>\r\n</view>index.wxss\r\n page {\r\n    background-color: #f8f8f8;\r\n  }\r\n.list-body {\r\n   background-color: #fff;\r\n   margin-top: 15px; \r\n}\r\n.navigator-block {\r\n  border-bottom: 1px solid rgb(231, 227, 227);\r\n  display: flex;\r\n  flex-direction: row;\r\n  height:40px;\r\n  margin-left:5px;\r\n}\r\n.question-redirect {\r\n  font-size:13px;\r\n  color: #666;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  white-space:nowrap;\r\n  width: 90%;    \r\n  margin-left:10px;\r\n  line-height: 40px;\r\n}\r\n.list-detail{\r\n   transform: rotate(45deg);\r\n   border-right:  1px solid  #BDBDBD;\r\n   border-top: 1px solid  #BDBDBD;\r\n   width:8px;\r\n   height:8px;\r\n   float:right;\r\n   margin-top:15px;\r\n}\r\n.no-more{\r\n    color: #999;\r\n    text-align: center;\r\n    margin-top: .1rem;\r\n    font-size: .1rem;\r\n}\r\n.title{\r\n    margin-top: 20px;\r\n    font-size: 15px;\r\n    color: #333;\r\n    line-height: .22rem;\r\n    padding: .1rem .15rem;\r\n    font-weight: 700;\r\n}"}
{"title": "不可错过的流量风口：小程序 & 快应用", "author": "Rolan", "time": "2020-5-14 00:05", "content": "小程序、快应用、APP之间的多边竞争，谁会是未来流量的主战场？在智能手机诞生前，你应该想象不到APP居然成为移动互联网流量的聚集地，商家将电商产品、新闻资讯、视频影音、娱乐游戏、O2O服务等内容都从PC端转移到手机屏幕上的一个小小的“图标”里。PC的用户流量大都集中在搜索引擎和导航栏，APP的流量生态不一样，APP之间都是相互隔绝的，用户被切割成一个个“流量池”。在To C线上消费市场上，APP所形成的商业价值已经远远超越了PC的价值。据极光发布《2019 年 Q2 移动互联网行业数据研究报告》显示，截止 6 月份中国网民规模增长至 11.34 亿，人均手机APP 的数量为 56 个。一个6寸左右的手机屏幕被各类APP塞得满满当当，这么多应用对手机是一个很大的负担，所以手机内存在不断的扩容。对于用户来说，越来越多的APP，不单单是选择和使用上的负担，更多的是用户绝大部分时间里压根都不会想起这些应用，用户每天常用的APP其实也就5-10款，其他大部分APP都静静的躺在手机里“酣睡”。但是，做过APP开发和推广的产品经理和运营人都知道，一款APP从上市到付费推广吸引用户下载，再到用户留存，花费了巨大的人力和财力成本。最后，这个APP能不能生存下来很难说，但巨大的投入是不可逆了。所以，对于中小型创业公司来说，通过APP做产品和商业化变现的门槛越来越高，产品冷启动阶段投入越大，创业的风险越来越大。流量只会像头部应用越来越集中，大手笔的创业公司在新上市的APP上可能还有些机会，但这不是中小创业公司的最佳选择。而小程序和快应用的出现，或许能改变这个流量困境。每一次应用形态的变革，都会产生流量红利。尤其是对于创业公司来说，这波流量红利必须要牢牢把握。一、打破壁垒的场景流量生态——小程序1. 小程序的流量生态优势小程序是在2017年年初被腾讯提出来的，在上线初期，小程序产品的生态单一，用户量不多，当时不被市场看好，市场对于任何新事物一开始都是质疑和拒绝的。但经过短短3年时间的发展，大厂都开始布局小程序。微信的小程序以社交娱乐和零售服务为主，阿里巴巴的小程序以生活服务、商业服务为主，头条系的小程序以消费和内容为主。据阿拉丁数据统计，2019年小程序的DAU达到3.3亿，累计GMV达到1万亿。预计到2020年年底，小程序的用户量会达到4.5亿人，小程序将打造出一个新的流量生态。随着小程序这两年的崛起，给很多创业公司带去了机会，比如短视频内容的小年糕、做社区团购的十荟团，都是借助微信小程序的流量生态成长起来的。张小龙曾在一次微信公开课中提到，“激活线下流量是小程序真正的核心”。可见，线下将是微信小程序进击的第一个流量市场。有一个很好的例子就是摩拜，摩拜在2017年2月就上线了微信小程序，这个时期还是微信小程序上线的初期阶段，摩拜微信在小程序上的月活用户数仅有8万人。之后，随着微信小程序“跳一跳”小游戏地推出，一下子聚拢了3亿多个玩家，给小程序生态快速地积累了用户量。摩拜属于第一批参与者也是第一批受益者，仅两个月时间，小程序就为摩拜带来了50%的拉新占比，注册用户增长了30倍。小程序能够在短短的3年里快速发展，有三大生态优势：产品制作成本低、推广和获客更简单、“无域流量”。产品制作成本低：与APP开发周期长和推广成本高相比，小程序的开发周期远比原生应用开发短得多，开发成本也相对较低。推广和获客更简单：对于用户来说，小程序的使用门槛很低，无须下载和注册，即开即用，在满足用户即时性需求的同时，不会给用户带来其他的信息干扰。对于推广者来说，以小程序产品作为推广产品，新用户的转化路径更短，用户的接受度更高。与下载一个APP相比，用户扫码打开小程序的操作成本更低，拉新效率更高。“无域流量”：于私域流量和公域流量相比，小程序是不受平台和用户圈层限制的，很明显的一个趋势是：不论是入口还是推广的渠道，小程序都正朝着无边界化的方向发展，我将这个方向称为“无域流量”。小程序即开即用和即用即走的生态特点决定了这个生态里的流量不再会形成“流量孤岛”。以支付宝为例，其小程序已经打通了高德地图、UC浏览器、神马搜索等阿里系的应用。用户可以通过高德App、UC浏览器内置，以及其他浏览器渠道的神马搜索，打开和使用支付宝小程序。2. 如何快速获取小程序流量？小程序的流量主要来自两个地方：一个是生态内流量，另一个是线下流量。以微信小程序为例，生态流量是指微信内以聊天为主的社交流量和以公众号为主的内容流量；线下流量则主要是指商家的线下渠道流量。目前，微信小程序还没有与外部的其他APP进行数据打通，很难实现跨平台引流。（1）微信小程序生态内流量流量入口一：公众号通过公众号绑定小程序、底部菜单设置小程序入口、文章插入小程序卡片等方式可以达到锁住用户的目的。流量入口二：社群微信小程序支持分享给微信好友和微信群，社群的流量就等于这个渠道的流量。电商类小程序通过社群做流量转化的策略已经十分成熟，拼多多和苏宁拼购在小程序社群营销上下了不少功夫。（2）线下流量流量转化形式一：搜索搜索是外部新用户进入小程序的重要形式之一，如同公众号一样，在外部渠道，我们可以通过引导语“搜索XX小程序领券”来实现用户转化。在设置小程序名称和描述时，我们可以参考SEO优化的相关策略，让用户能够通过搜索关键词快速找到目标小程序。流量转化形式二：小程序码在线下地推活动中，我们可以引导用户主动扫描小程序的二维码领取优惠券，将用户快速沉淀在小程序账号中，以实现后面的深度转化。线下商家可以通过小程序实现线下用户转线上会员，以便后期让用户二次到店及复购。流量转化形式三：附近的小程序有线下门店的小程序商家一定要设置好小程序的地理位置，微信会基于LBS在“发现”的小程序入口智能地推荐附近的小程序，对于偏重线下获客的商家来说，这无疑是一个价值较高的流量入口。二、手机厂商的流量江湖——快应用1. 什么是快应用？快应用是基于手机硬件平台的新型应用生态。2018年3月20日，由小米、中兴、华为、金立、联想、魅族、努比亚、OPPO、vivo九大手机厂商共同主办快应用标准启动发布会，这标志着一个新的应用生态正式成立。有很多运营者对快应用还比较陌生，因为到目前阶段，真正参与快应用产品建设的基本上都是头部互联网公司，比如滴滴、网易新闻、菜鸟等。在与手机厂商共建快应用生态的早期阶段，我们确实能够享受不少流量红利。快应用具备 HTML 5 页面和APP的双重优点，用户无须下载安装，即点即用，同时也能拥有APP应用的完美性能体验。目前的快应用是基于场景而生的，在功能上和手机APP有着高度的同质化，但快应用拥有更加多样的场景入口，如智慧短信、负一屏、快捷搜索框，这给应用带来了更多的场景流量。快应用还有一个特殊的优势是流量分发更智能。以打车为例，当用户需要使用打车服务时，一般都是通过APP或者微信、支付宝的打车入口下单服务。而快应用对打车业务的改造更加智能，通过大数据分析，模拟出用户千人千面的打车需求（如打车时间、偏好），再通过手机系统消息或者智慧短信推送打车服务（比如航班到达降落机场，即时性地给用户提供打车入口），这样使得流量分发更加精准和智能。快应用目前处于初期阶段，产品功能尚不成熟，还没有形成一个高效的流量生态闭环，很多公司还没有参与快应用产品的制作。期待手机厂商、应用企业和渠道商的共同参与，在不久的将来快应用可以迎来颠覆式的场景流量时代。2. 快应用的流量获取优势快应用作为一个新应用生态的代表，目前主要对标的是手机APP和小程序。快应用的出现在一定程度上干扰了App的基础变现渠道和生态，APP在手机上是一个个流量孤岛，移动流量逐渐向头部APP集中的趋势越发明显，对于新APP来说获取和占领用户高地的机会越来越少。快应用的出现，对于流量运营者来说是一个新的机会。与原生APP相比，快应用的流量获取优势主要有以下三个方面。优势一：产品形态快应用是基于手机系统层面开发的应用，占用内存小，有统一的接口开发标准。快应用不像一个APP一样静静地位于在手机桌面上的某个位置，而是多形态的存在，可以在桌面形成图标，可以在负一屏以任务栏的形式存在，也可以是系统推送过来的即时消息。这样的产品形态将流量入口、使用场景以及用户需求进行了较好的融合。优势二：用户体验当你的手机上安装了几十个APP时，总会在某个时刻因为找不到某个应用而花费不少时间，这种苦恼我相信很多人都体验过。快应用的一个优点是，可以通过搜索框或者手机智能语音直接找到并吊起某个应用，无须安装直接使用。从目前来看，快应用在用户体验上的另一个优点是启动快。与普通安卓手机APP启动等待3-5秒时间相比，快应用的启动基本上没有等待时差，且即用即走，在用户需求满足上更加及时。不过，从目前来看，用户有一个不好的体验是，很多快应用产品上架的都是“简化版”，与原来的APP相比，产品功能精简了很多，用户的部分需求得不到满足。优势三：流量生态快应用在流量生态上的一个显著特点是去中心化。不论是智能手机，还是智能音响和智能电视，现在的一个大的时代背景是人工智能技术的加入，让原本固定化的软件内容去中心化了，不再是固定的软件和栏目，更多的是对场景的智能学习，对用户需求的个性化满足。就像你家的智能音箱和我家的智能音箱在使用一段时间后，推荐的音频内容会不一样。从目前快应用的发展趋势来看，以后手机上只有一个流量中心，那就是手机系统。同时，快应用会让某一个应用拥有多个流量入口，这对流量运营玩法将是颠覆性的，值得我们一起期待。从目前的快应用发展状况来看，想要快速占领这块新的流量高地，我们需要和手机厂商保持密切沟通，在手机系统里探索出更多的场景流量。2. 如何实现快应用流量布局？快应用是和手机厂商直接合作的，就像APP应用市场一样，手机厂商对商家的快应用拥有生杀大权。要点一：清晰的产品功能定位因为快应用还处于形态初期，手机厂商重点扶持的应用需要为平台带来大量的用户量，所以想要获得厂商的流量扶持。重点向满足用户吃穿住行娱乐类的基础应用进行布局，垂直类人群的应用最好先不要碰，满足普通手机用户的刚性的产品功能需求，目标用户基数要大，产品功能性要强。要点二：注重用户体验感快应用作为APP的替代品，本身具有很强的优势，所以在产品设计上要下足功夫，比如完整的产品逻辑、友好的交互、轻便快捷使用感受等。产品设计的质量度直接决定了是否能够被手机厂商推广的用户所接受，这也是获取流量扶持前必须打下的基础。要点三：密切关注手机厂商的流量扶持活动华为、OPPO、小米、vivo、金立、魅族、中兴、努比亚、联想手机厂商作为快应用的联盟成员，定期会发起跨平台的流量扶持活动，这对于快应用商家来说，是一个增加应用曝光的绝好机会。比如，在2018年6月，快应用举办了第一期流量扶持活动。第一期流量扶持活动由七家厂商参与，通过千万级的Push和闪屏资源推广，实现了超6亿的曝光量，被扶持的三家快应用商家，每家快应用的UV上涨均达到150%以上。在手机厂商、头部流量平台以及商家多方共建的情况下，移动互联网肯定会迎来新的一波流量增长，这个增长方向可能不再是做APP分发的应用市场，而是在手机厂商和头部互联网平台的产品生态中。不论是小程序，还是快应用，对于互联网企业来说，需要尽早布局，这是不可错过的流量增长“风口”。作者：一文（Lory），聚焦流量运营及用户增长相关的知识分享；微信公众号：如是一文。本文由 @lory 原创发布于人人都是产品经理。未经许可，禁止转载。题图来自Unsplash，基于CC0协议"}
{"title": "要做小程序的订阅推送 本篇 从小程序到后端!!!", "author": "Rolan", "time": "2020-4-30 00:03", "content": "小程序模板消息即将被废弃掉，于是有了新接口wx.requestSubscribeMessage ----订阅消息推送本篇将带你感受一下订阅推送的坑坑洼洼前期准备工作申请订阅消息模板 id appid 等自行准备 这准备不好的话 别干了兄弟转行吧 我不让白嫖!!!!!话不多说直接上代码!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!小程序端app.js//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    // 展示本地存储能力\r\n    var logs = wx.getStorageSync('logs') || []\r\n    logs.unshift(Date.now())\r\n    wx.setStorageSync('logs', logs)\r\n   \r\n    var that = this\r\n    var user = wx.getStorageSync('user') || {};\r\n    var userInfo = wx.getStorageSync('userInfo') || {};\r\n  \r\n    // 登录\r\n    wx.login({\r\n      success: res => {\r\n        // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n        //获取openid___________________________________________开始\r\n        that.globalData.code = res.code\r\n            if (res.code) {\r\n             \r\n              wx.getUserInfo({\r\n                success: function (res) {\r\n                \r\n                  var objz = {};\r\n                  objz.avatarUrl = res.userInfo.avatarUrl;\r\n                  objz.nickName = res.userInfo.nickName;\r\n\r\n                  wx.setStorageSync('userInfo', objz);//存储userInfo\r\n                \r\n                },\r\n                fail: function (e) {\r\n                \r\n                }\r\n              });\r\n\r\n              var d = that.globalData;//这里存储了appid、secret、token串  \r\n             \r\n              var l = 'https://api.weixin.qq.com/sns/jscode2session?appid=' + d.appid + '&secret=' + d.secret + '&js_code=' + res.code + '&grant_type=authorization_code';\r\n              wx.request({\r\n                url: l,\r\n                data: {},\r\n                method: 'GET', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT  \r\n                // header: {}, // 设置请求的 header  \r\n                success: function (res) {\r\n               \r\n                  var obj = {};\r\n                  obj.openid = res.data.openid;\r\n                  obj.expires_in = Date.now() + res.data.expires_in;\r\n                  console.log(obj.openid);\r\n                  wx.setStorageSync('userop', obj);//存储openid  \r\n                }\r\n              });\r\n            } else {\r\n              console.log('获取用户登录态失败！' + res.errMsg)\r\n            }\r\n            //获取openid___________________________________________结束\r\n      }\r\n    })\r\n    // 获取用户信息\r\n    wx.getSetting({\r\n      success: res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n          wx.getUserInfo({\r\n            success: res => {\r\n              // 可以将 res 发送给后台解码出 unionId\r\n              this.globalData.userInfo = res.userInfo\r\n\r\n              // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回\r\n              // 所以此处加入 callback 以防止这种情况\r\n              if (this.userInfoReadyCallback) {\r\n                this.userInfoReadyCallback(res)\r\n              }\r\n            }\r\n          })\r\n        }\r\n      }\r\n    })\r\n  },\r\n  globalData: {\r\n       url:\"http://192.168.0.199:8888/app\",\r\n       appid: '微信appid',//微信appid\r\n       secret: '秘钥',//秘钥\r\n       userInfo: null\r\n  }\r\n})index.js//登录\r\n  login:function(){\r\n    if(!this.data.userName){\r\n      wx.showToast({\r\n        title: '用户名不能为空',\r\n        icon:'none'\r\n      })\r\n      return;\r\n    }\r\n    if (!this.data.pwd) {\r\n      wx.showToast({\r\n        title: '密码不能为空',\r\n        icon: 'none'\r\n      })\r\n      return;\r\n    }\r\n    wx.showLoading({});\r\n    wx.setStorageSync(\"cid\",this.guid());\r\n    wx.request({\r\n      url: app.globalData.url + '/Login/appLogin',\r\n      data:{\r\n        username: this.data.userName,\r\n        password: this.data.pwd,\r\n        clientId: wx.getStorageSync(\"cid\"),\r\n        openid: wx.getStorageSync('userop').openid\r\n      },\r\n      header: {\r\n        'content-type': 'application/x-www-form-urlencoded',\r\n        'X-Requested-With':'XMLHttpRequest'\r\n      },\r\n      method:\"POST\",\r\n      success:function(res){\r\n        if(res.data.status == 200){\r\n          wx.setStorageSync(\"user\", res.data.user);\r\n          wx.removeStorageSync('sessionid');\r\n          wx.setStorageSync(\"sessionid\", res.cookies[1]);\r\n          wx.switchTab({\r\n            url: '/pages/main/main'\r\n          });\r\n          return;\r\n        }else{\r\n          wx.showToast({\r\n            title: '用户名或密码错误',\r\n            icon: 'none'\r\n          })\r\n        }\r\n      }\r\n    });获取到openid之后直接就从你的登录方法往后端传就行 后端接收后存到相应的表里 下次登录给挂个标识 表里对应的useid有就不存了 没有就存 如果有redis可以做缓存 避免给数据库造成太大的压力当然这只是小程序获取openi的第一步后端代码给您您微信个推的工具类 自己写的用的话可以根据自己的需求改改 1 package com.jeesite.modules.sys.utils;\r\n 2 \r\n 3 import com.alibaba.fastjson.JSONObject;\r\n 4 import com.jeesite.common.wx.TemplateDataVo;\r\n 5 import com.jeesite.common.wx.WxMssVo;\r\n 6 import lombok.extern.slf4j.Slf4j;\r\n 7 import org.springframework.http.ResponseEntity;\r\n 8 import org.springframework.stereotype.Component;\r\n 9 import org.springframework.web.client.RestTemplate;\r\n10 import java.util.HashMap;\r\n11 import java.util.Map;\r\n12 \r\n13 /**\r\n14  * @Author wm\r\n15  * @Description wx小程序发送工具\r\n16  * @Date 2020/4/278:22\r\n17  **/\r\n18 \r\n19 @Slf4j\r\n20 @Component\r\n21 public class WeChatPushUtils {\r\n22 \r\n23 \r\n24 \r\n25     /**\r\n26      *\r\n27      * @param openid 用户openid\r\n28      * @param templateDataVo 模板消息\r\n29      * @return\r\n30      */\r\n31     public static String pushOneUser( String openid,TemplateDataVo templateDataVo) {\r\n32         RestTemplate restTemplate = new RestTemplate();\r\n33         //自动获取token\r\n34         String access_token = getAccess_token();\r\n35         String url = \"https://api.weixin.qq.com/cgi-bin/message/subscribe/send?access_token=\" + access_token; //微信请求接口\r\n36         //封装模板数据\r\n37         WxMssVo wxMssVo = new WxMssVo();\r\n38         //用户openid\r\n39         wxMssVo.setTouser(openid);\r\n40         Map<String,Object> data = new HashMap<>();\r\n41         data.put(\"number2\",templateDataVo.getNumber2());\r\n42         data.put(\"name1\",templateDataVo.getName1());\r\n43         wxMssVo.setData(data);\r\n44         ResponseEntity<String> responseEntity = restTemplate.postForEntity(url,JSONObject.toJSON(wxMssVo).toString(),String.class);\r\n45         log.info(\"小程序推送结果={}\", responseEntity.getBody());\r\n46         return responseEntity.getBody();\r\n47     }\r\n48 \r\n49     /**\r\n50      * 获取access_token\r\n51      * appid和appsecret到小程序后台获取，当然也可以让小程序开发人员给你传过来\r\n52      * */\r\n53     public static   String getAccess_token() {\r\n54         RestTemplate restTemplate = new RestTemplate();\r\n55         //获取access_token\r\n56         String appid = \"微信appid\";\r\n57         String appsecret = \"密钥\";\r\n58         String url = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential\" +\r\n59                 \"&appid=\" + appid + \"&secret=\" + appsecret; //获取token\r\n60         if(restTemplate==null){\r\n61             restTemplate = new RestTemplate();\r\n62         }\r\n63         String json = restTemplate.getForObject(url, String.class);\r\n64         JSONObject myJson = JSONObject.parseObject(json);\r\n65         return myJson.get(\"access_token\").toString();\r\n66     }\r\n67 }这里面不得不说的几个坑  我的天那选的模板 一定一定要根据微信公众平台提供的例子去封装 一定一定一定 别自己随便去封装什么实体 最底层的key就是value不解释了我截个图去   也别说了 看图宝贝 接口很隐秘网址先po出来https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/subscribe-message/subscribeMessage.send.html看右边大红框里面的data值 就是你申请的模板对应的相关字段 data 比如你申请的字段是 thing1 name你写的方式就是12345data{thing1:{value:\"thing1的值\"}} 对没错 value 就是每个字段值的key这就是那个坑封装的坑 如果想实体封装太麻烦 建议JSONOBJECT简单粗暴但是!!!!但是 到了这一步即使你传进去了模板id openid 想发请求 不好意思  不行行!!!!!!!!下面我们来看看原因    还是看图 步骤一的数据都有了  详情网址:https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html那他妈步骤二呢  用户没订阅发个蛋蛋............下面就得让openid这个用户订阅一下  上!!!代!!!!码!!!!!我是这样做的  加了一个按钮 ,用户点了就是这样的  虽然有点丑 功能是有了代码标签1 <button bindtap=\"subTap\"   type=\"defaults\" style=\" background-color:#98F898;width:95%;margin:20px 10px;\">订阅消息<text>{{textcontent}}</text></button>函数 1 //订阅消息开启\r\n 2 data: {\r\n 3   textcontent: '提示：未开启'\r\n 4 },\r\n 5 \r\n 6 // 检测是否开启  更新提示\r\n 7 testingTap: function() {\r\n 8   let that = this;\r\n 9   wx.getSetting({\r\n10     withSubscriptions: true,\r\n11     success(res) {\r\n12       console.log(res)\r\n13       if (res.subscriptionsSetting.mainSwitch) {\r\n14         if (res.subscriptionsSetting.itemSettings != null) {\r\n15           let item = res.subscriptionsSetting.itemSettings.模板id\r\n16           console.log(item)\r\n17           if (item == \"reject\") {\r\n18             that.setData({\r\n19               textcontent: '提示：您已经拒绝订阅消息'\r\n20             })\r\n21           } else if (item == \"accept\") {\r\n22             that.setData({\r\n23               textcontent: '提示：您已经开启订阅消息'\r\n24             })\r\n25           } else if (item == \"ban\") {\r\n26             that.setData({\r\n27               textcontent: '提示：您已经被后台封禁'\r\n28             })\r\n29           }\r\n30         }\r\n31       } else {\r\n32         that.setData({\r\n33           textcontent: '提示：订阅消息未开启'\r\n34         })\r\n35       }\r\n36     }\r\n37   })\r\n38 },\r\n39 \r\n40 //授权\r\n41 subTap: function() {\r\n42   let that = this;\r\n43   wx.requestSubscribeMessage({\r\n44     tmplIds: ['模板id'],\r\n45     success(res) {\r\n46       if(res.模板id==\"accept\"){\r\n47         that.setData({\r\n48           textcontent: '提示：授权成功'\r\n49         })\r\n50       }else{\r\n51         that.setData({\r\n52           textcontent: '提示：未授权'\r\n53         })\r\n54       }\r\n55     },\r\n56     fail(res) {\r\n57   \r\n58       that.setData({\r\n59         textcontent: '提示：授权失败'\r\n60       })\r\n61     }\r\n62   })\r\n63 }这样用户订阅了之后才能发送 .........快去试试吧本文为原创当然写的时候太草率 有诸多问题没有说明 但是代码你只要有点基础 放对地方了绝对 下面附成功图  如果有什么问题加QQ:592322684 我乐于助人 有啥不会的咱俩一块不会.........嘿嘿 作者： C1own出处：https://www.cnblogs.com/C1own/p/12801087.html版权：本文采用「署名-非商业性使用-相同方式共享 4.0 国际」知识共享许可协议进行许可。亲分享时记得带上出处噢"}
{"title": "只会Vue怎么开发小程序？Vue和微信小程序的到底有哪些区别?", "author": "Rolan", "time": "2020-4-30 00:11", "content": "写了vue项目和小程序，发现二者有许多相同之处，在此想总结一下二者的共同点和区别。 1|0一、生命周期先贴两张生命周期图对比下：1|1vue生命周期 1|2小程序生命周期   相比之下，小程序的钩子函数要简单得多。vue的钩子函数在跳转新页面时，钩子函数都会触发，但是小程序的钩子函数，页面不同的跳转方式，触发的钩子并不一样。onLoad: 页面加载一个页面只会调用一次，可以在 onLoad 中获取打开当前页面所调用的 query 参数。onShow: 页面显示每次打开页面都会调用一次。onReady: 页面初次渲染完成一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。对界面的设置如wx.setNavigationBarTitle请在onReady之后设置。详见生命周期onHide: 页面隐藏当navigateTo或底部tab切换时调用。onUnload: 页面卸载当redirectTo或navigateBack的时候调用。 数据请求在页面加载请求数据时，两者钩子的使用有些类似，vue一般会在created或者mounted中请求数据，而在小程序，会在onLoad或者onShow中请求数据。2|0二、数据绑定VUE:vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例：1<img :src=\"imgSrc\"/> 小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来，如果不加括号，为被认为是字符串。例：1<image src=\"{{imgSrc}}\"></image>　　3|0三、列表渲染我们直接贴代码，两者还是有些相似3|1vue：123456789101112131415<ul id=\"example-1\">  <li v-for=\"item in items\">    {{ item.message }}  </li></ul> var example1 = new Vue({  el: '#example-1',  data: {    items: [      { message: 'Foo' },      { message: 'Bar' }   ]  }})　　3|2小程序：12345678910Page({  data: {    items: [      { message: 'Foo' },      { message: 'Bar' }    ]  }}) <text wx:for=\"{{items}}\">{{item}}</text>　　4|0四、显示与隐藏元素vue中，使用v-if 和v-show控制元素的显示和隐藏小程序中，使用wx-if和hidden控制元素的显示和隐藏 5|0五、事件处理vue：使用v-on:event绑定事件，或者使用@event绑定事件,例如:12<button v-on:click=\"counter += 1\">Add 1</button><button v-on:click.stop=\"counter+=1\">Add1</button>  //阻止事件冒泡　　小程序: 全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件,例如：12<button bindtap=\"noWork\">明天不上班</button><button catchtap=\"noWork\">明天不上班</button>  //阻止事件冒泡　　6|0六、数据双向绑定6|11.设置值在vue中,只需要再表单元素上加上v-model,然后再绑定data中对应的一个值，当表单元素内容发生变化时，data中对应的值也会相应改变，这是vue非常nice的一点。12345678910<div id=\"app\">    <input v-model=\"reason\" placeholder=\"填写理由\" class='reason'/></div> new Vue({  el: '#app',  data: {   reason:''  }})　　但是在小程序中，却没有这个功能。那怎么办呢？当表单内容发生变化时，会触发表单元素上绑定的方法，然后在该方法中，通过this.setData({key:value})来将表单上的值赋值给data中的对应值。下面是代码，可以感受一下:123456789101112<input bindinput=\"bindReason\" placeholder=\"填写理由\" class='reason'         value='{{reason}}' name=\"reason\" /> Page({data:{reason:''},bindReason(e) {    this.setData({      reason: e.detail.value    })  }})   　　当页面表单元素很多的时候，更改值就是一件体力活了。和小程序一比较，vue的v-model简直爽的不要不要的。 6|22.取值vue中，通过this.reason取值小程序中，通过this.data.reason取值 7|0七、绑定事件传参在vue中，绑定事件传参挺简单，只需要在触发事件的方法中，把需要传递的数据作为形参传入就可以了，例如：12345678910<button @click=\"say('明天不上班')\"></button> new Vue({  el: '#app',  methods:{    say(arg){    consloe.log(arg)    }  }})　　在小程序中，不能直接在绑定事件的方法中传入参数，需要将参数作为属性值，绑定到元素上的data-属性上，然后在方法中，通过e.currentTarget.dataset.*的方式获取，从而完成参数的传递，很麻烦有没有...123456789<view class='tr' bindtap='toApprove' data-id=\"{{item.id}}\"></view>Page({data:{    reason:''},toApprove(e) {    let id = e.currentTarget.dataset.id;  }})　　8|0八、父子组件通信8|11.子组件的使用在vue中：编写子组件在需要使用的父组件中通过import引入在vue的components中注册在模板中使用1234567891011121314151617181920212223242526272829303132333435// 父组件 foo.vue<template>  <div class=\"container\">    <bar :title=\"title\"></bar>  </div></template><script>import Bar from './bar.vue'export default{data(){    return{               title:\"我是标题\"    }},components:{    Bar}</script> // 子组件bar.vue<template>  <div class=\"search-box\">    <div :title=\"title\" ></div>  </div></template><script>export default{props:{    title:{       type:String,       default:''      }    }}</script>　　子组件和父组件通信可以通过this.$emit将方法和数据传递给父组件。 在小程序中父组件向子组件通信和vue类似，但是小程序没有通过v-bind，而是直接将值赋值给一个变量，如下：123<tab-bar currentpage=\"index\"></tab-bar> 此处， “index”就是要向子组件传递的值在子组件properties中，接收传递的值1234567properties: {    // 弹窗标题    currentpage: {            // 属性名      type: String,     // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）      value: 'index'     // 属性初始值（可选），如果未指定则会根据类型选择一个    }  }　　子组件向父组件通信和vue也很类似，代码如下:1234567891011121314151617//子组件中methods: {      // 传递给父组件    cancelBut: function (e) {      var that = this;      var myEventDetail = { pickerShow: false, type: 'cancel' } // detail对象，提供给事件监听函数      this.triggerEvent('myevent', myEventDetail) //myevent自定义名称事件，父组件中使用    },} //父组件中<bar bind:myevent=\"toggleToast\"></bar> // 获取子组件信息toggleToast(e){    console.log(e.detail)}　　如果父组件想要调用子组件的方法vue会给子组件添加一个ref属性，通过this.$refs.ref的值便可以获取到该子组件，然后便可以调用子组件中的任意方法，例如：12345//子组件<bar ref=\"bar\"></bar> //父组件this.$ref.bar.子组件的方法　　小程序是给子组件添加id或者class，然后通过this.selectComponent找到子组件，然后再调用子组件的方法,示例：12345//子组件<bar id=\"bar\"></bar> // 父组件this.selectComponent('#id').syaHello()　　小程序父组件改变子组件样式1.父组件将style传入子组件2.父组件传入变量控制子组件样式3.在父组件样式中，在子组件类名前面加上父组件类名1234567<view class='share-button-container' bindtap='handleShareBtn'>   <share-button  product=\"{{goodProduct}}\" type=\"1\" back-color=\"#fff\" fore-color=\"#9e292f\" bind:error=\"on_error\" /></view> .share-button-container .button--btn-navigator__hover{  background: #fff;}  小程序和vue在这点上太相似了，有木有。。。"}
{"title": "微信小程序实现点击按钮修改字体颜色功能【附demo源码下载】 ...", "author": "Rolan", "time": "2020-4-30 00:43", "content": "本文实例讲述了微信小程序实现点击按钮修改字体颜色功能。分享给大家供大家参考，具体如下：1、效果展示2、关键代码index.wxml文件<view class=\"view\" style=\"color:{{color}}\">我是view标签</view>\r\n<view style=\"display:flex;\">\r\n  <block wx:for=\"{{colorArray}}\" wx:key=\"\" wx:for-item=\"Color\">\r\n    <button class=\"btn\" style=\"background:{{Color}};\" type=\"default\" bindtap=\"bindtap{{index}}\"></button>\r\n  </block>\r\n</view>这里使用bindtap=\"bindtap{{index}}\"绑定事件动态修改style=\"color:{{color}}\"中的颜色值。index.js文件var pageData={}\r\npageData.data={\r\n  color:'black',\r\n  colorArray:['red','blue','yellow','green','black']\r\n}\r\nfor(var i=0;i<5;++i){\r\n  (function(index){\r\n    pageData['bindtap'+index]=function(e){\r\n      this.setData({\r\n        color:this.data.colorArray[index]\r\n      })\r\n    }\r\n  })(i)\r\n}\r\nPage(pageData)\r\n3、源代码点击此处本站下载。希望本文所述对大家微信小程序开发有所帮助。"}
{"title": "小程序实现自定义滚动条", "author": "Rolan", "time": "2020-4-30 00:52", "content": "在 「小程序」 中怎么实现这种横向滚动效果呢。\r\n说起来也简单，直接上代码吧\r\n1 .WXML\r\n\r\n分类区域使用小程序的scroll-view，绑定bindscroll事件，动态计算scroll-left的距离滚动条区域写用两个view模拟滚动条，滚动条的宽度和滚动距离都根据分类的内容来计算\r\n    <!-- 分类区域 -->\r\n    <view class=\"scroll-wrap\">\r\n        <scroll-view scroll-x=\"true\" scroll-with-animation=\"true\" bindscroll=\"spikeScroll\" class=\"scroll scroll-x\" scroll-left=\"{{scrollLeft}}\">\r\n            <view class=\"scroll-item index-nav\" wx:for=\"{{catList}}\" wx:key=\"catId\">\r\n                <view class=\"index-nav-item flex-y-fs {{item.selected?'selected':''}}\" data-idx=\"{{index}}\" data-catid=\"{{item.catId}}\"  bindtap=\"handleClickCat\">\r\n                    <view class=\"cat-img-wrap\">\r\n                        <image class=\"\" src=\"{{item.catPicUrl}}\" mode=\"\"></image>\r\n                    </view>\r\n                    <text>{{item.catName}}</text>\r\n                </view>\r\n            </view>\r\n        </scroll-view>\r\n    </view>\r\n    <!-- 滚动条区域 -->\r\n    <view class=\"scroll-bar\">\r\n        <view class=\"scroll-bar__bg\">\r\n        <view class=\"scroll-bar__slide\" style=\"width: {{barW}}rpx;left:{{percent}}rpx\"></view>\r\n        </view>\r\n    </view>\r\n复制代码2 .CSS\r\n.scroll-wrap {\r\n  width: 100%;\r\n  box-sizing: border-box;\r\n  background: #ffffff;\r\n}\r\n.scroll {\r\n  height: 100%;\r\n  box-sizing: border-box;\r\n}\r\n.scroll-x {\r\n  display: flex;\r\n  width: 100%;\r\n  white-space: nowrap;\r\n  overflow-x: auto;\r\n}\r\n.scroll-item {\r\n  width: 138rpx;\r\n  display: inline-block;\r\n  margin-right: 10rpx;\r\n  padding: 0 24rpx 27rpx;\r\n  font-size: 24rpx;\r\n  color: #4e4e4e;\r\n  font-family: PingFangSC-Regular, PingFang SC;\r\n}\r\n.scroll-bar {\r\n  background: #ffffff;\r\n}\r\n.scroll-bar__bg {\r\n  position: relative;\r\n  width: 86rpx;\r\n  height: 6rpx;\r\n  background: #d4d8dd;\r\n  border-radius: 5px;\r\n  margin: 0 auto;\r\n  overflow: hidden;\r\n}\r\n.scroll-bar__slide {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  height: 100%;\r\n  background: rgba(233, 89, 14, 1);\r\n  border-radius: 5px;\r\n}\r\n复制代码3 .JS\r\n  data: {\r\n      percent: 0,       //滚动条距离左边的距离\r\n      barW: 0,          //滚动条的宽度\r\n  }\r\n/* 计算滚动区域的宽度 */\r\n  countCatWidth () {\r\n      var query = wx.createSelectorQuery();\r\n      //选择id\r\n      var that = this;\r\n      query.select('.scroll-item').boundingClientRect(function (rect) {\r\n        let sw = (rect.width+5)*that.data.catList.length+5\r\n        that.setData({\r\n          barW: (86/sw)*wx.getSystemInfoSync().windowWidth\r\n        })\r\n      }).exec();\r\n  },\r\n  //bindscroll事件\r\n  spikeScroll(e) {\r\n      let barW = (86/e.detail.scrollWidth)*wx.getSystemInfoSync().windowWidth\r\n      this.setData({\r\n          barW: barW,\r\n          percent: (86/e.detail.scrollWidth)*e.detail.scrollLeft\r\n      })\r\n  },"}
{"title": "微信小程序实现拍照界面自定义实现", "author": "Rolan", "time": "2020-5-1 00:10", "content": "最近有一个项目需要对拍照界面进行自定义，之前使用的是html写的项目界面，但是在html中想要自定义拍照界面十分的困难,于是想到了使用微信小程序来实现拍照界面的自定义在微信小程序中实现自定义拍照功能主要使用到如下的组件和API1：camera组件常见的属性有:(1)：mode应用模式，只在初始化时有效，不能动态变更，参数有：normal(相机模式),scanCode(扫码模式) ，默认为normal(2)：device-position摄像头朝向，参数有front(前置),back(后置)，默认为back(3)：flash闪关灯，参数有：auto(自动,手机相机目前的闪光灯状态), on(打开闪光灯), off(关闭闪光灯)，默认为auto(4)：binderror用户不允许使用摄像头时触发事件例如:<camera device-position=\"back\" flash=\"off\" >  \r\n</camera>  2：拍摄照片API(CameraContext.takePhoto)参数说明：(1)quality成像质量,参数有：high(高质量),normal(普通质量),low(低质量)，默认为normal(2)success接口调用成功的回调函数(3)fail接口调用失败的回调函数例如：//拍摄照片  \r\nwx.createCameraContext().takePhoto({  \r\n  quality: 'high',//拍摄质量(high:高质量 normal:普通质量 low:高质量)  \r\n  success: (res) => {  \r\n    //拍摄成功  \r\n    //照片文件的临时文件  \r\n    var file = res.tempImagePath;  \r\n  },  \r\n  fail: (res) => {  \r\n    //拍摄失败  \r\n  },  \r\n})  3:上传拍照文件API(uploadFile)参数说明：url:上传文件的服务器地址filePath:要上传文件资源的路径 (本地路径)name:文件对应的 key，开发者在服务端可以通过这个 key 获取文件的二进制内容formData:HTTP 请求中其他额外的参数success：接口调用成功的回调函数fail：接口调用失败的回调函数例如：wx.chooseImage({  \r\n  success (res) {  \r\n    const tempFilePaths = res.tempFilePaths  \r\n    wx.uploadFile({  \r\n      url: 'https://example.weixin.qq.com/upload', //仅为示例，非真实的接口地址  \r\n      filePath: tempFilePaths\\[0\\],  \r\n      name: 'file',  \r\n      formData: {  \r\n        'user': 'test'  \r\n      },  \r\n      success: (res) => {  \r\n        //上传成功  \r\n      },  \r\n      fail: function(t) {  \r\n        //上传失败  \r\n    },  \r\n    })  \r\n  }  \r\n})  4：根据如上我们就可以实现在微信小程序中自定义拍照页面来实现上传(1)：wxml端：<!--pages/web/index.wxml-->  \r\n<camera binderror=\"handleCameraError\" device-position=\"{{devicePosition}}\" flash=\"off\"  wx:if=\"{{authCamera}}\">  \r\n<cover-view>  \r\n    <cover-image class=\"line\" src=\"/images/outline.png\"></cover-image>  \r\n</cover-view>  \r\n</camera>  \r\n<button type=\"primary\" bindtap=\"takePhoto\">拍照</button>  \r\n<button type=\"primary\" bindtap=\"reverseCamera\">摄像头切换</button>  \r\n<view class=\"error-handler\" wx:if=\"{{!authCamera}}\">  \r\n    <button class=\"nobtn\" openType=\"openSetting\">打开相机授权</button>  \r\n</view>  (2)：js端// pages/web/index.js  \r\nPage({  \r\n  /\\*\\*  \r\n   \\* 页面的初始数据  \r\n   \\*/  \r\n  data: {  \r\n    devicePosition:'back',  \r\n    authCamera: false,//用户是否运行授权拍照  \r\n  },  \r\n  handleCameraError:function() {  \r\n    wx.showToast({  \r\n      title:'用户拒绝使用摄像头',  \r\n      icon: 'none'  \r\n    })  \r\n  },  \r\n  reverseCamera:function(){  \r\n    this.setData({  \r\n      devicePosition: \"back\" === this.data.devicePosition ? \"front\" : \"back\"  \r\n  });  \r\n  },  \r\n  takePhoto:function() {  \r\n    //拍摄照片  \r\n    wx.createCameraContext().takePhoto({  \r\n      quality: 'high',//拍摄质量(high:高质量 normal:普通质量 low:高质量)  \r\n      success: (res) => {  \r\n        //拍摄成功  \r\n        //照片文件的临时文件  \r\n        var file = res.tempImagePath;  \r\n        console.log(file)  \r\n        //上传图片到服务器  \r\n        wx.uploadFile({  \r\n          url: 'XXXX', //上传服务器地址  \r\n          filePath: file,  \r\n          name: 'file',  \r\n          formData: {  \r\n            'test': 'test'  \r\n          },  \r\n          success: (res) => {  \r\n            //上传成功  \r\n          },  \r\n          fail: function(t) {  \r\n            //上传失败  \r\n          },  \r\n        })  \r\n      },  \r\n      fail: (res) => {  \r\n        //拍摄失败  \r\n      },  \r\n    })  \r\n  },  \r\n  /\\*\\*  \r\n   \\* 生命周期函数--监听页面显示  \r\n   \\*/  \r\n  onShow: function () {  \r\n    wx.getSetting({  \r\n      success: (res) => {  \r\n          if (res.authSetting\\[\"scope.camera\"\\]) {  \r\n              this.setData({  \r\n                authCamera:true,  \r\n              })  \r\n          } else {  \r\n            this.setData({  \r\n              authCamera:false,  \r\n            })  \r\n          }  \r\n      }  \r\n    });  \r\n  },  \r\n})  具体相信如下：在接口处理上传文件的流程和正常的表单上传文件流程相同，这里就不多叙述了"}
{"title": "使用flex弹性布局代替传统浮动布局来为微信小程序写自适应页面 ...", "author": "Rolan", "time": "2020-5-1 00:22", "content": "原文转载自「刘悦的技术博客」 v3u.cn/a_id_109我们知道，写习惯了前端的人，一般切图后布局页面的话，上手最习惯的是基于盒子模型的浮动布局，依赖 display 属性 + position属性 + float属性，但是浮动布局有一些致命的小问题，比如垂直居中比较费劲，比如著名的 float坍塌问题 ，另外有些极端情况下，还得使用模型+clear:both来手动清除浮动，比较麻烦。于是，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能，本人在微信小程序页面中尝试了一下弹性布局，个人感觉是：简直太好用了。Flex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。.box{\r\n  display: flex;\r\n}\r\n复制代码不过需要注意一点，就是设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。也就是说浮动布局和弹性布局不可共存，二者必居其一。其实flex布局原理很简单，采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。弹性布局的容器可以设置下面这些属性：flex-direction\r\nflex-direction属性决定主轴的方向（即项目的排列方向）。\r\n.box {\r\n  flex-direction: row | row-reverse | column | column-reverse;\r\n}\r\n\r\nflex-wrap\r\n默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\r\n.box{\r\n  flex-wrap: nowrap | wrap | wrap-reverse;\r\n}\r\n\r\nflex-flow\r\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\r\n.box {\r\n  flex-flow: <flex-direction> || <flex-wrap>;\r\n}\r\n\r\n\r\njustify-content\r\njustify-content属性定义了项目在主轴上的对齐方式。\r\n.box {\r\n  justify-content: flex-start | flex-end | center | space-between | space-around;\r\n}\r\n\r\n\r\nalign-items\r\nalign-items属性定义项目在交叉轴上如何对齐。\r\n.box {\r\n  align-items: flex-start | flex-end | center | baseline | stretch;\r\n}\r\n\r\nalign-content\r\nalign-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\r\n.box {\r\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\r\n}\r\n复制代码说了这么多，都是理论，我们来用弹性布局实战一下，比如我们要模仿瑞辛咖啡小程序中的，首行单列，换行双列，并且自适应整个手机页面的布局页面部分:<template>\r\n   \r\n\r\n        <div class=\"container1\">\r\n \r\n            <div class=\"item11\">\r\n            1\r\n            </div>\r\n            \r\n           <div class=\"item12\">\r\n            \r\n              <div class=\"item1\">\r\n                  3\r\n                  </div>\r\n\r\n\r\n                  <div class=\"item1\">\r\n                      3\r\n                      </div>\r\n            \r\n          </div>\r\n            \r\n            <div class=\"item12\">\r\n              \r\n                <div class=\"item1\">\r\n                    3\r\n                    </div>\r\n  \r\n  \r\n                    <div class=\"item1\">\r\n                        3\r\n                        </div>\r\n\r\n\r\n            </div>\r\n            \r\n         \r\n            \r\n  \r\n\r\n\r\n      \r\n\r\n    </div>\r\n    </template>\r\n复制代码css部分:.container1{\r\n  height: 100%;\r\n  width:100%;\r\n  background-color:beige;\r\n  display:flex;\r\n  flex-flow:column;\r\n}\r\n\r\n\r\n.item11{\r\n  height:300rpx;\r\n  background-color:cyan;\r\n  border: 1px solid #fff\r\n}\r\n\r\n.item12{\r\n  height:300rpx;\r\n  background-color:cyan;\r\n  border: 1px solid #fff;\r\n  display:flex;\r\n}\r\n \r\n.item1{\r\n  height:300rpx;\r\n  width: 50%;\r\n  background-color:cyan;\r\n  border: 1px solid #fff\r\n}\r\n复制代码轻松搞定，代码量比浮动布局少了很多，简直完美。原文转载自「刘悦的技术博客」 v3u.cn/a_id_109"}
{"title": "实现微信小程序最新运行环境系列 (初始篇)", "author": "Rolan", "time": "2020-5-1 00:59", "content": "实现微信小程序编译和运行环境系列 (初始篇)前言最近一段时间在研究实现微信小程序和小游戏编译打包和运行环境平台开发。目前基本可以支持微信基础库 2.8.2 功能迭代了。所以想通过记录分享一下自己的认知过程中遇到的一些问题和解决方案来更好的理解小程序设计上的优点和一些不足的地方。在此之前网上有存在开源的一些基于微信基础库版本 1.0 的一些参考。核心作者是由开源大牛 启明兄 的 wept 项目基础上构建的 (目前有幸和启明兄成为同事对这个小程序整体的架构理解帮助了我很多)。由于 wept 的运行环境是基于微信基础库 1.0 的版本上实现之后也不维护了，时间上是 2016 的在后续的更新的版本中新加的一些特性如自定义组件 npm 包很多 api 等开发实现都不支持，最主要是的微信在后续架构中更换底层的通信方式采用了 webstock 的方式等一些其他变化。正文后面我会通过几篇文章来整体描述一下从工具到破解到源码解析和原理到实现的处理流程最开始的时候也在网上找了很多的资料，看了有一些人写的解析微信小程序架构的文章，从中学习了解了很多，但如果想模拟实现出来这么个东西还是有蛮迷糊的，所以我想通过我们所实现的过程来一点点 从现象 看本质 来解析下微信小程序编译和运行原理。凡事对自己多点信心，多坚持下，多学习下，想想我们遇到的问题，当时感觉我，搞不定了，弄不了，最后随着时间的推移和认知的迭代问题总会慢慢消灭掉。本文将先通过全面解析微信开发者工具来知道那些基本的文件和内容组成一一讲述 (从现象 看本质)。在此之前我们通过官方文档可以了解一些内容整个小程序框架系统分为两部分：逻辑层（App Service）和 视图层（View）；小程序提供了自己的视图层描述语言 WXML 和 WXSS；基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统他们两个线程里运行；视图层使用 WebView 渲染，逻辑层使用 JSCore 运行， 视图层和逻辑层通过系统层的 JSBridage 进行通信，逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。从上述说明中我们可以得知一些重要信息逻辑层（App Service）和 视图层（View） 以及两者之间的通信协调。下面通过微信开发工具来展示说明，小程序逻辑层的 javascript 代码是运行在 NW.js 中，视图层是由 Chromium 60 Webview 来渲染的他们之间是通过 webstock 协议来通信的。以下我们主要是以 mac 环境为主我们先打开 微信开发工具官方 demo 如图：从上图和我们的一些理解我们知道微信小程序的文件格式主要组成：.js 主要页面逻辑；.wxml 页面结构，框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构；.wxss 是一套样式语言，用于描述 WXML 的组件样式；.json 页面配置按照『约定优于配置』的原则。接下来我们先找到本机微信开发者工具应用包里面如图我们后面分析的主要代码都在 package.nw 里面和 core.wxvpkg。这些文件在后面实现过程中都会使用说明用途的。js 文件里面的内容主要是在页面和逻辑层的渲染用，后面将会看到；core.wxvpkg 是这个里面的核心文件破解这个包可以知道很多逻辑可以先给大家看下解压后包的结构：core.wxvpkg 解压代码上传在 unwxvpkg 大家有兴趣可以自己先试试。接下来我们回到开发者工具中打开：微信开发者工具–》调试–》调试微信开发者工具打开调试后我们可以看到的界面如下：从上面的现象我们可以看出他的两层渲染层和逻辑层结构是包含在两个 webview 里面第一个对应的 webview 是渲染层的每个页面都对应一个地址但逻辑层 appservice 只有一个不变的下来我们可以看看这个 webview 里面是个什么东如果我们直接把 view 层的 webview 标签改成 iframe 的话可以看到微信就直接不在里面展示给你页面白屏了如果你更改 appservice 的 webview 的话微信还会给你各种 alert 弹框，反正应该就是不想让你分析他的代码点击确定消都消不了只能重新重启编译了 有点小恶心啊居然不让我们正大光明的看，那我们只能搞一些旁门左道来破坏了我们第一步还是打开：微信开发者工具–》调试–》调试微信开发者工具在控制台输入 复制代码document.getElementsByTagName('webview')\r\n可以看到对应的有 4 个 webview, 我们先要关注的是第一个 webview 因为你点开可以发现第一个对应的就是渲染层的 webview后面的几个可以先不关注，后续我们会详解然后我们执行命令打开第一个 webview: 复制代码document.getElementsByTagName('webview')[0].showDevTools(true,null)\r\n可以看到如图现在我们就可以看到微信页面渲染层的页面结构了(这里说明下本篇文章中文件里面的内容每一个文件的来源和用途，我都会在后续章节中讲解出来 因为里面涉及的内容过多 我怕放在一篇文章里会太长大家看了会厌烦，所以我会分为几篇来说明，后面的 appservice 和 一些基础包和 WAWebview.js WAService.js 以及使用的同步 api 和请求在页面的 appservice.js 等等，在本篇中只会简单描述出来 不做过多讲解，后续会逐步更新)上面的 webview 可以找到对应的页面层的结构，那么 appservice 要怎么找到呢？其实最简单的我们直接在首页里面的控制台打 document 就可以直接看到展示的逻辑层代码(我的做法是从写了微信的 alert 和基础库的一些文件都可以看到这个结构)注意点在微信小游戏里面微信重写了 window 和 document 对象 所以不能直接按照我们平常操作页面那样使用接下面我们看下微信小程序的基础库库文件方法是我们在首页控制台里面输入 openVendor()我们可以看到弹出的文件系统，这里面对应的就是你选择本地的详情 ==》调试基础库 ==》选择基础库版本.wxvpkg 文件就是每个基础库版本的包我们，解压这个包我们可以看到他的组成；wcc 可执行程序，用于将 wxml 转为 view 模块使用的 js；wcsc 可执行程序，用于将 wxss 转为 view 模块使用的 css。.wxvpkg 包里面这个基础库文件的 WAWebview.js 和 WAService.js，对应这两个 webview 里面的 js 引用你可以仔细观察下.wxvpkg 文件解包后的格式：解压.wxvpkg 格式包的代码地址 github对于 wcc 和 wcsc 源码现在没必要去研究他，但我们可以通过脚本劫持方法可以看到他运行了什么命令操作这里告诉大家一个方法劫持他的运行命令找到微信开发者工具 wcc 和 wcsc 的地方然后新建两个同名的脚本，然后把原文件从命名，然后重启微信开发者工具 一定要重启不然不生效wcc wcsca 劫持脚本代码地址 github然后我们到首页控制台还是输入 openVendor() 可以看到输出的文件从上面这个图就可以看出下面这个图里面我们可以认知到一些信息首次加载的时候 wcc 执行了 -ds -d - xc…和 -ds -d - cc…结构的命令可以看到微信首次把所有.wxml 都执行了可以看到参数里面有个数字其实他对应的有几种.wxml 文件形式向只存在.wxml 和自定义组件等一些格式他是没计算在内的-xc -cc 其实对应就是下面图两个逻辑层和渲染层里面的 js 方式我发现当我们修改一个.wxml 里面一点改动的时候，微信又会全部从新编译执行这些命令很耗时这点其实可以改进的。另一个微信开发者工具感觉做的不友好的地方是大于 500KB 的 javascript 文件不做给你做 es6 转换和压缩，就算你设置了微信也不会给你转，可以在 source 里面的资源可以看出。wcc 执行的命令最终生成的就是逻辑层和渲染层的 $gwxc() 方法里面的 js 代码，大家可以自己手动测试下就会发现。wxss 生成的主要是渲染层 eval() 这一坨代码本篇只是简单描述了一些关键文件的描述。后面我会对关键文件进行一一分析描述下他具体做了什么，为什么用到它。下一篇会给大家带来渲染层和逻辑层的具体页面文件内容结构解析，以及 webstock 通信架构在微信开发者工具里面的运用，可以先给大家看下。其实他们之间的协调工作以及公开对外的 wx. 对象上面的 api 都是通过 websocket 协议消息实现的。"}
{"title": "微信小程序|动态时钟", "author": "Rolan", "time": "2020-5-2 00:02", "content": "问题描述近期，网络上流行了一个“时间管理”的梗，想要做好时间管理，清楚把握时间才是关键点，那么借着这个“时间管理”，来介绍一个小程序实现动态时钟的案例吧。效果图：图2.1 动态时钟解决方案1、wxmlwxml代码十分简单，只需要一个canvas组件便能实现一个时钟外圆形状。<canvas  canvas-id='myCanvas'></canvas>2、jsjs部分主要针对于Math相关属性的应用。（1）指针的配置：指针都要对运动路径进行适当的设置，需要利用Math.PI属性来对不同指针转动角度进行配置。比如，秒针转动角度Math.PI/30表示将整个圆(360°)平分为60份，即一秒转过6°；分针、时针的计算同理。指针转动到某个点，存在一个坐标，坐标的计算需要利用Math.sin、Math.cos属。（2）方法为：假设圆心坐标为(a,b)，则x=a + Math.sin(angle * (Math.PI / 180)) * r ；y=b -Math.cos(angle * (Math.PI / 180)) * r 。（3）表盘、数字点：arc(x,y,半径,起始位置，结束位置)3、代码示例：（1）先定义将要直接执行的几个函数  onShow:  function (e) {     setInterval(show, 1000); //每秒执行1次     function show() {       secshow() //秒针       minshow() //分针       houshow() //时针       backshow() //表盘       numbershow() //数字       ctx.draw()     }   },（2）秒针function secshow() {   var now = new Date()   var sec = now.getSeconds()   //角度弧度   var angle = sec * Math.PI / 30   var x = 100 * Math.sin(angle) + 150   var y = 150 - 100 * Math.cos(angle)   ctx.beginPath() #开始路径  ctx.setLineWidth(5)  //线条粗细   ctx.setStrokeStyle('black')   ctx.moveTo(150, 150)   ctx.lineTo(x, y) //指针指向   ctx.closePath() //返回初始状态   ctx.stroke() //描出点的路径}（3）分针function minshow() {   var now = new Date()   var min = now.getMinutes()   var sec = now.getSeconds()   var angle = (min + sec / 60) * Math.PI / 30   var x = 80 * Math.sin(angle) + 150   var y = 150 - 80 * Math.cos(angle)   ctx.beginPath()   ctx.setLineWidth(5)   ctx.setStrokeStyle('black')   ctx.moveTo(150, 150)   ctx.lineTo(x, y)  ctx.closePath()   ctx.stroke()}（4）时针function houshow() {   var now = new Date()   var hou = now.getHours()   hou = hou % 12  //24小时制，取余数   var min = now.getMinutes()   var sec = now.getSeconds()   var angle = (hou + min / 60 + sec / 3600) * Math.PI / 6   var x = 50 * Math.sin(angle) + 150   var y = 150 - 50 * Math.cos(angle)   ctx.beginPath()   ctx.setLineWidth(8)   ctx.moveTo(150, 150)   ctx.lineTo(x, y)   ctx.closePath()   ctx.stroke()}(5)表盘及数字点function backshow() {   ctx.beginPath()  ctx.setLineWidth(3)   ctx.arc(150, 150, 110, 0, 2 * Math.PI)   ctx.closePath()   ctx.stroke()} function numbershow() {   ctx.beginPath()   ctx.setFontSize(20)   for (var i = 1; i < 13; i++) {     var angle = i * Math.PI / 6     var x = 100 * Math.sin(angle) + 145     var y = 158 - 100 * Math.cos(angle)     ctx.fillText(i, x, y)  }}"}
{"title": "微信小程序无法保存图片提示saveImageToPhotosAlbum:fail file not found ...", "author": "Rolan", "time": "2020-5-4 00:47", "content": "最近项目中遇到一个需求，就是要保存商品的图片到手机相册，一开始我还以为挺简单的，毕竟文档在哪里，小程序一般都是拿来就用的，可是这个就是不行，遇到提示saveImageToPhotosAlbum:fail file not found问题，最后发现是用户没有授权。解决这个问题又发现小程序又无法保存图片，这明明是同意了为什么还不行，经过研究发现，我没要先获取图片信息在进行保存就可以了。我使用的是uni-app来开发的，如果你用原生小程序开发的话就把uni改成wx吧！在这里我强烈推荐大家使用uni-app来开发小程序。具体什么好处，大伙可以去看看uni-app的文档，好了不多说看代码。/* 如果是这么写的，可以不使用button设置open-type属性*/\r\n/* 判断是否授权 */\r\nuni.authorize({\r\n    /* 这个就是保存相册的 */\r\n    scope: 'scope.writePhotosAlbum',\r\n    success() {\r\n        /* 保存图片方法 */\r\n        img();\r\n    },\r\n    complete(res) {\r\n        console.log(res);\r\n        /* 这里判断一下如果没有授权重新打开设置选项 */\r\n        uni.getSetting({\r\n            success(res) {\r\n                if (!res.authSetting['scope.writePhotosAlbum']) {\r\n                    /* 打开设置的方法 */\r\n                    opensit();\r\n                }\r\n            }\r\n        });\r\n    }\r\n});\r\n/* 授权提示 ，这里就是重复提示用户去授权*/\r\nfunction opensit() {\r\n    uni.showModal({\r\n        content: '由于您还没有允许保存图片到您相册里,这无法进行分享操作点击确定去允许授权',\r\n        success: function(res) {\r\n            if (res.confirm) {\r\n                /* 这个就是打开设置的API*/\r\n                uni.openSetting({\r\n                    success(res) {\r\n                        console.log(res.authSetting);\r\n                    }\r\n                });\r\n            } else if (res.cancel) {\r\n                uni.showModal({\r\n                    cancelText: '依然取消',\r\n                    confirmText: '重新授权',\r\n                    content: '很遗憾你点击了取消，这将无法进行分享操作，请慎重考虑',\r\n                    success: function(res) {\r\n                        if (res.confirm) {\r\n                            uni.openSetting({\r\n                                success(res) {\r\n                                    console.log(res.authSetting);\r\n                                }\r\n                            });\r\n                        } else if (res.cancel) {\r\n                            console.log('用户不授权');\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n}\r\n/* 特别注意要先获取图片信息在进行保存，不让保存不了 */\r\nfunction img() {\r\n/* 我这里要保存多张图片，一张的话就可以取消这些，具体看你的需求 */\r\n    if (num > len) {\r\n        return false;\r\n    }\r\n    /* 获取图片信息 */\r\n    uni.getImageInfo({\r\n        src: obj[num],\r\n        success: function(image) {\r\n            console.log(image);\r\n            /* 保存图片到相册 */\r\n            uni.saveImageToPhotosAlbum({\r\n                filePath: image.path,\r\n                success: function() {\r\n                    console.log('save success');\r\n                    if (num == len) {\r\n                        uni.showModal({\r\n                            title: '保存成功',\r\n                            content: '图片已成功保存到相册，快去分享到您的圈子吧',\r\n                            showCancel: false\r\n                        });\r\n                    }\r\n                },\r\n                complete(res) {\r\n                    console.log(res);\r\n                }\r\n            });\r\n        }\r\n    });\r\n    num++;\r\n    img();\r\n}"}
{"title": "钉钉小程序 之 自定义组件的使用，以及父组件与子组件(自定义组件)传值 ...", "author": "Rolan", "time": "2020-5-5 00:09", "content": "本机环境自定义组件（子组件）页面中引入（父组件引入子组件）父组件（使用自定义组件的页面）传值给子组件子组件（自定义组件）传值给父组件备注一、本机环境本机系统： Mac\r\n小程序开发者工具:  1.5.7\r\n复制代码二、自定义组件（子组件）子组件中：项目的根目录下！！创建自定义组件在对应 json 文件中定义 component 属性如图在根目录 的 `components` 目录（目录名自定义）下存放自定义组件\r\n复制代码三、页面中引入（父组件引入子组件）父组件中：路径引入在对应页面下添加 json 文件中定义 usingComponentsaxml 文件中直接使用如图 \r\n复制代码（图 3.1）（图 3.2）四、父组件（使用自定义组件的页面）传值给子组件子组件中：通过属性 props 传递值 numIndex在 data 中定义对应的值 itemIndex在生命周期 didMount 中修改对应的值如图 \r\n复制代码（图 4.1）五、子组件（自定义组件）传值给父组件子组件通过函数参数，传递值给父组件子组件通过 props 属性传递函数，但是注意:warning:，函数名必须以 on 开头父组件中给对应函数属性，传递对应的方法如图 子组件\r\n复制代码（图 5.1）如图 父组件\r\n复制代码（图 5.2）备注第 五 步尴尬了很久，因为函数名 不是以 on 开头的！！！ ，过分，开发文档的提示，可不可以加个其他颜色呐！！！微笑:blush:，参考 这里 ：写给自己的随笔，有问题欢迎指出"}
{"title": "使用scss开发小程序（各种小程序平台通用）", "author": "Rolan", "time": "2020-5-6 00:02", "content": "微信小程序的 wxss 、阿里旗下淘宝、支付宝小程序的 acss 等等语法很类似原生css，但是在web开发里用惯了动态css语言，再写回原生css很不习惯，尤其是父子样式的嵌套写法非常繁琐。因此，我希望能有一个自动化构建方案，能够简单地将scss转换成小程序的样式语言。方案1以前写微信小程序的依赖库时用过，使用gulp编译，将源码和编译后的代码分别放到src和dist两个目录。gulp会处理src下面的所有文件，将其中的scss转换成css，并将其他所有文件原封不动挪到dist下相应位置。这里就不详细说了，代码参考 Wux 。方案2非常简单直接，使用 Webstorm / IDEA 的 File Watchers 功能实时转换。安装Ruby和sass确保命令行输入 sass -v 能出现版本号，安装过程略。安装 File Watchers到插件市场上搜索并安装（已安装则跳过）添加scss的转换脚本现在安装完插件打开项目会自动弹出scss转css的向导，方便了很多。但还需要做一些修改，配置如下：首先要将生成文件的后缀名改掉，比如这里我的淘宝小程序就得是 acss 。其次，将Arguments改为:$FileName$:$FileNameWithoutExtension$.acss --no-cache --sourcemap=none --default-encoding utf-8 --style expanded\r\n复制代码如果不加 --no-cache ，scss文件同目录下会出现一个 .sass-cache 目录。如果不加 --sourcemap=none , scss文件同目录下会出现一个 .map 文件。如果不加 --default-encoding utf-8 , scss文件如果有中文注释转换就会报错。style 可不加，这里用的是无缩进和压缩的风格，反正小程序打包发布时还会压，这里保持可读性。现在这个scss转换是单独作用于项目的，如果新建一个小程序项目，就需要重新添加（不建议设置成global，容易误伤）。注意到 File Watchers 列表的右侧操作栏下方有导入导出按钮，可以将现在配好的设置导出保存，将来新建项目时只要导入一下就行了。之后还有一个问题，如果我手动将编译后的css（即 wxss 或者 acss ，下略）文件删除，scss文件不改动的话，就不会重新编译出css文件。 或者万一监听失效或者不够及时，css还有可能是旧的。 所以还需要一个命令，用来将整个目录下的scss文件统一转换，确保没有遗漏和保持代码最新。不过我看了半天 sass 和 sass-convert 的文档，没有找到一个可用的写法，能让命令行遍历指定目录下的所有scss文件，将其转换成css放到源文件所在目录，并且将后缀名改为 wxss 或者 acss 。所以遍历这个行为只能交给nodejs来实现，代码如下：创建编译脚本 build/scss-convert.js ：var path = require(\"path\")\r\nvar fs = require(\"fs\")\r\nconst { exec } = require('child_process')\r\n\r\nconst basePath = path.resolve(__dirname, '../')\r\n\r\nfunction mapDir(dir, callback, finish) {\r\n  fs.readdir(dir, function(err, files) {\r\n    if (err) {\r\n      console.error(err)\r\n      return\r\n    }\r\n    files.forEach((filename, index) => {\r\n      let pathname = path.join(dir, filename)\r\n      fs.stat(pathname, (err, stats) => { // 读取文件信息\r\n        if (err) {\r\n          console.log('获取文件stats失败')\r\n          return\r\n        }\r\n        if (stats.isDirectory()) {\r\n          mapDir(pathname, callback, finish)\r\n        } else if (stats.isFile()) {\r\n          if (!['.scss'].includes(path.extname(pathname))) {\r\n            return\r\n          }\r\n          callback(pathname)\r\n        }\r\n      })\r\n      if (index === files.length - 1) {\r\n        finish && finish()\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\nmapDir(\r\n  basePath,\r\n  function (file) {\r\n    const newFileWithoutExt = path.basename(file, '.scss')\r\n    if (newFileWithoutExt.startsWith('_')) {\r\n      return  // 按照scss规则，下划线开头的文件不会生成css\r\n    }\r\n    // exec可以让nodejs执行外部命令\r\n    exec(`sass --no-cache --sourcemap=none --default-encoding utf-8 --style expanded ${file}:${newFileWithoutExt}.acss`, {\r\n      cwd: path.dirname(file) // 不写这个会导致生成的文件出现在根目录\r\n    }, (err, stdout, stderr) => {\r\n      if (err) {\r\n        console.log(err)\r\n        return\r\n      }\r\n      console.log(`stdout: ${stdout}`)\r\n    })\r\n  },\r\n  function() {\r\n    // console.log('xxx文件目录遍历完了')\r\n  }\r\n)\r\n复制代码在 package.json 里添加一条script:\"scripts\": {\r\n    \"scss\": \"node build/scss-convert\",\r\n  },\r\n复制代码"}
{"title": "小程序自定义组件之下拉菜单", "author": "Rolan", "time": "2020-5-6 00:23", "content": "图例中筛选是另外一个组件一般在筛选的场景中需要使用下拉菜单，动态设置筛选条件，比如淘宝，京东的产品筛选列表，携程的旅游目的地的筛选列表。支持配置化设置弹层内容支持动态刷新弹层内容支持动态修改分类标题支持遮罩层支持api关闭弹层配置wxml模板<view class=\"container\">\r\n  <ui-list list=\"{{tabConfig}}\" />\r\n</view>\r\n复制代码jsconst Pager = require('../../components/aotoo/core/index')\r\nconst mkDropdown = require('../../components/modules/dropdown')\r\n\r\nPager({\r\n  data: {\r\n    tabConfig: mkDropdown({\r\n      id: 'xxx',\r\n      data: [\r\n        {title: '选项-1'}, \r\n        {title: '选项-2'}, \r\n        {title: '选项-3'},\r\n        {title: '选项-3'},\r\n      ],\r\n      tap(data, index){\r\n        if (index === 0) {\r\n          this.updateContent({ ...checkListConfig })  // 配置弹层内容\r\n          let title = this.getTitle()\r\n        }\r\n      }\r\n    }),\r\n  },\r\n})\r\n复制代码updateContent更新的结构是一次性的，即再次打开时，实例维持不变，如果需要强制刷新，指定第二参数为true属性说明id{String}指定实例名称，在page中可通过this[id]找到实例data{Array}配置下拉菜单的列表，组件自动生成器对应的弹层tap{Function}下拉菜单项点击时的响应事件如何设置如何设置data数据data数组展示下拉菜单的所有菜单项，每一项必须为Object类型的数据，每一项数据可自定义，支持图片，文字，图片组，文字组等等菜单项由item组件构成，因此可以支持非常丰富的结构用于展示指定图片{img: 'path/to/imgsrc'}\r\n复制代码指定文字{title: '文字标题'}\r\n复制代码指定图文{title: '文字标题', img: 'path/to/imgsrc'}  \r\n\r\n// 更改图文顺序只需要把属性位置倒置  \r\n{img: 'path/to/imgsrc', title: '文字标题'}\r\n复制代码指定图组，文字组// 文字组\r\n{title: ['文字标题-1', '文字标题-2']}  \r\n\r\n// 图片组\r\n{img: [{src: 'path/to/imgsrc'}, {src: 'path/to/imgsrc'}]}\r\n复制代码同时也支持图组，文字组混排，根据需求如何获取实例当指定id后，便可以在page页中，方便的获取下拉菜单的实例，调用实例方法注意Pager和Page的区别，Page是微信小程序原生方法，Pager是对Page的二次封装，Pager支持原生Page的所有属性、方法，但反过来则不能支持mkDropdown({ id: 'xxx' })\r\n\r\n// 获取实例  \r\nPager({\r\n  onReady(){\r\n    const instance = this['xxx']\r\n    console.log(instance)\r\n  }\r\n})\r\n复制代码如何配置弹层内容通过tap响应方法支持，设置弹出内容和菜单项标题tap方法的上下文(context)环境updateContent{Function} 更新菜单项弹出层内容updateTitle{Function}更新菜单项标题getTitle{Function}获取当前菜单项标题mkDropdown({ \r\n  id: 'xxx',\r\n  data: [...],\r\n  tap(data, index){ // data为菜单项数据，index为菜单项位置  \r\n    if (index === 0) {  // 菜单栏第一项\r\n      this.updateTitle()  // 更新标题\r\n      // this.updateContent()  更新内容\r\n    }\r\n  }\r\n})\r\n复制代码更新弹出类容为列表下列配置，会在弹出框中渲染列表结构this.updateContent({\r\n  \"@list\": {\r\n    data: [\r\n      {title: '1'},\r\n      {title: '2'},\r\n    ]\r\n  }\r\n})\r\n复制代码更新弹出类容为表单下列配置，会在弹出框中渲染列表结构this.updateContent({\r\n  \"@form\": {\r\n    data: [\r\n      {title: '表单区域1', input: [...]},\r\n      {title: '表单区域2', input: [...]},\r\n    ]\r\n  }\r\n})\r\n复制代码更新弹出类容为多层筛选列表下列配置，会在弹出框中渲染列表结构this.updateContent({\r\n  \"@list\": mkChecklist({\r\n    ...\r\n  })\r\n})\r\n复制代码"}
{"title": "Spring Boot 整合微信小程序实现登录与增删改查", "author": "Rolan", "time": "2020-5-6 00:35", "content": "项目描述：在微信小程序中通过与Springboot操作数据库实现简单的增删改查，其中我是用springboot整合mybatis-plus 和mysql使用的1. 开发前准备1.1 前置知识java基础SpringBoot简单基础知识1.2 环境参数开发工具：IDEA基础环境：Maven+JDK8主要技术：SpringBoot、lombok、mybatis-plus、mysql 、微信小程序SpringBoot版本：2.2.62.开发者服务器项目结构：2.1 初始配置（1）pom.xml配置 <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-web</artifactId>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.mybatis.spring.boot</groupId>\r\n            <artifactId>mybatis-spring-boot-starter</artifactId>\r\n            <version>2.1.1</version>\r\n        </dependency>\r\n\r\n        <!--模板引擎-->\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\r\n        </dependency>\r\n\r\n        <!-- 引入阿里数据库连接池 -->\r\n        <dependency>\r\n            <groupId>com.alibaba</groupId>\r\n            <artifactId>druid</artifactId>\r\n            <version>1.1.14</version>\r\n        </dependency>\r\n\r\n        <!-- mysql依赖-->\r\n        <dependency>\r\n            <groupId>mysql</groupId>\r\n            <artifactId>mysql-connector-java</artifactId>\r\n            <version>5.1.42</version>\r\n            <scope>runtime</scope>\r\n        </dependency>\r\n\r\n        <!-- mybatisPlus 核心库 -->\r\n        <dependency>\r\n            <groupId>com.baomidou</groupId>\r\n            <artifactId>mybatis-plus-boot-starter</artifactId>\r\n            <version>3.1.0</version>\r\n        </dependency>\r\n\r\n        <!--生成实体成get set-->\r\n        <dependency>\r\n            <groupId>org.projectlombok</groupId>\r\n            <artifactId>lombok</artifactId>\r\n            <optional>true</optional>\r\n        </dependency>\r\n\r\n        <!-- pagehelper 分页插件 -->\r\n        <dependency>\r\n            <groupId>com.github.pagehelper</groupId>\r\n            <artifactId>pagehelper-spring-boot-starter</artifactId>\r\n            <version>1.2.5</version>\r\n        </dependency>\r\n\r\n        <!--junit 测试-->\r\n        <dependency>\r\n            <groupId>junit</groupId>\r\n            <artifactId>junit</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n            <exclusions>\r\n                <exclusion>\r\n                    <groupId>org.junit.vintage</groupId>\r\n                    <artifactId>junit-vintage-engine</artifactId>\r\n                </exclusion>\r\n            </exclusions>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n\r\n</project>\r\n（2）application.yml# Spring Boot 的数据源配置\r\nspring:\r\n  datasource:\r\n    name: wx\r\n    url: jdbc:mysql://localhost:3306/wx_mini_program?useUnicode=true&characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=true&serverTimezone=GMT%2B8\r\n username: root\r\n    password: root\r\n    # 使用druid数据源\r\n    type: com.alibaba.druid.pool.DruidDataSource\r\n    driver-class-name: com.mysql.jdbc.Driver\r\n    filters: stat\r\n    maxActive: 20 initialSize: 1 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: select 'x' testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 maxOpenPreparedStatements: 20 # mybatis-plus相关配置\r\nmybatis-plus:\r\n  # xml扫描，多个目录用逗号或者分号分隔（告诉 Mapper 所对应的 XML 文件位置）\r\n  mapper-locations: classpath:mapper/*.xml\r\n  # 以下配置均有默认值,可以不设置\r\n  global-config:\r\n    db-config:\r\n      #主键类型 AUTO:\"数据库ID自增\" INPUT:\"用户输入ID\",ID_WORKER:\"全局唯一ID (数字类型唯一ID)\", UUID:\"全局唯一ID UUID\";\r\n      id-type: auto\r\n      #字段策略 IGNORED:\"忽略判断\"  NOT_NULL:\"非 NULL 判断\")  NOT_EMPTY:\"非空判断\"\r\n      field-strategy: NOT_EMPTY\r\n      #数据库类型\r\n      db-type: MYSQL\r\n\r\n  # 指定实体类的包\r\n  type-aliases-package: com.ckf.login_wx.entity\r\n  configuration:\r\n    # 是否开启自动驼峰命名规则映射:从数据库列名到Java属性驼峰命名的类似映射\r\n    map-underscore-to-camel-case: true\r\n    # 如果查询结果中包含空值的列，则 MyBatis 在映射的时候，不会映射这个字段\r\n    call-setters-on-nulls: true\r\n    # 这个配置会将执行的sql打印出来，在开发或测试的时候可以用\r\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\r\n\r\n# PageHelper分页插件\r\npagehelper:\r\n  helperDialect: mysql\r\n  reasonable: true\r\n  supportMethodsArguments: true\r\n  params: count=countSql\r\n2.2 小程序用户表CREATE table users(\r\n id int not null PRIMARY key auto_increment,\r\n name varchar(255) not null,\r\n age int not null );\r\n\r\ninsert into users value(null,'陈克锋',18);\r\ninsert into users value(null,'陈克帅',11);\r\ninsert into users value(null,'陈克兵',14); select * from users;\r\n2.3 pojo2.4 mapper2.5 service2.5 serviceImpl配置SpringBoot扫描mapper2.6 controllerLoginControllerpackage com.ckf.login_wx.controller;\r\n\r\nimport org.springframework.web.bind.annotation.PostMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.Map; /**\r\n * @author 安详的苦丁茶\r\n * @date 2020/4/30 11:46 */ @RestController public class LoginController { /**\r\n     * 登录\r\n     * @param phone\r\n     * @param password\r\n     * @return */ @PostMapping(\"/doLogin\") public Map doLogin(String phone, String password){\r\n        Map map = new HashMap(); if ((phone.equals(\"10086\")&& password.equals(\"123456\"))){\r\n            map.put(\"code\",200);\r\n            map.put(\"result\",\"登录成功\");\r\n            System.out.println(\"登录成功\");\r\n        }else {\r\n            map.put(\"result\",\"no\");\r\n        } return map;\r\n    }\r\n\r\n}\r\nUserControllerpackage com.ckf.login_wx.controller;\r\n\r\nimport com.ckf.login_wx.entity.User;\r\nimport com.ckf.login_wx.servic.UserService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.web.bind.annotation.*; /**\r\n * @author 安详的苦丁茶\r\n * @date 2020/4/30 13:39 */ @RestController\r\n@RequestMapping(\"/test\") public class UserController {\r\n\r\n    @Autowired private UserService userService; /**\r\n     * 查询全部\r\n     * @return */ @GetMapping(\"/list\") public Object list(){\r\n        System.out.println(\"查询成功\"); return userService.list();\r\n    } /**\r\n     * 根据id删除\r\n     * @param id\r\n     * @return */ @GetMapping(\"/delete\") public boolean delete(Integer id){\r\n        System.out.println(\"删除成功\"); return userService.removeById(id);\r\n    } /**\r\n     *  根据id查询\r\n      * @param id\r\n     * @return */ @GetMapping(\"/byid\") public Object byid(Integer id){\r\n        System.out.println(\"查询成功\"); return userService.getById(id);\r\n    } /**\r\n     *  修改\r\n     * @param user\r\n     * @return */ @PostMapping(\"/update\") public boolean update(@RequestBody User user){\r\n        System.out.println(\"修改成功\"); return userService.updateById(user);\r\n    } /**\r\n     * 添加\r\n     * @param user\r\n     * @return */ @PostMapping(\"/add\") public boolean add(@RequestBody User user){\r\n        System.out.println(\"添加成功\"); return userService.save(user);\r\n    }\r\n\r\n}\r\n3. 微信小程序项目结构：3.1 初始配置3.2 bing.wxml<!--pages/bind/bind.wxml-->\r\n<view>\r\n\r\n  <form bindsubmit='doLogin'>\r\n            <!--账号-->\r\n            <view class=\"inputView\">\r\n\r\n                <label class=\"loginLabel\">账号</label>\r\n                <input name=\"phone\" value='10086' class=\"inputText\" placeholder=\"请输入账号\" />\r\n            </view>\r\n            <view class=\"line\"></view>\r\n\r\n            <!--密码-->\r\n            <view class=\"inputView\">\r\n\r\n                <label class=\"loginLabel\">密码</label>\r\n                <input name=\"password\" value='123456' class=\"inputText\" password=\"true\" placeholder=\"请输入密码\" />\r\n            </view>\r\n            <view class=\"line\"></view>\r\n            <!--按钮-->\r\n            <view class='backColor'>\r\n                <button class=\"loginBtn\" formType=\"submit\"  open-type='getUserInfo' >登录</button>\r\n            </view>\r\n\r\n            <!-- <view>\r\n                <button class=\"goRegistBtn\" type=\"warn\" open-type='getUserInfo' bindgetuserinfo='doLogin'>微信登录</button>\r\n            </view> -->\r\n        </form>\r\n\r\n</view>\r\n3.3 bing.js3.3 list.wxml<!--pages/list/list.wxml-->\r\n  <button class=\"add\" type='primary' bindtap='addArea'>添加</button>\r\n<view class=\"container\">\r\n  <view class='widget'>\r\n    <text class='column'>编号</text>\r\n    <text class='column'>姓名</text>\r\n    <text class='column'>年龄</text>\r\n    <text class='link-column'>操作</text>\r\n  </view>\r\n  <scroll-view scroll-y=\"true\">\r\n    <view>\r\n      <block wx:for='{{list}}'>\r\n      <view class='widget'> \r\n        <text class='column'>{{item.id}}</text>\r\n        <text class='column'>{{item.name}}</text>\r\n         <text class='column'>{{item.age}}</text>\r\n        <view class='link-column'>\r\n          <navigator class='link' url='../operation/operation?id={{item.id}}'>编辑</navigator> |\r\n          <text class='link' bindtap='deleteArea' data-areaid='{{item.id}}' data-areaname='{{item.name}}' data-index='{{index}}'>删除</text>  \r\n        </view>\r\n        </view>      \r\n      </block>\r\n    </view>\r\n  </scroll-view>\r\n\r\n</view>\r\n3.4 list.js// pages/list/list.js\r\nPage({ /**\r\n   * 页面的初始数据 */ data: {\r\n    list:[]\r\n  }, /**\r\n   * 生命周期函数--监听页面加载 */ onLoad: function (options) {\r\n\r\n  }, /**\r\n   * 生命周期函数--监听页面初次渲染完成 */ onReady: function () {\r\n\r\n  }, /**\r\n   * 生命周期函数--监听页面显示 */ onShow: function () { var that=this;\r\n    wx.request({\r\n      url: 'http://localhost:8080/test/list',\r\n      method:'GET',\r\n      data:{},\r\n      success:function(res){ var list=res.data; if(list==null){ var toastText='获取数据失败';\r\n          wx.showToast({\r\n            title: toastText,\r\n            icon:'',\r\n            duration:2000 //弹出时间\r\n })\r\n        }else{\r\n          that.setData({\r\n            list:list\r\n          })\r\n        }\r\n      }\r\n    })\r\n  }, /**\r\n   * 生命周期函数--监听页面隐藏 */ onHide: function () {\r\n\r\n  }, /**\r\n   * 生命周期函数--监听页面卸载 */ onUnload: function () {\r\n\r\n  }, /**\r\n   * 页面相关事件处理函数--监听用户下拉动作 */ onPullDownRefresh: function () {\r\n\r\n  }, /**\r\n   * 页面上拉触底事件的处理函数 */ onReachBottom: function () {\r\n\r\n  }, /**\r\n   * 用户点击右上角分享 */ onShareAppMessage: function () {\r\n\r\n  },\r\n  addArea:function(){\r\n    wx.navigateTo({\r\n      url:'../operation/operation' })\r\n  },\r\n  deleteArea: function (e) { var that=this;\r\n    wx.showModal({\r\n      title: '提示',\r\n      content: '确定要删除[' + e.target.dataset.areaname +']吗？',\r\n      success:function(sm){ if(sm.confirm){\r\n          wx.request({\r\n            url: 'http://localhost:8080/test/delete',\r\n            data: { id: e.target.dataset.areaid},\r\n            method:'GET',\r\n            success:function(res){ var result=res.statusCode; var toastText=\"删除成功\"; if(result!=200){\r\n                toastText = \"删除失败\";\r\n              }else{\r\n                that.data.list.splice(e.target.dataset.index,1);\r\n                that.setData({\r\n                  list:that.data.list\r\n                });\r\n              }\r\n              wx.showToast({\r\n                title: toastText,\r\n                icon:'',\r\n                duration:2000 });\r\n            }\r\n          })\r\n        }\r\n      }\r\n    })\r\n\r\n  }\r\n})\r\n3.5 app.json{ \"pages\": [ \"pages/bind/bind\", \"pages/list/list\", \"pages/logs/logs\", \"pages/operation/operation\", \"pages/index/index\" ], \"window\": { \"backgroundColor\": \"#F6F6F6\", \"backgroundTextStyle\": \"light\", \"navigationBarBackgroundColor\": \"#29d\", \"navigationBarTitleText\": \"login\", \"navigationBarTextStyle\": \"black\" }, \"sitemapLocation\": \"sitemap.json\", \"style\": \"v2\" }\r\n4. 测试启动开发者服务器，启动SpringBoot的main方法。打开微信小程序开发者工具登录页面首页添加页面修改页面删除到处基本的增删改查操作已经完成了如有需要前往 Gitee（码云）下载前台：https://gitee.com/ckfeng/applet_of_wechat.git后台：https://gitee.com/ckfeng/wx_login.git作者：安详的苦丁茶链接：cnblogs.com/ckfeng/p/12812214.html-END-"}
{"title": "企业数字化转型，都开始做私域流量转投小程序直播了？", "author": "Rolan", "time": "2020-5-7 00:01", "content": "直播带货，为电商营销赋予创新红利。这是直播带货大行其道，为电商营销赋予创新红利的泛商业时代，尤其在2020年这场疫情期间，突显出了巨大的商业价值，给企业数字化转型自救提供了便捷的途径。尽管眼看有人一场直播带货，销售过亿，也有人坐拥百万流量但成交寥寥无几，甚至还有人直播当场翻车，惨遭滑铁卢，但商户和品牌主们追逐直播带货的热情从未停下来，争先恐后地闯进了这片红海，寄望真金白银的投放能换来一个网红品牌，又或者实现销量暴增的目标。一、直播带货注定烽火燎原在疫情这层阴影的笼罩下，首当其冲的就是零售业企业。从CCFA中国经营连锁协会获取的数据来看，疫情期间门店关店率高达70%以上，业绩普遍下滑超过90%，员工闲置在家的情况比比皆是。遭受突如其来的黑天鹅事件，处于冰封状态的零售业，自救回血就是首要目标，于是转投直播获取流量卖货，成为了顺理成章的重要选择。2019年双11，淘宝直播带货销售额1天就突破200亿元，这让所有商户都看到了直播带货的威力和潜力。而且，有权威机构指出，预计2020全年主流直播电商平台，全年带货金额将突破4000亿元。所以，直播带货在2020年注定是烽火燎原的。二、始于流量，终于运营1.直播带货：货找人，更高效直播带货的出现，正在加速改变互联网的供需关系。从人货场的角度去看，直播工具创造出了全新的消费场景，承载了在线沟通的功能，能直接地传递品牌的观念，依托电商平台的服务保障，能充分地给用户带来顺畅的购买体验。可见，直播带货改变了过去电商行业人找货的模式，实现了交易更高效的货找人模式。正是因为如此，互联网巨头不可能错失这个分一杯羹的机会，纷纷入局沉浸在这场流量红利的狂欢之中，不断推出一系列扶持计划，让更多品牌和商户加入这场流量博弈的游戏。2.直播带货：拼流量，更要拼运营和管理在这股全民直播的浪潮下，流量似乎是万能的。然而，有些问题并非流量所能解决的，所有人也千万别寄望流量能解决电商卖货的所有问题。主播带不动货，怎么办？为什么直播间观看人数不够多，实时在线人数增长缓慢？直播间进来的粉丝不精准，互动低，新增粉丝也不多，如何解决？进来直播间的粉丝很快又离开了，流失率很高，有哪些方法可应对？归根到底，直播带货离不开运营和管理，毕竟互联网是依靠多方面的运营管理手段来实现商业系统持续产生效益。众所周知，广告投放的方式能够带来大批精准的流量，当中就需要不断对广告投放进行精细化运营和优化，根据目标用户分类理解人群价值，针对性地进行定向的广告投放。例如品类内容关注的用户，未曾有过直播相关的行为，那么就应该把运营的重心放在如何合理利用对品类内容的关注，来引导到直播间，最终把看播和加粉作为运营的目标。再例如选品的管理，除了要考虑成本和供应链的能力，还要考虑商品是否具备成为爆款的潜力，一旦商品能成为爆款，那意味着用户会复购，对店铺的粘性也会更强，有利于带动其他商品销售。如果商品销量一般，商品的更替计划也要提前准备好。而且，随着商品的转化成交不断提升，就会沉淀下来更丰富的数据，能够为后续的广告投放提供更精准可靠的依据。毫无疑问，直播带货拼的不只是流量，要持续产生价值，还要拼运营和管理，遵循互联网商业的常识和发展规律。三、小程序直播，已成为电商必争之地纵观当下，传统电商平台的直播带货如火如荼，头部和腰部主播的热度高企，坑位费普遍上涨，卖货的佣金比例也有所增加，因此按照二八法则，后入者门槛相对变高。于是，不少商户和品牌主把小程序作为直播带货的第二战场，因为背靠微信成熟的生态和巨大的流量池，具备强社交和易传播的优势，借力小程序能够高效连接线上和线下，把零售电商的核心要素（即人流、信息流、资金流、物流）充分联结起来，实现私域流量池的建立和变现。1. 小程序直播的护城河(1)原生优势，获客效率更高使用即安装，更有效留存，留存才是真正的增长；多种访问路径，用户更方便回访，可随时触达用户；具备广告、搜索功能，意味着拥有更丰富的流量入口，可推送开播预告、秒杀活动等信息。可见，直播小程序相对其他直播平台而言，获客效率是更高的。(2)从引爆私域流量开始，实现流量沉淀在直播开播前，商户可以通过朋友圈、社群、公众号消息模板引导用户关注直播间，开播前收到提醒，提前激活私域流量，锁住忠诚客户；商户还能引导用户关注公众号，持续积累私域流量，多通道触达粘性更高，也方便后续对用户进行二次营销，可利用多元化的会员玩法，增进复购。在开播进行的过程中，直播间广告位还可以导流到商城小程序，引导用户跳转到商城里面选购商品，提升了单uv的价值，最终完成私域流量沉淀。(3)借助营销工具组合，提升成交效率在微信生态里，分销、砍价这些常见的营销工具都可以为直播小程序提供有效的帮助，能让观众主动分享转发，达到刺激购买的目的。商户还可以通过优惠券和秒杀的方式，吸引更多的用户下单，同时在直播间还可以发放礼盒小奖品，提升用户留存，有利于促成交易。(4)处于封闭的生态循环，赋能数据决策直播小程序，与小程序商城、社群、公众号、支付、社交广告，共同构成了微信的封闭生态。微信生态的一体化加速了变现的同时，也为用户管理、渠道管理、运营策略的数据决策提供了必要的支撑。所以，我们可以结合流量监控、推广效果跟踪、成交分析等来评估每场直播带货的活动效果，进行复盘和优化，基于数据结果，为后续直播策划提供更好的决策。(5)不止直播，引流到店对于品牌主而言，人货场都是数字化经营，线上直播带货不仅是高效的传播推广方式，触达广大的消费者，给线下门店带来流量，还能从用户消费和商品热销数据里洞察到品牌的市场反馈，能够为线下门店的商品经营提供参考依据。对于商户而言，线上直播带货的流量当沉淀成为私域流量后，可导入到线下门店，提高门店流量，帮助线下门店更好卖货，实现线上线下一体化联动。2. 小程序直播，本质是私域流量直播疫情考验了企业的造血自救能力，尤其很多企业在预算非常有限的情况下，没有选择网红主播和MCN机构来做直播带货，纷纷让自家的员工、门店导购利用小程序做直播带货，小程序直播无疑提供了企业快速实现数字化的通道。(1)小程序直播，普通素人的最佳秀场小程序直播确实很适合品牌商员工、门店导购等普通素人，因为他们对用户和产品非常熟悉，具备丰富的销售技巧，基于微信的熟人社交关系，更容易互动，提升转化成交。而且，公众号、消息模板、菜单、小程序商城、社群、朋友圈都可以直接成为直播活动的流量入口，再配合微信的裂变和推广，还有门店海报的二维码，最终构成了小程序直播得天独厚的条件。(2)小程序直播，私域流量的复用利器不难发现，这些天然的流量入口，在直播还没到来之前，就已经成为触达用户的私域矩阵，所以小程序直播是提升了微信生态流量资源的利用率，并且借助小程序直播，还能反哺社群、朋友圈、公众号这些私域流量得到不断壮大，形成螺旋式上升的增长趋势，从而更有力地推动微信生态流量持续变现，体现出了复利，完全符合微信生态的价值主张。由此看来，小程序直播，就是私域流量直播。从人货场的角度去看，微信生态这个场提供了多层面和多渠道的推广触点入口，不管是KOC、社群还是品牌官方和门店对个人用户而言，都是属于本来就存在的私域流量关系，并且还可以基于社交关系链产生多次裂变传播，这是只有微信才拥有的壁垒。所以，小程序直播是复用了这些私域流量，与直播平台+网红主播+MCN机构的模式相比，最显著的区别就在于让品牌商的员工和门店导购，替代了网红主播和MCN机构。其实，两种模式各有优势，网红主播和MCN机构这样的公域流量能带来强曝光，可以帮助品牌打响品宣的第一枪，配合话题营销，很容易被广泛认识；员工和导购的小程序直播，会把销量作为首要目标，凭借微信的私域流量可进行高频互动和触达，不断积累用户信任，加强用户与品牌的粘性，配合多元化的促销玩法，最终能实现销售业绩倍增。值得一说的是，朋友圈广告也能把流量引导到小程序的直播间，通过精准的投放，能带来强流量和强转化，这也是基于私域流量所展开的营销动作，当中需要品牌主对目标消费群体有深度的洞察，辅以创意内容和优化投放，来充分实现品效合一。四、品牌企业的新增长：小程序直播与私域流量双驱动1. Cabbeen卡宾服饰，7天1500W+销售额疫情期间，很多零售企业正遭受着不同程度的冲击，都纷纷启动了线上直播带货，Cabbeen卡宾服饰也不例外，选择了小程序直播的方式。据官方透露，直播以来共有280万+人观看、新增会员45w人，并创下了38秒成交金额高达100w、7天销售额突破1500w的记录，领跑全国小程序男装类目。Cabbeen卡宾服饰直播卖货之所以取得这么夺目的成绩，我认为可以归结为充分利用了私域流量的优势：(1)激励导购和员工，通过社群和朋友圈开展全员分销(2)根据社群的活跃度，进行精细化的分层运营(3)发起秒杀、抽奖、大转盘等互动活动增强了社群用户粘性(4)小程序直播结合社群，使用优惠券、赠品等激励手段，促进用户下单Cabbeen卡宾服饰小程序直播&社群抢购Cabbeen卡宾服饰通过私域流量运营和小程序直播，与消费者之间搭建起了高效的营销互动场景，在零售实体门店受疫情影响的情况下，无疑创造了新的增长，相信这能够给更多零售企业带来启发，为业务升级转型提供了可借鉴的思路和方法。2.梦洁家纺，4小时2500W+销售额梦洁家纺通过小程序直播卖货的方式，也同样达成了相当亮眼的业绩：130万+的在线观看人数，其中近60W人同时在线，最终4个小时完成了2500多万销售额。梦洁家纺从直播创建、流量获取以及交易转化的营销闭环，都做足了准备：(1)在直播开始前，让门店导购将线下流量快速导入线上社群(2)在朋友圈、社群预告直播内容，导购负责在群里介绍商品(3)直播开启后，群里发起砍价活动，让用户积极分享出去，形成裂变传播(4)直播间发放秒杀和限时折扣券，刺激用户把商品加入到购物车(5)在评论区与用户互动，活跃直播间氛围，激发用户购买欲望(6)直播结束后，采用了直播回放功能，让用户在回顾直播的过程中下单购买梦洁家纺直播间及互动梦洁家纺直播带货的销量持续上涨，全靠私域流量的推动，直面用户的门店导购、社群、朋友圈等多样化的社交触点一直都在为小程序直播的推广和转化，快速蓄积了流量，最终让直播的投入获得最大化的回报。相信梦洁家纺的小程序直播案例，能让品牌主理解，私域流量运营得当，可改进流量获取和直播推广的效率。五、小程序直播，释放私域流量新价值当企业逐渐建设了自己的私域流量池，往往会遇到一个很现实的问题，那就是如何与用户进行有效的互动，实现用户留存的转化。别简单以为建立了社群，在群里发放优惠折扣，发起拼团砍价的活动，就是在做私域流量运营。不难理解，用户也不会喜欢这样轰炸式的内容推送，非常容易引起反感，最终就是退出社群。小程序直播的出现，是私域流量运营的一个重要拐点。因为小程序直播离用户很近，可以有效形成社交互动，直播内容从而承接和转化了私域流量。通过小程序直播，企业能直接地给用户传递最新的品牌动态，进行友好的双向互动交流，从交易数据中能洞察到用户对品牌的喜好，这把私域流量的价值发挥到极致。直播已经成为营销增长的利器，尤其依靠在微信生态下的小程序直播，对企业实现数字化增长而言具有战略性的意义，当中私域流量作为触点的重要载体，我们有必要深入了解小程序直播的私域流量运营全链路，更好把握转化关键。1.蓄量环节企业的私域流量池，通常由门店导购微信号、自建社群、公众号粉丝、小程序的自然流量组成。所以，朋友圈、社群、公众号的直播预告必不可少，可以邀约用户进群领取优惠券等福利，观看直播，提前锁定用户。即使用户错过直播，在社群里发起抢购活动还是能刺激用户下单的。 服务号的消息模板也能提醒用户，可引导用户添加直播助手的微信号，然后邀请进群。2.增量环节蓄量环节过后，我们该思考如何持续为直播间带来新的流量，这就是增量环节的任务。有吸引力的内容再加上高频的互动，会更容易让用户产生裂变的行为，从而传播引进新的流量，比如直播间的抽奖和砍价，就能够让直播间的用户，主动转发邀请好友参与。举个例子，当前直播间的在线观看人数8万，我们可以告诉直播间里的用户，如果超过10万，将会抽出万元大奖，那么用户就会积极分享直播间的海报到朋友圈。显然，直播间的增量会因为庞大的蓄量基础而实现快速的增长，可见蓄量水平能影响增量的增长空间。另外，在预算充足的前提下，还可以在朋友圈投放精准的微信社交广告，直接引流到直播间，这也是非常有效的方法。3.转化环节在转化环节中，除了秒杀、优惠券和买增的方式，我认为有几个要素可以提升转化，使直播带货的效益最大化。(1)加强对导购的激励，实行分销导购员对于商品和消费者心理都非常了解，因此导购完全有能力去转化直播间和朋友圈以及社群这些私域的流量，只需要制定好佣金策略，导购就会有更强的意愿去卖货。一般建议佣金比例可以按完成的销售额分为几个等级，业绩越好，等级越高，佣金比例越高，导购的动力更大，从而形成正向的循环。与此同时，业绩突出的导购可以作为全员学习的榜样和标杆，让其他人学习到有用的卖货技巧，这样能给到导购精神层面的激励，还可以带动整个团队氛围做好业务。(2)加强直播间互动，提升留存互动的方式有很多种，例如直播间不定时抽奖，能减少用户流失离开直播间；又或者直播间点赞量超过多少，送出福利回馈给直播间的用户等。总之，不能让直播间冷场，要营造出很热闹的氛围，增进用户留存，激发用户消费的冲动情绪。(3)提供直播回放，持续转化在直播结束后，可以把直播回放链接发到社群里，借助直播的余温让用户感知最后的优惠抢购机会，这样也有助于促使用户转化，带来销量持续增长。六、结束语艾瑞咨询权威的调查数据表明，直播可预见是一个万亿规模的市场，这意味着是各家品牌和企业空前难得的大好机遇，绝不能视而不见的红利。作为高度依赖社交传播的场景，直播必然能够与微信生态形成高效的商业适配，因此基于私域流量的小程序直播具备了先天优势，这是其他直播平台无法比拟的，因此小程序直播将会引领各家企业走进直播2.0时代。历史总是相似的，回望中国移动互联网的发展史，业态日趋成熟的背后总是离不开生态布局者与其战略伙伴的携手合作，当前微信生态与微盟这类第三方解决方案服务商共同赋能企业加快数字化转型，私域流量和小程序直播正是当打之处。黑天鹅冲击之下，数字化浪潮已掀起，没有谁愿意掉队，这是一个人人都需要深耕私域流量，完成小程序直播良性互动闭环的商业时代。-END-"}
{"title": "python实现小程序推送页面收录", "author": "Rolan", "time": "2020-4-21 00:11", "content": "小程序搜索推送接口： developers.weixin.qq.com/miniprogram…小程序获取assess_token： developers.weixin.qq.com/miniprogram…当时看到小程序页面收录的时候也是很恍然，一直都没有怎么注意到这个东西，直到加了微信小程序社区的官方群才看到有人提及这个东西，索性点进去看了一下，发现收录页面达到了17万，应该不算太多，属于爬虫自然收录。也有过人问过我怎么做收录的，真的，就是自然收录，无非是详情页比较重要而已，因为参数的不同收录肯定会增多很多，前提是不要随意的拦截用户登录。当然也和朋友交流过这方面的东西，后面发现收录是周期性的，大概是间隔7天左右会有一次上涨，所以过了几天之后涨了4万达到了21万。但是他们都是页面推送的收录，我去看了下发现我们的是一个推送收录都没有，然后大概的问了问自己就写了一份推送收录的Python脚本。废话过多直接上代码吧，如有不足之处还望指教。import requests\r\nimport math\r\nimport time\r\nimport json\r\n\r\n\"\"\"\r\n@author: axin\r\n@time:2019/12/14 14:30\r\n@File: smpush.py\r\n\"\"\"\r\n\r\n# 设置配置信息\r\nappid = \"\"     # 小程序appid\r\nsecret = \"\"    # 小程序secret\r\nsn = 990        # 每次推送数量\r\ntimer = 5      # 每次睡眠时间\r\n\r\n\r\n# 获取小程序assess_token\r\ntokenUrl = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid={}&secret={}\".format(appid, secret)\r\ntokenReq = requests.get(tokenUrl)\r\ntokenResp = tokenReq.json()\r\ntoken = tokenResp['access_token']\r\n\r\n# 拼接推送链接\r\nurl = \"https://api.weixin.qq.com/wxa/search/wxaapi_submitpages?access_token={}\".format(token)\r\n\r\n# 获取小程序招工推送列表\r\npostData = {\r\n    \"access_token\": token,\r\n    \"pages\": []\r\n}\r\n\r\n#读取所有待推送信息\r\nwith open('ids.txt', 'r') as f:\r\n    ids = f.read()\r\n    ids = ids.split(\",\")   # 切割成数组保存\r\n    idsLen = len(ids)      # 获取数组长度\r\n    maxGroup = math.ceil(idsLen / sn)  # 最大的分组数量\r\n    group_m = -1\r\n    lists = []   # 使用新数组保存\r\n    for i in range(idsLen):\r\n        if i % sn == 0:\r\n            group_m += 1\r\n            lists.append([ids[i]])\r\n        else:\r\n            lists[group_m].append(ids[i])\r\n\r\n\r\n    #分组推送\r\n    sign = 0  # 标记当前推送条数\r\n    for item in lists:\r\n        arrData = []  # 声明或重置待提交数组\r\n        for i in item:\r\n            data = {\r\n                \"path\": \"pages/detail/info/info\",\r\n                \"query\": \"id=\" + i\r\n            }\r\n            arrData.append(data)\r\n\r\n        postData['pages'] = arrData\r\n        onceReq = requests.post(url, json.dumps(postData))\r\n        onceRes = onceReq.json()\r\n        signStart = sign * sn\r\n        signEnd = (sign * sn) + sn\r\n        if onceRes['errcode'] == 0:\r\n            print(\"当前推送第{} - {} 条：成功！最后一条数据为：{}\".format(signStart, signEnd, arrData[-1]))\r\n        elif onceRes['errcode'] == 47006:\r\n            print(\"当前推送第{} - {} 条：失败！返回状态码：{},最后一条数据为：{}, 当日推送已达到最大上限！\".format(signStart, signEnd, onceRes['errcode'], arrData[-1]))\r\n            break\r\n        else:\r\n            print(\"当前推送第{} - {} 条：失败！返回状态码：{},最后一条数据为：{}\".format(signStart, signEnd, onceRes['errcode'], arrData[-1]))\r\n\r\n        sign += 1\r\n        time.sleep(timer)  # 设置睡眠时间\r\n\r\n\r\n复制代码还有一个参数文本，由于id过多就将id导入了一个txt,然后读取之后用\",\"进行了一次分割。感谢@克隆:sheep:多利建议改了Python的format以及下掉eval如有错误或者探讨欢迎留言，看到必回。最后也祝大家的页面尽早收录。"}
{"title": "小程序瀑布流的实践", "author": "Rolan", "time": "2020-4-21 00:21", "content": "前言：最近在工作中，实践了下在 微信小程序中实现瀑布流列表(左右两栏，动态图文) ，最终的效果还不错，所以在此记录，仅供有需要的人参考。最终的效果：补充说明的是,要做瀑布流，最好是可以知道图片的高度，由接口下发，来提前占位，否则，即使是原生app，也会因为图片的加载闪屏使得不好的用户体验。在小程序中，没有原生app的流式layout控件，所以不知道图片宽高的情况下，只能减少每一页的page_size，在加载完图片之后，再计算插入的位置（对产品来说，这可能是一个不可接受的漫长过程）尝试过的小程序瀑布流实现方式1.左右两列判断奇偶性渲染//demo.js\r\n\r\nPage({\r\n    data:{\r\n        renderLists:[]\r\n    },\r\n    fetchData(){\r\n        request(url,params).then(res=>{\r\n            const PreData=this.data.renderLists\r\n            this.setData({\r\n                renderLists:PreData.concat(res)\r\n            })\r\n        })\r\n    }\r\n})\r\n//demo.wxml\r\n<view class=\"waterfall\">\r\n    <view class=\"waterfall__left\">\r\n        <your-compoent \r\n            wx:for=\"{{renderLists}}\"\r\n            wx:key=\"id\"\r\n            wx:if=\"{{index % 2 === 0}}\"\r\n        />\r\n    </view>\r\n    <view class=\"waterfall__right\">\r\n        <your-compoent \r\n            wx:for=\"{{renderLists}}\"\r\n            wx:key=\"id\"\r\n            wx:if=\"{{index % 2 === 1}}\"\r\n        />\r\n    </view>\r\n</view>说明优点缺点左右列重复wx:for 渲染数据，根据index索引的奇偶性来wx:if简单1.重复for循环。2.如果每个item高度相差较大，很容易造成左右矮的那一栏是部分空白的或许京东购物小程序-首页就是这样做的?（不确定）2.绝对定位这个方式可能就是目前pc端的实现方式，原理都一样。但是在小程序中，有以下几个需要解决的问题如果列表是动态图文，即使知道图片宽高，如何获取文字内容区域的高度？安卓下实验过会出现白屏，卡顿等性能问题（这个问题导致直接放弃了这个做法）3.左右两列计算插入渲染//demo.js\r\n\r\nPage({\r\n    data:{\r\n        leftLists:[],\r\n        rightLists:[]\r\n    },\r\n    onLoad(){\r\n        this.leftHeight=0\r\n        this.rightHeight=0\r\n    },\r\n    fetchData(){\r\n        request(url,params).then(res=>{\r\n            this.generate(res)\r\n        })\r\n    },\r\n    generate(list){\r\n        let leftList=[],rightList=[]\r\n        list.map(async (item)=>{\r\n            //每个item的高度=图片宽高+内容区域\r\n            const itemHeight=getImageHeight(item)+getContentHeight(item)+gap\r\n            this.leftHeight>this.rightHeight?rightList.push[item]:leftList.push(item)\r\n        })\r\n        this.render({leftList,rightList})\r\n    },\r\n    getImageHeight(){\r\n        //如果知道图片宽高，就return item.height\r\n        //如果不知道，wx.getImageInfo(需要配合域名)或者通过display:\"node\" image 然后 bindload。\r\n    },\r\n    getContentHeight(){\r\n        //文字内容区域高度固定，直接返回\r\n        //不固定，做数据映射，例如10个字一行，行高按照设计稿，做rpxToPx返回\r\n    },\r\n    render(params){\r\n        const {leftList,rightList}=params\r\n        const preLeft=this.data.leftList;\r\n        const preRight=this.data.rightList\r\n        this.setData({\r\n            leftList:preLeft.concat(leftList),\r\n            rightList:preRight.concat(rightList)\r\n        },()=>{\r\n             const query = this.createSelectorQuery(); \r\n       query.select('.wrapper__left').boundingClientRect();\r\n      query.select('.wrapper__right').boundingClientRect(); \r\n           query.exec((res) => {\r\n             this.leftHeight = res[0].height; \r\n             this.rightHeight = res[1].height;\r\n           });\r\n        })\r\n    }\r\n})\r\n//demo.wxml\r\n<view class=\"waterfall\">\r\n    <view class=\"waterfall__left\">\r\n        <your-compoent \r\n            wx:for=\"{{leftLists}}\"\r\n            wx:key=\"id\"\r\n        />\r\n    </view>\r\n    <view class=\"waterfall__right\">\r\n        <your-compoent \r\n            wx:for=\"{{rightLists}}\"\r\n            wx:key=\"id\"\r\n        />\r\n    </view>\r\n</view>说明优点缺点下面↓↓↓性能好，实现的效果好(⊙o⊙)…注意下面的操作都必须是一个同步获取的过程，需要异步获取的都要async await,如果需要异步获取的数据多，例如图片，那就是一个耗时操作\r\n可能有小概率会影响我们的计算，这个问题是存在的且可以接受的\r\ncreateSelectorQuery\r\n可以看下小程序 附近的餐厅 ，效果很好，他的图片宽高是服务器返回的，文字内容区域是固定的（标题只有几个字，也是两行）结论目前来说，第三种方案的实现效果最好，也是我们正在线上使用的方式，推荐使用。"}
{"title": "微信小程序工程化探索之webpack实战", "author": "Rolan", "time": "2020-4-21 00:37", "content": "微信小程序因为其便捷的使用方式，以极快的速度传播开来吸引了大量的使用者。市场需求急剧增加的情况下，每家互联网企业都想一尝甜头，因此掌握小程序开发这一技术无疑是一名前端开发者不可或缺的技能。但小程序开发当中总有一些不便一直让开发者诟病不已，主要表现在：初期缺乏方便的npm包管理机制（现阶段确实可以使用npm包，但是操作确实不便）不能使用预编译语言处理样式无法通过脚本命令切换不同的开发环境，需手动修改对应环境所需配置（常规项目至少具备开发与生产环境）无法将规范检查工具结合到项目工程中（诸如EsLint、StyleLint的使用）有了不少的问题之后，我开始思考如何将现代的工程化技术与小程序相结合。初期在社区中查阅资料时，许多前辈都基于gulp去做了不少实践，对于小程序这种多页应用来说gulp的流式工作方式似乎更加方便。在实际的实践过后，我不太满意应用gulp这一方案，所以我转向了对webpack的实践探索。我认为选择webpack作为工程化的支持，尽管它相对gulp更难实现，但在未来的发展中一定会有非凡的效果，实践我们先不考虑预编译、规范等等较为复杂的问题，我们的第一个目标是如何应用webpack将源代码文件夹下的文件输出到目标文件夹当中，接下来我们就一步步来创建这个工程项目：/* 创建项目 */\r\n$ mkdir wxmp-base\r\n$ cd ./wxmp-base\r\n/* 创建package.json */\r\n$ npm init\r\n/* 安装依赖包 */\r\n$ npm install webpack webpack-cli --dev\r\n复制代码安装好依赖之后我们为这个项目创建基础的目录结构，如图所示：上图所展示的是一个最简单的小程序，它只包含 app 全局配置文件和一个 home 页面。接下来我们不管全局或是页面，我们以文件类型划分为需要待加工的 js 类型文件和不需要再加工可以直接拷贝的 wxml 、 wxss 、 json 文件。以这样的思路我们开始编写供webpack执行的配置文件，在项目根目录下创建一个build目录存放webpack.config.js文件。$ mkdir build\r\n$ cd ./build\r\n$ touch webpack.config.js\r\n复制代码/** webpack.config.js */\r\nconst path = require('path');\r\nconst CopyPlugin = require('copy-webpack-plugin');\r\n\r\nconst ABSOLUTE_PATH = process.cwd();\r\n\r\nmodule.exports = {\r\n  context: path.resolve(ABSOLUTE_PATH, 'src'),\r\n  entry: {\r\n    app: './app.js',\r\n    'pages/home/index': './pages/home/index.js'\r\n  },\r\n  output: {\r\n    filename: '[name].js',\r\n    path: path.resolve(ABSOLUTE_PATH, 'dist')\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        use: {\r\n          loader: 'babel-loader',\r\n          options: {\r\n            presets: ['@babel/preset-env'],\r\n            plugins: ['@babel/plugin-transform-runtime'],\r\n          },\r\n        },\r\n      }\r\n    ]\r\n  },\r\n  plugins: [\r\n    new CopyPlugin([\r\n      {\r\n        from: '**/*.wxml',\r\n        toType: 'dir',\r\n      },\r\n      {\r\n        from: '**/*.wxss',\r\n        toType: 'dir',\r\n      },\r\n      {\r\n        from: '**/*.json',\r\n        toType: 'dir',\r\n      }\r\n    ])\r\n  ]\r\n};\r\n复制代码在编写完上述代码之后，为大家解释一下上述的代码究竟会做些什么：入口 entry 对象中我写了两个属性，意在将 app.js 和 home/index.js 作为webpack的构建入口，它会以这个文件为起始点创建各自的依赖关系，这样当我们在入口文件中引入其他文件时，被引入的文件也能被webpack所处理。module 中我使用了 babel-loader 对 js 文件进行ES6转换为ES5的处理，并且加入了对新语法的处理，这样我们就解决了在原生小程序开发中总是要反复引入 regenerator-runtime 的问题。（这一步我们需要安装 @babel/core 、 @babel/preset-env 、 @babel/plugin-transform-runtime 、 @babel/runtime 、 babel-loader 这几个依赖包）使用 copy-webpack-plugin 来处理不需要再加工的文件，这个插件可以直接将文件复制到目标目录当中。我们了解完这些代码的实际作用之后就可以在终端中运行 webpack --config build/webpack.config.js 命令。webpack会将源代码编译到 dist 文件夹中，这个文件夹中的内容就可用在开发者工具中运行、预览、上传。优化完成了最基础的webpack构建策略后，我们实现了 app 和 home 页面的转化，但这还远远不够。我们还需要解决许多的问题：页面文件增多怎么办，组件怎么处理预期的预编译如何做规范如何结合到工程中环境变量怎么处理接下来我们针对以上几点进行webpack策略的升级：页面与组件一开始我的实现方法是写一个工具函数利用 glob 收集pages和components下的 js 文件然后生成入口对象传递给 entry 。但是在实践过程中，我发现这样的做法有两个弊端：当终端中已经启动了命令，这时候新增页面或组件都不会自动生成新的入口，也就是我们要重跑一遍命令。工具函数写死了匹配pages和components文件夹下的文件，不利于项目的延展性，如果我们需要分包或者文件夹命名需要改动时，我们就需要改动工具函数。本着程序员应该是极度慵懒，能交给机器完成的事情绝不自己动手的信条，我开始研究新的入口生成方案。最终确定下来编写一个webpack的插件，在webpack构建的生命周期中生成入口，废话不多说上代码：/** build/entry-extract-plugin.js */\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst chalk = require('chalk');\r\nconst replaceExt = require('replace-ext');\r\nconst { difference } = require('lodash');\r\nconst SingleEntryPlugin = require('webpack/lib/SingleEntryPlugin');\r\nconst MultiEntryPlugin = require('webpack/lib/MultiEntryPlugin');\r\n\r\nclass EntryExtractPlugin {\r\n  constructor() {\r\n    this.appContext = null;\r\n    this.pages = [];\r\n    this.entries = [];\r\n  }\r\n\r\n  /**\r\n  \t*\t收集app.json文件中注册的pages和subpackages生成一个待处理数组\r\n  \t*/\r\n  getPages() {\r\n    const app = path.resolve(this.appContext, 'app.json');\r\n    const content = fs.readFileSync(app, 'utf8');\r\n    const { pages = [], subpackages = [] } = JSON.parse(content);\r\n    const { length: pagesLength } = pages;\r\n    if (!pagesLength) {\r\n      console.log(chalk.red('ERROR in \"app.json\": pages字段缺失'));\r\n      process.exit();\r\n    }\r\n    /** 收集分包中的页面 */\r\n    const { length: subPackagesLength } = subpackages;\r\n    if (subPackagesLength) {\r\n      subpackages.forEach((subPackage) => {\r\n        const { root, pages: subPages = [] } = subPackage;\r\n        if (!root) {\r\n          console.log(chalk.red('ERROR in \"app.json\": 分包配置中root字段缺失'));\r\n          process.exit();\r\n        }\r\n        const { length: subPagesLength } = subPages;\r\n        if (!subPagesLength) {\r\n          console.log(chalk.red(`ERROR in \"app.json\": 当前分包 \"${root}\" 中pages字段为空`));\r\n          process.exit();\r\n        }\r\n        subPages.forEach((subPage) => pages.push(`${root}/${subPage}`));\r\n      });\r\n    }\r\n    return pages;\r\n  }\r\n\r\n  /**\r\n  \t*\t以页面为起始点递归去寻找所使用的组件\r\n  \t*\t@param {String} 当前文件的上下文路径\r\n  \t*\t@param {String} 依赖路径\r\n  \t* @param {Array} 包含全部入口的数组\r\n  \t*/\r\n  addDependencies(context, dependPath, entries) {\r\n    /** 生成绝对路径 */\r\n    const isAbsolute = dependPath[0] === '/';\r\n    let absolutePath = '';\r\n    if (isAbsolute) {\r\n      absolutePath = path.resolve(this.appContext, dependPath.slice(1));\r\n    } else {\r\n      absolutePath = path.resolve(context, dependPath);\r\n    }\r\n    /** 生成以源代码目录为基准的相对路径 */\r\n    const relativePath = path.relative(this.appContext, absolutePath);\r\n    /** 校验该路径是否合法以及是否在已有入口当中 */\r\n    const jsPath = replaceExt(absolutePath, '.js');\r\n    const isQualification = fs.existsSync(jsPath);\r\n    if (!isQualification) {\r\n      console.log(chalk.red(`ERROR: in \"${replaceExt(relativePath, '.js')}\": 当前文件缺失`));\r\n      process.exit();\r\n    }\r\n    const isExistence = entries.includes((entry) => entry === absolutePath);\r\n    if (!isExistence) {\r\n      entries.push(relativePath);\r\n    }\r\n    /** 获取json文件内容 */\r\n    const jsonPath = replaceExt(absolutePath, '.json');\r\n    const isJsonExistence = fs.existsSync(jsonPath);\r\n    if (!isJsonExistence) {\r\n      console.log(chalk.red(`ERROR: in \"${replaceExt(relativePath, '.json')}\": 当前文件缺失`));\r\n      process.exit();\r\n    }\r\n    try {\r\n      const content = fs.readFileSync(jsonPath, 'utf8');\r\n      const { usingComponents = {} } = JSON.parse(content);\r\n      const components = Object.values(usingComponents);\r\n      const { length } = components;\r\n      /** 当json文件中有再引用其他组件时执行递归 */\r\n      if (length) {\r\n        const absoluteDir = path.dirname(absolutePath);\r\n        components.forEach((component) => {\r\n          this.addDependencies(absoluteDir, component, entries);\r\n        });\r\n      }\r\n    } catch (e) {\r\n      console.log(chalk.red(`ERROR: in \"${replaceExt(relativePath, '.json')}\": 当前文件内容为空或书写不正确`));\r\n      process.exit();\r\n    }\r\n  }\r\n\r\n  /**\r\n  \t* 将入口加入到webpack中\r\n  \t*/\r\n  applyEntry(context, entryName, module) {\r\n    if (Array.isArray(module)) {\r\n      return new MultiEntryPlugin(context, module, entryName);\r\n    }\r\n    return new SingleEntryPlugin(context, module, entryName);\r\n  }\r\n\r\n  apply(compiler) {\r\n    /** 设置源代码的上下文 */\r\n    const { context } = compiler.options;\r\n    this.appContext = context;\r\n\r\n    compiler.hooks.entryOption.tap('EntryExtractPlugin', () => {\r\n      /** 生成入口依赖数组 */\r\n      this.pages = this.getPages();\r\n      this.pages.forEach((page) => void this.addDependencies(context, page, this.entries));\r\n      this.entries.forEach((entry) => {\r\n        this.applyEntry(context, entry, `./${entry}`).apply(compiler);\r\n      });\r\n    });\r\n\r\n    compiler.hooks.watchRun.tap('EntryExtractPlugin', () => {\r\n      /** 校验页面入口是否增加 */\r\n      const pages = this.getPages();\r\n      const diffPages = difference(pages, this.pages);\r\n      const { length } = diffPages;\r\n      if (length) {\r\n        this.pages = this.pages.concat(diffPages);\r\n        const entries = [];\r\n        /** 通过新增的入口页面建立依赖 */\r\n        diffPages.forEach((page) => void this.addDependencies(context, page, entries));\r\n        /** 去除与原有依赖的交集 */\r\n        const diffEntries = difference(entries, this.entries);\r\n        diffEntries.forEach((entry) => {\r\n          this.applyEntry(context, entry, `./${entry}`).apply(compiler);\r\n        });\r\n        this.entries = this.entries.concat(diffEntries);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nmodule.exports = EntryExtractPlugin;\r\n复制代码由于webpack的 plugin 相关知识不在我们这篇文章的讨论范畴，所以我只简单的介绍一下它是如何介入webpack的工作流程中并生成入口的。（如果有兴趣想了解这些可以私信我，有时间的话可能会整理一些资料出来给大家）该插件实际做了两件事：entry\r\nentry\r\n现在我们将这个插件应用到之前的webpack策略中，将上面的配置更改为：（记得安装 chalk replace-ext 依赖）/** build/webpack.config.js */\r\nconst EntryExtractPlugin = require('./entry-extract-plugin');\r\n\r\nmodule.exports = {\r\n  ...\r\n  entry: {\r\n    app: './app.js'\r\n  },\r\n  plugins: [\r\n    ...\r\n    new EntryExtractPlugin()\r\n  ]\r\n}\r\n复制代码样式预编译与EsLint样式预编译和EsLint应用其实已经有许多优秀的文章了，在这里我就只贴出我们的实践代码：/** build/webpack.config.js */\r\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\r\n\r\nmodule.exports = {\r\n  ...\r\n  module: {\r\n    rules: [\r\n      ...\r\n      {\r\n        enforce: 'pre',\r\n        test: /\\.js$/,\r\n        exclude: /node_modules/,\r\n        loader: 'eslint-loader',\r\n        options: {\r\n          cache: true,\r\n          fix: true,\r\n        },\r\n      },\r\n      {\r\n        test: /\\.less$/,\r\n        use: [\r\n          {\r\n            loader: MiniCssExtractPlugin.loader,\r\n          },\r\n          {\r\n            loader: 'css-loader',\r\n          },\r\n          {\r\n            loader: 'less-loader',\r\n          },\r\n        ],\r\n      },\r\n    ]\r\n  },\r\n  plugins: [\r\n    ...\r\n    new MiniCssExtractPlugin({ filename: '[name].wxss' })\r\n  ]\r\n}\r\n复制代码我们修改完策略后就可以将 wxss 后缀名的文件更改为 less 后缀名（如果你想用其他的预编译语言，可以自行修改loader），然后我们在 js 文件中加入 import './index.less' 语句就能看到样式文件正常编译生成了。样式文件能够正常的生成最大的功臣就是 mini-css-extract-plugin 工具包，它帮助我们转换了后缀名并且生成到目标目录中。环境切换环境变量的切换我们使用 cross-env 工具包来进行配置，我们在 package.json 文件中添加两句脚本命令：\"scripts\": {\r\n\t\"dev\": \"cross-env OPERATING_ENV=development webpack --config build/webpack.config.js --watch\",\r\n\t\"build\": \"cross-env OPERATING_ENV=production webpack --config build/webpack.config.js\r\n}\r\n复制代码相应的我们也修改一下webpack的配置文件，将我们应用的环境也告诉webpack，这样webpack会针对环境对代码进行优化处理。/** build/webpack.config.js */\r\nconst { OPERATING_ENV } = process.env;\r\n\r\nmodule.exports = {\r\n  ...\r\n  mode: OPERATING_ENV,\r\n  devtool: OPERATING_ENV === 'production' ? 'source-map' : 'inline-source-map'\r\n}\r\n复制代码虽然我们也可以通过命令为webpack设置 mode ，这样也可以在项目中通过 process.env.NODE_ENV 访问环境变量，但是我还是推荐使用工具包，因为你可能会有多个环境 uat test pre 等等。针对JS优化小程序对包的大小有严格的要求，单个包的大小不能超过2M，所以我们应该对JS做进一步的优化，这有利于我们控制包的大小。我所做的优化主要针对runtime和多个入口页面之间引用的公共部分，修改配置文件为：/** build/webpack.config.js */\r\nmodule.exports = {\r\n  ...\r\n  optimization: {\r\n    splitChunks: {\r\n      cacheGroups: {\r\n        commons: {\r\n          chunks: 'initial',\r\n          name: 'commons',\r\n          minSize: 0,\r\n          maxSize: 0,\r\n          minChunks: 2,\r\n        },\r\n      },\r\n    },\r\n    runtimeChunk: {\r\n      name: 'manifest',\r\n    },\r\n  },\r\n}\r\n复制代码webpack会将公共的部分抽离出来在 dist 文件夹根目录中生成 common.js 和 manifest.js 文件，这样整个项目的体积就会有明显的缩小，但是你会发现当我们运行命令是开发者工具里面项目其实是无法正常运行的，这是为什么？这主要是因为这种优化使小程序其他的 js 文件丢失了对公共部分的依赖，我们对webpack配置文件做如下修改就可以解决了：/** build/webpack.config.js */\r\nmodule.exports = {\r\n  ...\r\n  output: {\r\n    ...\r\n    globalObject: 'global'\r\n  },\r\n  plugins: [\r\n    new webpack.BannerPlugin({\r\n      banner: 'const commons = require(\"./commons\");\\nconst runtime = require(\"./runtime\");',\r\n      raw: true,\r\n      include: 'app.js',\r\n    })\r\n  ]\r\n}\r\n复制代码小小解惑许多读者可能会有疑惑，为什么你不直接使用已有的框架进行开发，这些能力已经有许多框架支持了。选择框架确实是一个不错的选择，毕竟开箱即用为开发者带来了许多便利。但是这个选择是有利有弊的，我也对市面上的较流行框架做了一段时间的研究和实践。较为早期的腾讯的wepy、美团的mpvue，后来者居上的京东的taro、Dcloud的uni-app等，这些在应用当中我认为有以下一些点不受我青睐：黑盒使我们有时很难定位问题究竟是出在自身的代码当中还是在框架的编译流程中（这让我踩了不少坑）围绕框架展开的可以使用的资源有限，例如UI的使用基本依赖于官方团队进行配套开发，如果没有社区也极难找到需要的资源（这一点我认为uni-app的社区做得挺不错）与已有的一些原生的资源无法结合，这些框架基本都是基于编译原理提供了以react或者vue为开发语言的能力，这使得原生的资源要无缝接入很难实现（假如你们公司已经积淀了一些业务组件那你会很头疼）。最后一点，也是我担心的最重要的一点，框架的升级速度是否能跟得上官方的迭代速度，如果滞后了已有的项目该如何处理以上基本是我为什么要自己探索小程序工程化的理由（其实还有一点就是求知欲，嘻嘻）写在最后以上是我对原生小程序工程化的探索，在我所在的团队中还应用了一些相关的样式规范，在这篇文章中我没有具体的说，有兴趣的话可以查看我的专栏中《团队规范之样式规范实践》一文。其实还有静态资源的管理，项目的目录的补充这些细节可以依照团队的需要去完善补充。本文希望对有需要做这方面实践的团队有所帮助，如有观点不正确或需要改进的地方，望可以评论告知我。"}
{"title": "小程序踩坑之旅", "author": "Rolan", "time": "2020-4-21 00:46", "content": "最近几个月因为公司的业务需求，一直在折腾小程序，从开始的完全不熟悉，到后面被各种坑折磨，是时候写一篇总结了，避免下一次遇到还找不到解决的方案。配置项app.json和page.jsonapp.json首先，需要确定的是，app.json 是小程序的全局配置，放在根目录下。常用的一些字段如下：pages： 这个用于设置页面的路径，通常访问的页面都放在pages文件夹里面，且必须在这个全局配置文件中设置好路径，否则访问的时候会报错找不到该路径， 写在 pages 字段的第一个页面就是这个小程序的首页 （打开小程序看到的第一个页面）window: 全局样式的配置导航栏相关：可配置导航栏背景颜色、标题颜色，标题内容，可以隐藏导航栏（navigationStyle设置为custom，但需要注意， 自定义导航栏仍然保留右上角胶囊，且没有返回键，如果想要实现返回功能，需要自己自定义返回的样式和功能 ），==该设置对web-view 组件无效==窗口的背景色， backgroundColor，（即小程序下拉时露出的那一截），另外，仅ios支持的还有backgroundColorTop和backgroundColorBottom， 顶部和底部窗口的背景色下拉loading的样式，只有黑色和白色（dark / light）enablePullDownRefresh ，小程序默认页面是没有下拉刷新功能的，如果在app.json中配置该项为true，则所有页面都可以生效。如果只想在单个页面使用下拉刷新，需要在对应的page.json中进行配置onReachBottomDistance， 上拉加载更多生效时距页面底部距离，默认为50px屏幕旋转，pageOrientation， 暂时还没有用到过，支持 auto / portrait / landscape，默认为portrait竖屏显示，tabbar： tab栏设置位置：支持顶部和底部（通常使用底部tab栏）， position（bottom / top）tab列表 list： 文字以及对应的路径最少2个，最多5个pagePath，页面路径（必须是pages中定义的路径）text， tab上的文字iconPath， 图片路径，（ 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片 ）selectedIconPath，选中时的图片路径。限制同上样式相关：color字体颜色，selectedColor选中文字的颜色，backgroundColor是tab栏背景色 ，borderStyle上边框颜色，custom是否自定义，默认为否， 具体文档参考： 自定义tabBarnetworkTimeout（设置网络请求的超时时间）requestconnectSocketuploadFiledownloadFiledebug， 开启调试,会输出Page 的注册，页面路由，数据更新，事件触发等信息，方便查看生命周期的调试navigateToMiniProgramAppIdList， 跳转到其他小程序时，需要先在app.json中进行声明usingComponents，如果在app.json中声明该组件，则全局可以使用该自定义组件，不需要再在page的json中声明permission， 用于授权相关，平时项目中是自己写的页面，调用button的open-type属性唤起授权，其实可以通过插件功能页来实现，比如授权昵称， 用户信息功能页page.json页面的样式配置优先级比全局配置中的window高。可以设置导航栏背景颜色、导航栏标题颜色，导航栏标题，可以隐藏导航栏，custom 自定义导航栏，只保留右上角胶囊按钮窗口的背景色 ， 以及ios支持顶部和底部窗口的背景色backgroundTextStyle，下拉 loading 的样式，仅支持 dark / lightenablePullDownRefresh开启下拉刷新，这个属性只控制当前的page页面可以刷新onReachBottomDistance，上拉加载更多生效时距页面底部距离，默认为50pxpageOrientation，屏幕旋转设置disableScroll ，为 true 则页面整体不能上下滚动。只在页面配置中有效，无法在 app.json 中设置disableSwipeBack， 禁止页面右滑手势返回usingComponents， 使用自定义组件，如果没有在页面的json中声明，直接使用组件会报错sitemap.json文件（用于微信索引）默认规则为都默认被索引：{\"action\": \"allow\", \"page\": \"*\"}语法区别wxml文件跟html的区别：没有div, p, span， 使用view代替div， text代替spanwx:if的使用同vue中的v-if， 但使用上略有区别，不管在标签中还是文本上，都是使用双大括号来表示插值， wx:for=\"{{array}}\" ,条件渲染有wx:if, wx:elif, wx:else, 使用方式： <view wx:if=\"{{view == 'WEBVIEW'}}\"> WEBVIEW </view>尤其注意，如果是使用boolean类型的值，不要直接在双引号内直接写，也需要写在双大括号里面。如 <checkbox checked=\"{{false}}\"> </checkbox>列表渲染 wx:for=\"{{array}}\" , 可直接使用item和index，也可以使用 wx:for-item=\"idx\" , 和 wx:for-item=\"itemName\" 重新指定index和item的key值， 花括号和引号之间如果有空格，将最终被解析成为字符串wxml文件中有一个标签是block， 仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性wx:key的值只能是字符串或者 \"*this\", wx:key=\"*this\" 表示for 循环中的 item 本身， 但是要保证这个item本身是一个唯一的字符串或者数字， 当key绑定的是对象的时候会报错问题思考？wx:if 和 hidden 该怎么合理的判断使用场景？wx:if 是惰性的，只有为true时才会局部渲染，当 wx:if 的条件值切换时，条件块会在切换时销毁或重新渲染。而hidden始终会被渲染，只是控制显示与隐藏所以，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好组件基础组件组件的公共属性：id, class, style, hidden, data- , bind /catch*视图容器：可移动： movable-area， movable-view。 其中，movable-view必须在 movable-area 组件中，并且必须是直接子节点覆盖原生组件：cover-view， cover-image，主要用于覆盖 map、video、canvas、camera、live-player、live-pusher等级别高的原生组件。 注意，在cover-view中只能嵌套cover-view、cover-image和button可滚动的视图区域：scroll-view， 竖向滚动时，需要给scroll-view一个固定高度滑块视图容器： swiper， 其中只能放置swiper-item组件（常用于轮播图）视图容器view， 如果想使用hover的样式，可以指定按下去的样式类，跟hover相关的属性： hover-class，hover-stop-propagation， hover-start-time， hover-stay-time图标icon，在小程序中可以使用自带的一些icon图标，可以设置type、大小、颜色，详情查看， 小程序icon组件进度条，progress， 普通的进度条包括动画等可以直接使用该组件富文本，rich-txt, (可以使用该组件渲染html内容，传入html字符串)文本，text， （如果需要展示多个空格，可以设置space属性）按钮，button，（可以设置disabled属性进行禁用，防止多次点击触发事件）单选、多选框：radio、radio-goup、checkbox、checkbox-group富文本编辑器，editor表单form，支持switch input checkbox slider radio picker 的提交输入框input，支持文本、数字、身份证、带小数点的数字键盘等4个类型，password可以显示密码类型，（可以控制键盘右下角的文字，使用confirm-type属性控制，包括“发送”、“搜索”、“下一个”、“前往”、“完成”）注意：input无法设置 font-family，使用的是系统字体滚动选择器，picker，支持普通、多列、时间、日期、省市选择器，嵌入页面的滚动选择器， picker-view， picker-view-column滑动选择器，slider，类似进度条不过可以拖动开关，switch多行输入框，textarea导航，navigator，（类似于a标签，可以使用navigate、redirect、switchTab、reLaunch、navigateBack、exit（退出小程序）等类型）系统相机，camera，可以用于扫描二维码视频video，（注意，使用video组件在列表中的时候会引起小程序页面卡顿甚至崩溃，目前项目中的解决方案是使用阿里云上传视频的截帧图片来替换掉video组件，只有点击图片后才会播放视频，查看网上资料说是video的src默认为空，解决了viode自动下载的bug，使用custom-cache=\"{{false}}\"可以解决视频缓存中卡住的问题，不过还没有试过）公众号关注组件，official-account承载网页的容器，web-view，（适用于第三方网站内容的嵌入，注意需要在公众平台配置业务域名），避免在链接中带有中文字符，在 iOS中会有打开白屏的问题，建议加一下encodeURIComponent原生组件的使用限制原生组件包括：cameracanvasinput（仅在focus时表现为原生组件）live-playerlive-pushermaptextareavideo层级： 最高，其他组件无论设置 z-index 为多少，都无法盖在原生组件上原生组件不能设置动画、fixed布局、不能使用overflow: hidden来裁剪原生组件的显示区域，事件监听不能使用 bind:eventname 的写法，只支持 bindeventname，不支持 catch 和 capture 的事件绑定方式事件系统事件处理函数，参数是event，event的事件内容包括：typetimeStamp， 事件生成时的时间戳target，触发事件的 源组件currentTarget，事件绑定的 当前组件detail， 自定义事件所携带的数据touches，一个数组，每个元素为一个 Touch 对象changedTouches， 有变化的触摸点dataset：在target或currentTarget的事件对象中，可以通过dataset获取当前自定义的一些数据，（在JS文件中使用event.currentTarget.dataset时，dataset的属性会自动转换字符串， 连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符 ）mark，类似于dataset，（如果存在同名的 mark ，父节点的 mark 会被子节点覆盖）页面的用户行为：下拉刷新 onPullDownRefresh上拉触底 onReachBottom页面滚动 onPageScroll用户转发 onShareAppMessage思考：小程序中bind事件和catch事件有什么区别？bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡target和currentTarget有什么不同？<view id=\"outer\" bindtap=\"handleTap1\">\r\n  outer view\r\n  <view id=\"middle\" catchtap=\"handleTap2\">\r\n    middle view\r\n    <view id=\"inner\" bindtap=\"handleTap3\">\r\n      inner view\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码如上面这个示例中，点击inner view会触发handleTap3，同时会冒泡到handleTap2。 对于handleTap2这个组件来说，此时收到事件对象的target就是inner的元素，而currentTarget是middle的部分mark 和 dataset 有什么区别？mark 会包含从触发事件的节点到根节点上所有的 mark: 属性值；dataset 仅包含一个节点的 data- 属性值节点的 mark 不会做连字符和大小写转换小程序相关机制小程序框架的逻辑层并非运行在浏览器中，因此 JavaScript 在 web 中一些能力都无法使用，如 window，document 等小程序的运行机制：冷启动和热启动冷启动： 首次打开小程序；或小程序销毁后打开。（冷启动会触发app.js中的onLaunch生命周期函数）热启动： 点击右上角胶囊退出、或者home键离开微信、或者左右滑动返回到微信等动作，都是热启动，并没有销毁小程序，（所以热启动不会触发onLaunch函数，但会触发onShow函数）启动场景小程序启动场景分为两种：从发现栏、另一个小程序返回、微信支付、首页下拉小程序栏等为A场景B场景：打开某个特定页面：如转发分享的卡片链接热启动场景效果：如果重新进入的场景和退出时的场景都是A场景，则保留原来状态；例如：停留在“个人中心”页面，退出后，下拉首页的小程序列表进入后还是会停留在“个人中心”页面，（触发“个人中心”Page的onShow函数，但是不会触发onLoad函数）如果当前是A场景，上一个是B场景，则清空原来的页面栈，打开首页（即执行 wx.reLaunch 到首页）如分享出去的卡片是“学员列表”页面，点击卡片停留后退出，再从首页下拉的小程序进入，此时会跳转到首页不管上一个场景是什么，如果当前是B场景，如点击小程序的分享卡片，此时会清空原来的页面栈，重新进入这个分享页，首先触发app中的onShow函数，然后触发这个分享页的onLoad函数，当然如果app中已经进行了跳转到其它页面，则不会再走这个分享页。冷启动场景效果：冷启动规则比较简单，如果冷启动时是A场景，则进入小程序首页如果冷启动时是B场景，则进入对应的特定页面更新机制小程序首先会在后台有一个最新版本，一般来说会在24小时内下发新版本信息到用户，静默更新到新版本（此时用户是无感知态）在后台还没及时更新版本时，每次冷启动都会检测是否有更新版本，如果有，会 异步下载 ，同时启动当前的旧版本包，所以新版本需要下一次的冷启动才会应用上如果启动时就想立刻获取最新版本，需要使用 wx.getUpdateManager 的API，用wx.showModal提示用户是否重启应用更新ES6的支持情况：微信小程序已经支持了绝大部分的 ES6 API，但部分API仍依赖于系统版本而不支持String的normalize在ios8，ios9不支持数组的values在ios8和android不支持数组的includes在ios8不支持Proxy不支持ios8、ios9和android注册小程序app.js中注册小程序，整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 getApp 方法获取到全局唯一的 App 示例，获取App上的数据或调用开发者注册在 App 上的函数在app.js中可以直接使用this.globalData赋值，但在其他页面需通过getApp()方法获取到实例后才能使用全局变量globalDataApp({\r\n  onLaunch: function(options) {},\r\n  onShow: function(options) {},\r\n  onHide: function() {},\r\n  onError: function(msg) {},\r\n  globalData: 'I am global data'\r\n})\r\n复制代码注册页面和自定义组件页面data 是页面第一次渲染使用的初始数据onLoad页面加载时触发。一个页面只会调用一次；onShow在页面显示/切入前台时触发onPageScroll，监听用户滑动页面事件，（ 请避免在 onPageScroll 中过于频繁的执行 setData 等引起逻辑层-渲染层通信的操作。尤其是每次传输大量数据，会影响通信耗时 ）onShareAppMessage监听页面内的转发，转发有button 组件 open-type=\"share\"和右上角转发两个方式，（只有Page中定义了onShareAppMessage，右上角才会出现转发功能）setData：将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）（跟react的setState类似，但又不一样）直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致不要把 data 中任何一项的 value 设为 undefined如果需要视图层更新完毕后再处理事件，可以将事件放在setData的回调函数中Page构造器：Page({\r\n  data: { text: \"This is page data.\" },\r\n  onLoad: function(options) { },\r\n  onReady: function() { },\r\n  onShow: function() { },\r\n  onHide: function() { },\r\n  onUnload: function() { },\r\n  onPullDownRefresh: function() { },\r\n  onReachBottom: function() { },\r\n  onShareAppMessage: function () { },\r\n  onPageScroll: function() { }\r\n})\r\n复制代码自定义组件页面使用自定义组件时需要现在page的json文件中声明usingComponents定义段组件使用页面的生命周期方法时（即 on 开头的方法），应该写在methods定义段中behaviors 提取所有页面中公用的代码段，例如， 在所有页面被创建和销毁时都要执行同一段代码，就可以把这段代码提取到 behaviors 中// page-common-behavior.js\r\nmodule.exports = Behavior({\r\n  attached: function() {\r\n    // 页面创建时执行\r\n    console.info('Page loaded!')\r\n  },\r\n  detached: function() {\r\n    // 页面销毁时执行\r\n    console.info('Page unloaded!')\r\n  }\r\n})\r\n\r\n\r\n// 页面 A\r\nvar pageCommonBehavior = require('./page-common-behavior')\r\nComponent({\r\n  behaviors: [pageCommonBehavior],\r\n  data: { /* ... */ },\r\n  methods: { /* ... */ },\r\n})\r\n\r\n\r\n// 页面 B\r\nvar pageCommonBehavior = require('./page-common-behavior')\r\nComponent({\r\n  behaviors: [pageCommonBehavior],\r\n  data: { /* ... */ },\r\n  methods: { /* ... */ },\r\n})\r\n复制代码在 properties 定义段中，属性名采用驼峰写法（propertyName）；在 wxml 中，指定属性值时则对应使用连字符写法（component-tag-name property-name=\"attr value\"），应用于数据绑定时采用驼峰写法（attr=\"\"）observers数据监听器，（类似于vue中的watch），具体请参考 数据监听器created，组件实例刚被创建，（ 注意此时不能调用 setData ）definitionFilter，定义段过滤器，用于自定义组件扩展（如扩展自定义组件一个computed计算属性功能）注意：使用 this.data 可以获取内部数据和属性值；但直接修改它不会将变更应用到界面上，应使用 setData 修改生命周期函数无法在组件方法中通过 this 访问到组件间的通信与事件父传子：父组件绑定属性值，子组件通过properties获取，子组件向父组件传递数据：使用事件传递父组件访问子组件： 父组件可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法此处列举第二种自定义事件传递数据的方法：// 1. 父组件中监听事件\r\n<component-tag-name bindmyevent=\"onMyEvent\" />\r\n\r\n// 2. 子组件触发事件，触发wxml的onMyEvent事件，触发父组件的方法\r\n<!--自定义组件中-->\r\n<button bindtap=\"onTap\">点击这个按钮将触发“myevent”事件</button>\r\n\r\n<!--自定义组件js文件中-->\r\nComponent({\r\n  properties: {},\r\n  methods: {\r\n    onTap: function(){\r\n      var myEventDetail = {} // detail对象，提供给事件监听函数\r\n      var myEventOption = {} // 触发事件的选项\r\n      this.triggerEvent('myevent', myEventDetail, myEventOption)\r\n    }\r\n  }\r\n})\r\n\r\n复制代码具体可参考文档： 组件间通信与事件注意：组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，请改用class选择器避免使用后代选择器（.a .b）子元素选择器（.a>.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除继承样式外，如 font 、 color会继承自组件外）组件间关系场景： 如果一个页面中需要使用到A组件和B组件，而A组件与B组件之间需要通信，此时可以在组件定义时加入relations定义段，如封装的ul和li组件后，之间需要存在关联的父子关系必须在两个组件定义中都加入relations定义，否则不会生效type，与目标组件的相对关系，可选的值为 parent 、 child 、 ancestor 、 descendant另一种情况是关联一类组件（如form与input、checkbox等的关系），需要使用到behavior具体使用方式参见 组件间关系使用setData应注意的事项：不要频繁的去 setData，否则可能导致Android 下用户在滑动时会感觉到卡顿，或者渲染有出现延时不要每次 setData 都传递大量新数据不要在后台态页面进行 setData ，小程序运行流程微信打开小程序前，会把整个小程序的代码包下载到本地通过 app.json 的 pages 字段就可以知道你当前小程序的所有页面路径写在 pages 字段的第一个页面就是这个小程序的首页（打开小程序看到的第一个页面），所以微信会把首页的代码装载进来小程序启动，触发app.js 定义的 App 实例的 onLaunch回调，启动时也会触发onShow函数，或切前台、从其他页面返回到这个页面，都会触发onShow；onHide监听小程序切后台，（如tab切换，navigateTo，离开微信等）； onPageNotFound页面不存在监听函数页面的渲染流程开始，微信客户端会先根据 page的json文件配置生成一个界面，接着装载这个页面的 WXML 结构和 WXSS 样式最后客户端会装载 page的js文件Page构造器会生成一个页面，生成页面的时候小程序框架会把 data 数据和 index.wxml 一起渲染出最终的结构，渲染完界面渲染完界面之后，页面实例就会收到一个 onLoad 的回调生命周期函数小程序里面又三种生命周期：小程序运行的生命周期（在app.js中处理），页面的生命周期（在page的js文件中处理，或者组件的pageLifetimes触发的生命周期函数），组件的生命周期小程序生命周期函数onLaunch， 小程序初始化完成时触发，全局只触发一次onShow，小程序启动，或从后台进入前台显示时触发onHide，从前台进入后台时触发onError，小程序发生脚本错误或 API 调用报错时触发onPageNotFound，小程序要打开的页面不存在时触发onLaunch,onShow参数：path： 打开小程序的页面路径query： 打开小程序的页面参数queryscene： 打开小程序的场景值，shareTicket： 转发分享参数referrerInfo：当场景为由从另一个小程序或公众号或App打开时，返回此字段referrerInfo.appId： 来源小程序或公众号或App的 appIdreferrerInfo.extraData： 来源小程序传过来的数据，scene=1037或1038时支持页面生命周期函数onLoad，监听页面加载onShow, 监听页面显示（如tab切换或者离开微信、或navigateTo）onReady, 监听页面初次渲染完成(一个页面只会调用一次，代表页面已经准备妥当)onHide, 监听页面隐藏, (如 wx.navigateTo 或底部 tab 切换到其他页面，小程序切入后台等)onUnload, 监听页面卸载(如wx.redirectTo或wx.navigateBack到其他页面时)组件生命周期函数created,在组件实例刚刚被创建时执行，注意此时不能调用 setDataattached,在组件实例进入页面节点树时执行ready,在组件布局完成后执行moved, 在组件实例被移动到节点树另一个位置时执行detached, 在组件实例被从页面节点树移除时执行注意：组件中存在一个组件所在页面的生命周期，定义在pageLifetimes中，其中可用的生命周期包括：show， 组件所在的页面被展示时执行hide， 组件所在的页面被隐藏时执行resize， 组件所在的页面尺寸变化时执行网络服务器域名配置，当使用体验版或者开发版报“服务器开小差”了的错误，大部分可能性都是因为没有打开调试，因为在调试模式下，小程序不会去校验域名的合法性。小程序只可以跟指定的域名与进行网络通信，包括普通 HTTPS 请求（wx.request）、上传文件（wx.uploadFile）、下载文件（wx.downloadFile) 和 WebSocket 通信（wx.connectSocket）如果接入第三方网页，使用web-view组件，需要配置业务域名默认超时时间为60s，超时时间可以在 app.json 或 game.json 中通过 networktimeout 配置并发限制：wx.request、wx.uploadFile、wx.downloadFile 的最大并发限制是 10 个；wx.connectSockt 的最大并发限制是 5 个返回状态，只要成功接收到服务器返回， 无论 statusCode 是多少，都会进入 success 回调自定义tabBar用户可以通过配置app.json 中的 tabBar 项指定 custom 字段为true，来自定义tabBar，不过有些使用地方还需要注意：tabBar 的相关配置项仍然需完整声明，以兼容低版本以及区分哪些是tab页需要用户自定义一个组件来渲染 tabBar，推荐用 fixed 在底部的 cover-view + cover-image 组件渲染样式，以保证 tabBar 层级相对较高与 tabBar 样式相关的接口，如 wx.setTabBarItem 等将失效可以在自定义组件下通过 getTabBar 接口，获取当前页面的自定义 tabBar 组件实例小程序登录流程小程序登录需要调用微信的开放接口，整体流程如下：小程序通过wx.login()获取一个code调用后端的api，发送code，后端通过这个code来校验接口，并返回一个自定义登录态小程序将登录状态存入storage之后再访问服务器发送业务请求就只用后端判断登录态查询openid和session_key返回业务数据小程序优化操作缩短白屏时间：首屏渲染的内容较多，需要集合多份数据进行渲染：此时可以把优先级高的内容做优先展示首屏内容依赖的数据从服务端请求的时间太长：分析数据返回的时间长的原因一次性渲染数据太大或依赖的计算过于复杂：减少渲染的数据量、优化渲染相关数据的算法渲染界面的耗时过长，需要校验下是否同时渲染的区域太大（例如列表过长）脚本执行时间过长：需要确认并优化脚本的逻辑setData调用频繁：避免无用的频繁调用，每秒调用setData的次数不超过 20 次，// 不要频繁调用setData\r\n    this.setData({ a: 1 })\r\n    this.setData({ b: 2 })\r\n// 绝大多数时候可优化为\r\n    this.setData({ a: 1, b: 2 })\r\n复制代码setData的数据太大，setData的数据在JSON.stringify后不超过 256KBsetData一个未绑定的变量// 不要设置不在界面渲染时使用的数据，并将界面无关的数据放在data外\r\n    this.setData({\r\n      myData: {\r\n        a: '这个字符串在WXML中用到了',\r\n        b: '这个字符串未在WXML中用到，而且它很长…………………………'\r\n      }\r\n    })\r\n    // 可以优化为\r\n    this.setData({\r\n      'myData.a': '这个字符串在WXML中用到了'\r\n    })\r\n    this._myData = {\r\n      b: '这个字符串未在WXML中用到，而且它很长…………………………'\r\n    }\r\n\r\n复制代码开启 HTTP 缓存控制控制WXML节点数<view data-my-data=\"{{myData}}\"> <!-- 这个 view 和下一行的 view 可以合并 -->\r\n  <view class=\"my-class\" data-my-data=\"{{myData}}\" bindtap=\"onTap\">\r\n    <text> <!-- 这个 text 通常是没必要的 -->\r\n      {{myText}}\r\n    </text>\r\n  </view>\r\n</view>\r\n\r\n<!-- 可以简化为 -->\r\n\r\n<view class=\"my-class\" data-my-data=\"{{myData}}\" bindtap=\"onTap\">\r\n  {{myText}}\r\n</view>\r\n复制代码控制图片大小，图片宽高都不超过实际显示宽高的3倍合理控制网络请求数量控制图片请求数开启惯性滚动：wxss中带有overflow: scroll的元素，在 iOS 下需要设置-webkit-overflow-scrolling: touch样式避免使用:active伪类来实现点击态保持图片大小比例可点击元素的宽高都不小于 20pxiphoneX兼容，用以下wxss进行兼容：padding-bottom: constant(safe-area-inset-bottom);\r\npadding-bottom: env(safe-area-inset-bottom);\r\n复制代码避免JS异常不使用废弃接口设置最低基础库版本移除不可访问到的页面移除大量未使用的样式及时回收定时器：定时器是全局的，并不是跟页面绑定的，当小程序从一个页面路由到另一个页面之后，前一个页面定时器应注意手动回收"}
{"title": "调研·微信第三方平台-代小程序开发", "author": "Rolan", "time": "2020-4-22 00:13", "content": "前言\r\n\r\n目标: 通过平台代理的方式,对旗下所有小程序提供业务支持,版本发布等.\r\n\r\n一、前期准备工作\r\n注册平台账号\r\n通过微信·第三方平台申请平台资质\r\n\r\n需要注意第三方平台权限集。\r\n消息管理权限集建议不要勾选,除非业务要求。 若勾选在申请全网发布资质时微信会对这一项基础逻辑进行检测。\r\n\r\n\r\n\r\n全网发布以及为什么需要进行检测。\r\n顾名思义以为是只要发布一个小程序，那么所有的该模板下面的小程序都发布了。 NO！全网发布只是一种资质。通过审核后，第三方平台就可托管被授权的公众号/小程序，进行登录授权。第三方平台后端即可通过调api（核心接口:设置域名、设置分类、上传代码、绑定体验者、获取体验二维码、提交审核、发布）去对小程序进行自动化管理。\r\n\r\n\r\n\r\n作者：互联网修真院 链接：https://juejin.im/post/5cd14ef4f265da03ae74d8fd 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n注册小程序\r\n\r\n自主注册\r\n\r\n\r\n自主注册 : 小程序可以是授权方管理员自己去微信公众平台自己注册一个（若认证需要交300认证费），完善好类目后，把appid以及类目提供给第三方。\r\n\r\n\r\n接口注册\r\n\r\n\r\n第三方通过api接口快速注册 （有赞、微盟等小程序服务商就是例子）快速创建小程序文档\r\n\r\n二、小程序授权\r\n\r\n授权流程技术说明文档\r\n按照上述文档步骤进行授权操作，其中引导用户授权有两种方案：\r\n\r\n\r\n授权注册页面扫码授权\r\n点击移动端链接快速授权 第三方平台方可以生成授权链接，将链接通过移动端直接发给授权管理员，管理员确认后即授权成功。\r\n\r\nTips:\r\n    biz_appid 字段为指定授权唯一的小程序或公众号,建议引导户填写\r\n复制代码登录 微信公众平台 【设置-基本设置-账号信息】复制APPID然后发送给第三方平台\r\n\r\n\r\n授权后回调 URI(也就是redirect_uri字段对应的页面路径)，得到授权码（authorization_code）和过期时间，通过该授权码可以获得该小程序的基础信息\r\n\r\n注意: 如果是通过api接口快速创建小程序后，若注册成功，微信会推送注册审核事件给第三方后台，里面会包含appid以及auth_code(使用该授权码可以换取authorizer_accesstoken)等关键信息。\r\n\r\n小程序授权完成后，需要引导客户登录微信公众平台-小程序后台【设置-第三方设置】去绑定授权方小程序。 如下图：\r\n\r\n\r\n\r\n三、平台小程序模板\r\n代小程序实现业务-开发简介文档\r\n\r\n按照上述步骤绑定小程序模板目的就是产生模板ID\r\n相同点:\r\n开发普通小程序一样.\r\n不同点:\r\n代码只会上传至开放平台的后台草稿箱内，每一个开发者只有一个草稿，每次上传会自动覆盖上次code，草稿箱最多只能保存10个。\r\n合适的版本就可以添加模板库了。模板库最多也只能添加50个。\r\n\r\n前端上传完成后，第三方平台可以在小程序后台看到，然后可以把草稿指定成模板。 然后就可以提交审核并发布了。\r\n\r\n小程序授权托管之后，只能使用第三方平台的在微信开放平台登记的服务器地址。所以第三方平台在帮助旗下公众号发布代码之前，需先把服务器地址设置到小程序的服务器地址中，设置接口详见“修改服务器地址”文档中的接口。\r\n四、平台发布代理小程序发布前准备\r\n基础信息设置\r\n基础信息设置\r\n\r\n设置服务域名、设置业务域名(webview)\r\n\r\n类目管理\r\n类目管理\r\n成员管理\r\n成员管理\r\n\r\n绑定体验者\r\n\r\n订阅消息设置\r\n订阅消息设置\r\n插件管理\r\n插件管理文档\r\n\r\n如小程序直播插件申请\r\n\r\n获取体验版二维码\r\n获取体验版二维码文档\r\n普通链接二维码\r\n\r\naccess_token 会指定对应的小程序\r\n验证文件放置规则：放置于 URL 中声明的最后一级子目录下，若无子目录，则放置于 host 所属服务器的顶层目录下。\r\n扫普通链接二维码打开小程序文档\r\n二维码链接内容会以参数q的形式带给页面，在onLoad事件中提取q参数并自行decodeURIComponent一次，即可获取原二维码的完整内容。\r\n\r\n五、平台发布代理小程序\r\n代码管理\r\n上传代码\r\n\r\n为了便于第三方平台使用同一个小程序模版为不同的小程序提供服务，第三方可以将自定义信息放置在ext_json中，在模版小程序中，可以使用接口获取自定义信息，从而区分不同的小程序。(例如:可以写入对应的小程序标识以及接口版本等等)\r\n\r\n提交审核\r\n提交审核\r\n发布代码\r\n发布代码\r\n参考\r\n\r\n解读微信第三方平台-代小程序开发\r\n微信产品体系\r\n微信开放平台文档\r\n微信公众平台\r\n微信开放平台著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}
{"title": "开发钉钉小程序，使用内网穿透遇到的问题", "author": "Rolan", "time": "2020-4-24 00:21", "content": "最近在做钉钉小程序（第三方企业应用）的一个项目，由于是第一次做钉钉小程序，所以在开发过程中遇到很多坑。目前钉钉小程序的资料相较于微信小程序较少，在开发中遇到问题时，网上的答案很少，很多也都是照搬开发文档上的内容。现记录下在使用内网穿透遇到的问题（水平有限，这也是个很简单的问题）官方开发文档上关于内网穿透如下介绍：很简单的步骤：cd mac_64\r\nchmod 777 ./ding\r\n./ding -config=./ding.cfg -subdomain=abcde 8080可问题是本地的是WIN10系统，不是Mac系统，问题就出现了。在目录下执行第三条命令（windows系统和mac系统对于盘符的分隔号是不一样的，mac的\"./\"对应的windows系统是\".\"的写法，这里需要替换下示例内容。）这里我尝试了各种方法：改名字、改端口、改配置文件，始终无法正常启动内网穿透。上网查资料，相关内容少之又少，也都是官方文档上的内容。在实在没有办法的时候，想着会不会是PowerShell的问题，于是我换下CMD命令行执行，竟然成功启动了！！！不是说PowerShell比CMD更加丰富吗？这是怎么回事？暂时懒得去研究。另外在吐槽下，钉钉的开发文档，和在线调试工具API Explorer钉钉的开发文档，只有JAVA的示例，作为PHPer，十分难受。是不是也可以加上其他语言啊(PHP Python .net ...)另外关于API Explorer：下面是提交的工单内容既然有问题，为什么又不做说明和修改。纠结了那么久！！！------生命不息，BUG不止"}
{"title": "微信原生小程序转其他平台的小程序实践", "author": "Rolan", "time": "2020-4-24 00:53", "content": "如何将现有的微信原生小程序转其他平台的小程序？我想如果打算做这么一件事，或许大多数同学和我一样可能没什么思路。我第一次听说是在一次小程序生态技术大会上，一公司的一位前端技术人员谈到他们公司主要是将自己的微信小程序通过团队开发的工具转成其他平台的小程序，所以当时我也很想了解这个工具是怎么做的，实现过程是什么？恰好近期有这么一次需求要将现有的微信小程序上开发别家的小程序，这个事要么通过现在比较好的方案uni-app来做，要么就用对应的原生小程序来写。但是从零开始做，工作量实在太大了，周期好长呀，那么多页面，得搞到啥时候。就在决定开始调研uni-app来做的时候，恰好有一天在微信上看见了一篇技术文章： 开源｜wwto：小程序跨端迁移解决方案——微信转其他小程序 最后放弃了使用uni-app来做，尝试通过这个工具来转换。下面也将围绕 wwto 这个工具库，通过将我们现有的微信小程序转 支付宝小程序 来了解其转换原理，同时呢会说下在转换的过程中遇到的各种问题是如何解决的，希望对有需要的同学能有所帮助在了解 wwto 这个工具库后，它大致的架构是这样的，下面这张图是使用作者的，更权威一点。通过了解 编译 以及 运行时 这两个模块的实现过程就能够明白小程序转换的过程中做了那些事情以及怎么去做的了下面对这两个阶段所做的事简单说下：1、在 编译 阶段主要对4个文件做了处理，分别是：*.js、 *.json、 *.wxml、 *wxss*.wxml 的处理部分代码如下，可看源码 wxml.jsfunction convert(wxmlText, isWpy) {\r\n  return wxmlText\r\n    .replace(/wx:/g, 'a:')\r\n    .replace(/a:for-items/g, 'a:for')\r\n    .replace(/a:for-key/g, 'a:key')\r\n    //  data-set 全部转为小写\r\n    .replace(/data-[^=\\s]=/g, (match) => match.toLocaleLowerCase())\r\n    // // s:for-index=\"{{idx}}\" -> s:for-index=\"idx\"\r\n    .replace(/a:for-index=['\"]({{\\w+}})['\"]/ig, (match) => match.replace('{{', '').replace('}}', ''))\r\n    // 自定义组件命名不能用驼峰\r\n    .replace(/<[\\w]+/ig, (match) => {\r\n      return isWpy ? match : match.replace(/[A-Z]/g, (m) => ['-', m.toLowerCase()].join(''));\r\n    })\r\n    // 事件绑定名称对齐\r\n    .replace(/\\s+catch[\\w]+=['\"]/ig, (match) => match.replace(/catchsubmit/ig, 'onSubmit')\r\n      .replace(/catch(\\w)/g, (m, p1) => ['catch', p1.toUpperCase()].join('')));\r\n      \r\n    ... 省略\r\n}\r\n\r\nmodule.exports = convert;\r\n复制代码通过对文件的处理：例如<view bind:cellTap='onTabMyCrad' wx:if=\"{{hasJoin}}\">...</view>  变成了 <view onCellTap='onTabMyCrad' a:if=\"{{hasJoin}}\">...</view>\r\n也就是把微信的语法转换为目标小程序的语法结构。\r\n复制代码*.js 的处理部分代码如下，源代码 script.jsfunction convert(jsText, isWpy) {\r\n  return jsText\r\n    .replace(/(require\\(['\"])(\\w+)/g, '$1./$2')\r\n    .replace(/(from\\s+['\"])(\\w+)/g, (match, p1) => {\r\n      // 相对路径以./开头\r\n      return match.replace(p1, [p1, isWpy ? '' : './'].join(''));\r\n    })\r\n    .replace(/\\.properties/g, (match) => {\r\n      return match.replace('.properties', '.props');\r\n    })\r\n    .replace(/Component\\([\\s\\S]+methods:[^{]*{/, (match) => {\r\n      return [\r\n        match,\r\n        `,\\r\\ntriggerEvent: function(name, opt) {\r\n            this.props['on' + name[0].toUpperCase() + name.substring(1)]({detail:opt});\r\n          },\\r\\n`\r\n      ].join('');\r\n    })\r\n    .replace(/[\\s\\S]+/, (match) => {\r\n      // 只处理组件\r\n      if (!match.match(/Component\\(/)) return match;\r\n      \r\n      ... 省略\r\n    });\r\n}\r\n\r\nmodule.exports = convert;\r\n复制代码通过对组件的处理如图：这么转换的目的也就是原文中 开源｜wwto：小程序跨端迁移解决方案——微信转其他小程序 提到的 ： 支付宝小程序组件的生命周期函数与微信小程序完全不一样，也没有一一对应的关系。这种情况无法使用简单的方法名正则替换，本方案是注入支付宝小程序组件的生命周期函数，在这些生命周期函数中在调用微信小程序的生命周期函数，这样以来就避免了方法名替换无法一一对应的问题，也能更方便地书写适配代码。对 *.json 以及 *wxss 的处理就不列出代码了，可看源码： json.js 、 wxss.js2、在 运行时 阶段又做了哪些事情呢？...主要在每个js文件头部加入了适配代码adaptor.js截取部分实现代码如下： 源代码可参考 converter.jsfunction convert(opt = {}) {\r\n  const src = opt.source || './src';\r\n  const dest = opt.target || './alibaba';\r\n  const assets = opt.assets || config.getAssets(src);\r\n  \r\n  ...省略\r\n  // 注入适配器代码\r\n  gulp.src(sysPath.resolve(__dirname, '../../../node_modules/mp-adaptor/lib/alibaba.js'))\r\n    .pipe(rename('adaptor.js'))\r\n    .pipe(gulp.dest(dest)).on('end', () => {\r\n      logger.info('复制 adaptor.js 完成！');\r\n    });\r\n\r\n  // 处理脚本文件\r\n  gulp.src(`${src}/**/*.js`)\r\n    .pipe(replace(/[\\s\\S]*/g, (match) => converter.script(match)))\r\n    .pipe(through2.obj(function(file, enc, cb) {\r\n      const path = file.history[0].replace(file.base, '');\r\n      const spec = path.split(sysPath.sep);\r\n      const adaptor = new Array(spec.length - 1).fill('..').concat('adaptor.js').join('/');\r\n      const str = [\r\n        `import wx from '${adaptor.replace(/^\\.\\./, '.')}';`,\r\n        ab2str(file.contents)\r\n      ].join('\\r\\n');\r\n      file.contents = str2ab(str);\r\n\r\n      this.push(file);\r\n      cb();\r\n    }))\r\n    .pipe(gulp.dest(dest));\r\n}\r\n\r\nmodule.exports = convert;\r\n复制代码加入的adapter.js 代码是什么样的呢？ 参考源码 alibaba.jsfunction getInstance() {\r\n  // eslint-disable-next-line no-undef\r\n  const wx = my;\r\n  wx.has_ali_hook_flag = true;\r\n  \r\n  const {\r\n    getSystemInfo\r\n  } = wx;\r\n  wx.getSystemInfo = function(opt) {\r\n    ...省略\r\n    return getSystemInfo.call(this, opt);\r\n  };\r\n  ...省略\r\n  return wx;\r\n}\r\n\r\nexport default getInstance();\r\n\r\n上面的适配代码：主要就是包装抹平微信与支付宝两个平台间api的调用差异，既可以使用原微信wx.*的方式来调用，也可以使用支付宝小程序平台my.*的方式来调用api，说白了就是对微信的api包装了一层。\r\n复制代码通过分析 wwto 这个工具库的实现过程，也就学习到了如何基于现有的微信小程序转其他平台小程序的实现过程了。下面说下这次转换的过程中遇到了那些问题以及怎么解决的。微信小程序代码转换阶段-实践转换的时候遇见这么一些问题:首先，wwto工具做不到运行时 diff 的抹平，也做不到一个 API 从无到有的过程1、现阶段我们的微信小程序依赖 vantUI 组件库，使用wwto来转换压根就不支持2、微信小程序中常用的api：selectComponent 在支付宝里小程序里面不支持3、微信的分包加载是否支持？不支持又该如何处理等？对于第二个问题，需要修改 wwto 工具库的代码，使其支持这个api，我这边的实现思路如下： 如Page A 页面依赖 Component B组件，可以在B组件的ready生命周期阶段把当前组件实例this挂载到全局对象getApp()中的某个属性上，然后在Page A中实现selectComponent这个api，这个api就来获取挂载到getApp()上对应的实例组件。修改处在 script.js 代码中，可以打开文件比对 如下：对于第三个问题，通过了解支付宝的分包机制文档，完全可以支持微信小程序的，但是，这里我在调试的时候支付宝开发者工具和到真机预览的时，两者差异完全不一样，在开发者工具完全运行正常，可是在真机预览的时候会遇见各种奇葩问题，大部分都是adaptor.js 重写wx.* 的api导致的问题，通过调试了好长时间，终于找到了问题的根源所在，我已经在githup上 向wwto 开源者提issue了，可查看 adaptor.js 重复执行 了解，并且我已提交了PR进行了修正对于第二个大问题，做的事就相对比较多了，如果在不了解wwto这个工具库代码实现思路情况下，可能是无法解决的，当时能想到的解决办法就是，仿照 vantUI 组件库的代码实现，重新采用微信自定义组件的形式重写，但是这样做工作量又上去了，比起使用uni-app来，这个不可行，工作量也好大呀！这个时候，我几乎又要放弃使用这个工具来转换了。那这里能不能换别的思路去解决呢？答案肯定是有的，前提就是了解wwto工具的代码实现过程以及思路：wwto是在转换的时候，通过修改原微信小程序的文件，那么我就能够仿照其思想在小程序运行时添加兼容的代码来让vantUI微信小程序组件库能够跑在支付宝小程序中，听起来是多么一件有趣的事如何去做呢？通过查看了vantUI组件库的代码实现，是可以按这种思路实现的，大致需要修改组件库中两处代码1、源代码 basic.js 修改如下，主要是解决微信小程序triggerEvent api的功能，获取组件实例let Behavior = p => p\r\nexport const basic = Behavior({\r\n    methods: {\r\n        $emit(...args) { \r\n          let name = args[0];\r\n          let onPropsfn = this.props['on' + name[0].toUpperCase() + name.substring(1)];\r\n          // 可以正则匹配 data-*值 ['datadata-mm', 'data-', 'data-1'].filter(v => v.match(/^data-\\w+/))\r\n          let index = this.data && this.data['data-index'];\r\n          if (onPropsfn) {\r\n            if (args.length == 1) {\r\n              onPropsfn({detail: undefined})\r\n            } else if (args.length == 2) {\r\n              onPropsfn({detail: args[1], currentTarget:{dataset: {index: index}}})\r\n            } else if (args.length >= 3) {\r\n              onPropsfn.apply(this, args);\r\n            }\r\n          }\r\n          // this.triggerEvent(...args);\r\n        },\r\n      ... 省略\r\n    }\r\n});\r\n添加的代码实现：都是参考wwto实现的思路\r\n复制代码2、源代码 component.js 修改如下，主要是解决微信小程序中一系特性功能如：externalClasses、properties、behaviors => 模拟到支付宝小程序中，如果有兴趣可以比对添加的代码，如何抹平这些特性差异，其中微信的relations组件特性，没法模拟，替代方案就只能用支付宝小程序相关组件了import { basic } from '../mixins/basic';\r\nimport { observe } from '../mixins/observer/index';\r\nfunction mapKeys(source, target, map) {\r\n    Object.keys(map).forEach(key => {\r\n        if (source[key]) {\r\n            target[map[key]] = source[key];\r\n        }\r\n    });\r\n}\r\nfunction noop() {}\r\nfunction VantComponent(vantOptions = {}) {\r\n    const options = {};\r\n    mapKeys(vantOptions, options, {\r\n        data: 'data',\r\n        props: 'properties',\r\n        mixins: 'behaviors',\r\n        methods: 'methods',\r\n        beforeCreate: 'created',\r\n        created: 'attached',\r\n        mounted: 'ready',\r\n        relations: 'relations',\r\n        destroyed: 'detached',\r\n        classes: 'externalClasses'\r\n    });\r\n    options.properties = options.properties || {};\r\n    // relations 微信组件特性，暂时没法模拟到支付宝\r\n    const { relation } = vantOptions;\r\n    if (relation) {\r\n        options.relations = Object.assign(options.relations || {}, {\r\n            [`../${relation.name}/index`]: relation\r\n        });\r\n    }\r\n    // add default externalClasses\r\n    options.externalClasses = options.externalClasses || [];\r\n    options.externalClasses.push('custom-class');\r\n    // add default behaviors\r\n    options.behaviors = options.behaviors || [];\r\n    options.behaviors.push(basic);\r\n    // map field to form-field behavior\r\n    if (vantOptions.field) {\r\n        options.behaviors.push('wx://form-field');\r\n    }\r\n    // add default options\r\n    options.options = {\r\n        multipleSlots: true,\r\n        addGlobalClass: true\r\n    };\r\n    observe(vantOptions, options);\r\n\r\n    /**\r\n     *  参照wwto => 运行时调整options\r\n     */\r\n     \r\n    /**\r\n    *  mixins\r\n    */\r\n    options.mixins = options.mixins || [];\r\n    options.mixins = options.mixins.concat(options.behaviors);\r\n\r\n    /**\r\n     *  const lifeCircleNames = ['created', 'attached', 'ready', 'detached'];\r\n     */\r\n    options.methods = options.methods || {};\r\n    const lifeCircleNames = ['created', 'attached', 'ready', 'detached'];\r\n    lifeCircleNames.forEach(name => {\r\n      let methods = options.methods[name] = options.methods[name] || options[name] || noop;\r\n      // fix selectComponents api\r\n      if (name == 'ready') {\r\n        options.methods[name] = function() {\r\n          if(this.data.id){\r\n            var app = getApp();\r\n            app.globalData.insComp = app.globalData.insComp || {};\r\n            app.globalData.insComp[this.data.id] = this;\r\n          };\r\n          methods();\r\n        }\r\n      }\r\n    })\r\n\r\n    /**\r\n     *  处理this.__observers\r\n     */\r\n    let has = Object.prototype.hasOwnProperty;\r\n    let propMap = {};\r\n    let observerMap = null;\r\n    let walkProps = obj => {\r\n      Object.keys(obj).forEach((key) => {\r\n        if (!has.call(obj, key)) return\r\n        let item = obj[key];\r\n        // String Number Boolean 设定默认值\r\n        if (item === String) {\r\n          propMap[key] = '';\r\n        } else if (item === Boolean) {\r\n          propMap[key] = false;\r\n        } else if (item === Number) {\r\n          propMap[key] = 0;\r\n        } else if (item && typeof item == 'object') {\r\n          let type = item.type;\r\n          if (!('value' in item)) {\r\n            if (type === String) {\r\n              propMap[key] = '';\r\n            } else if (type === Boolean) {\r\n              propMap[key] = false;\r\n            } else if (type === Number) {\r\n              propMap[key] = 0;\r\n            } else {\r\n              propMap[key] = ''; // 暂时默认值\r\n            }\r\n          } else {\r\n            propMap[key] = item.value;\r\n          }\r\n\r\n          if (item.observer) {\r\n            // debugger\r\n            observerMap = observerMap || {};\r\n\r\n            if (typeof item.observer === 'function') {\r\n              observerMap[key] = item.observer;\r\n            } else { // 微信小程序中observer也可以使用对象的形式\r\n              observerMap[key] = function() {\r\n                this[item.observer] && this[item.observer].apply(this, arguments);\r\n              };\r\n            }\r\n          }\r\n        } else {\r\n          propMap[key] = item;\r\n        }\r\n      });\r\n    }\r\n\r\n    // 处理properties => props\r\n    let properties = options.properties;\r\n    walkProps(properties);\r\n\r\n    let mininsProperties = options.mixins.filter(item => item.properties);\r\n    mininsProperties.forEach(item => {\r\n      walkProps(item.properties);\r\n    })\r\n\r\n    /**\r\n     *  处理 externalClasses 同时手动拷贝class\r\n     */\r\n    let externalClasses = options.externalClasses;\r\n    externalClasses.forEach(clas => {\r\n      propMap[clas.replace(/-(\\w)/g, (match, p) => p.toUpperCase())] = '';\r\n    })\r\n\r\n    options.props = propMap;\r\n    options.props.__observers = observerMap\r\n\r\n    /**\r\n     *  my生命周期函数\r\n     */\r\n    options.didMount = function(){\r\n      this.data = Object.assign({}, this.data, this.props);\r\n\r\n      this.created && this.created.apply(this, arguments);\r\n      this.attached && this.attached.apply(this, arguments);\r\n      this.ready && this.ready.apply(this, arguments);\r\n\r\n      /**\r\n       *  解决初始化observer component 组件\r\n       */\r\n      if (this.props.__observers) {\r\n        Object.keys(this.props.__observers).forEach(key => {\r\n          this.props.__observers[key].call(this, this.props[key])\r\n        })\r\n      }\r\n    }\r\n\r\n    options.didUnmount = function(){\r\n      this.detached && this.detached.apply(this, arguments);\r\n    }\r\n\r\n    options.didUpdate = function(prevProps, preData) {\r\n      for (let key in this.props) {\r\n        if (this.props.__observers && typeof(this.props.__observers[key]) === 'function') {\r\n          if (JSON.stringify(prevProps[key]) !== JSON.stringify(this.props[key]) &&\r\n          JSON.stringify(preData[key]) !== JSON.stringify(this.props[key])) {\r\n            this.setData(Object.assign({}, this.data, {[key]: this.props[key]}));\r\n            this.props.__observers[key].apply(this, [this.props[key], prevProps[key]]);\r\n          }\r\n        } else if (this.props[key] !== prevProps[key]) {\r\n          this.data[key] = this.props[key];\r\n          this.setData(this.data);\r\n        }\r\n      }\r\n    }\r\n\r\n    Component(options);\r\n}\r\nexport { VantComponent };\r\n\r\n复制代码到这里主要的问题解决了，其他一些微信小程序到支付宝小程序的差异就不都列出来了，可以灵活的修改wwto 的代码来实现转换时的差异， 如果后期有同样需求的同学尝试转换时有遇见问题，也可留言交流。最后最初在决定到底要不要使用wwto这个工具来转换微信小程序的时候，心里面也是没底的，毕竟刚开源，我估计是第一个在刚开源的时候来做转换的。而且本身也从未开发过支付宝小程序，也不知道支付宝小程序和微信小程序有哪些大致的差异，再加上调研技术上也没有给充裕的时间来决策到底用什么方案来实现其他平台的小程序。最后决定使用wwto来做这件事，主要是不想做重复的工作，对仅仅使用新的技术框架uni-app来重写，估计对我来说短期也不会有太多的技术积累收益，当然同时呢我也想快速的了解微信和支付宝的一些差异，重要的一点就是wwto开源的，每个部分的源代码都能debug。综合以上几点于是决定来趟一下这个浑水，总的结果来说，项目周期缩短了好多，大致花了两周的时间来完成了，也了解了支付宝小程序和微信小程序之间的一些差异，解决了好多问题，解决问题的过程中也很头疼...最后转换后的效果图就不给出了，欢迎在微信和支付宝中搜索: “ 咔咔找车 ” 小程序看两者差异。"}
{"title": "解决微信小程序引用echarts视图模糊的问题", "author": "Rolan", "time": "2020-4-27 00:39", "content": "在小程序项目中需要用到echarts图表但是展示的时候遇到了问题 图表高度失真 体验感非常差经过一番查找实验，终于找到了解决方案下面上代码！function initChart(canvas, width, height,dpr) {const chart = echarts.init(canvas, null, {width: width,height: height,devicePixelRatio: dpr //解决小程序视图模糊的问题，必写});canvas.setChart(chart);var checkName = ‘今天’;var dataLength = 14; //默认的数据长度，既真实数组的长度，必须设置，长度来源：后台传输//这里是echart基础配置var option = {backgroundColor: ‘rgba(25,1,169,.05)’,tooltip: {trigger: ‘axis’,axisPointer: {type: ‘shadow’,backgroundColor: ‘rgba(245, 245, 245, 1)’,borderWidth: 1,// padding: 10,}},dataZoom: [{show: false, //是否显示下方滚动条realtime: true,startValue: dataLength – 7,endValue: dataLength – 1, //显示数据结束位置},{type: ‘inside’,realtime: true,startValue: dataLength – 7,endValue: dataLength – 1, //显示数据结束位置}],grid: {top: ‘20%’,right: ‘0’,left: ‘0’,bottom: ‘12%’},xAxis: [{type: ‘category’,data: [‘02.25’, ‘02.26’, ‘02.27’, ‘02.28’, ‘03.01’, ‘03.02’, ‘03.02’, ‘02.25’, ‘02.26’, ‘02.27’, ‘02.28’, ‘03.01’, ‘03.02’, ‘今天’],axisLine: {lineStyle: {color: ‘rgba(255,255,255,0.12)’}},position: ‘top’,axisLabel: {color: function(params) {//通过判断选中的名字改变柱子的颜色样式if (checkName === params) {return ‘rgba(38,74,255,1)’;} else {return ‘rgba(38,74,255,.3)’;}},textStyle: {fontSize: 14},padding: [10, 0]},}],yAxis: [{show: false,axisLabel: {formatter: ‘{value}’,color: ‘#e2e9ff’,},axisLine: {show: false},splitLine: {lineStyle: {color: ‘rgba(255,255,255,0.12)’}}}],series: [{type: ‘bar’,data: [300, 450, 770, 203, 255, 188, 156, 300, 450, 770, 203, 255, 188, 156],// itemStyle: {//     normal: {//         color: ‘rgba(38,74,255,.3)’,//     }// },itemStyle: {normal: {label: {show: true},color: function(params) {//通过判断选中的名字改变柱子的颜色样式if (checkName === params.name) {return ‘rgba(38,74,255,1)’;} else {return ‘rgba(38,74,255,.3)’;}}}},label: {normal: {show: true,position: ‘top’,textStyle: {color: ‘#B9C5FC’,fontSize: ’12’},formatter: ‘{c}分’}}}]};chart.setOption(option);return chart;}在小程序的data里面调用这样就解决了 解决后的效果图"}
{"title": "我是如何写超大型小程序代码的？｜ 京喜小程序最佳实践", "author": "Rolan", "time": "2020-4-27 00:51", "content": "你 和一头骆驼准备穿过沙漠，前面是一眼望不到头的沙海，你的目的是要穿过 沙漠到达对面的绿洲。 现在你写的每一行代码就是往骆驼上负重。 当然，有些 负重是 必须 的，比如水和食物。可能会由于负重太多，骆驼严重拖累行程，甚至可能永远走不出沙漠。可能水和食物不够，都被饿死在中途。本文目录：有必要重申的交互原理请慎重设置 data请三思组件间如何通信友好的使用 sass不可或缺的 template & @import理解多页应用的单页应用第三方库请善待主包小程序有包大小限制，单个主包或者子包不能超过 2M，总包不能高于 12M。有大小限制，那么对于超大型小程序，就要悠着点了，否则超包那就是家常便饭了，当然小程序这个远不及浏览器的内存和性能也提醒着我们要悠着点。现在，请开始给骆驼负重！！！有必要重申的交互原理小程序的 Page 给我们提供了一个 data 对象。这个 data 对象的数据更新，则直接影响 wxml 的内容。有 vue 或者 react 开发经验的同学可能再熟悉不过了。当然小程序我们需要使用 setData 来更新数据。Page({\r\n  data: {\r\n    text: \"This is page data.\"\r\n  },\r\n  onLoad: function(options) {\r\n    // doSomething\r\n  }\r\n});\r\n这是官网上的描述：小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。简而言之，js 逻辑层的 data 的数据是需要转换成字符串，再使用 JS 脚本传输到 wxml 的视图层。文档也明确了传输不实时。实际上如果数据量大还很慢。请慎重设置 datadata 对象是类似 vue 的 data，是 reactivity 的。vue 的 reactivity 的数据，是都需要 Object.defineProperty（或者 Proxy）的。比如看到有代码，在 data 里面放大量的数据，而这些数据根本上在 wxml 里面用不上，仅仅是为了存储一个对象，在其他文件模块（同 this）的时候，能直接用。还看到在 data 里面设置 isLoading 对象，这个仅仅是为了在点击的时候做一个锁，等接口调用完成，再把 isLoading 改为 false。以上情况，在小程序代码中比比皆是。这些都有一个通病，忽略了性能，随心使用 data，导致一个页面，在 data 下设置的变量可能占满一屏的高度。那我们如何做呢？原则：只在 data 对象设置在 wxml 需要使用的变量。那么其他变量我们怎么做呢？有两种方案：1、设置在实例作用域外，脱离 Page 或者 Component 对象。let name = \"is file scope data\";\r\nPage({});\r\n2、设置在实例作用域内，但是脱离 data 对象，不需要 reactivity。a) 如果是 Page ，可以直接新增一个 customData，Page({\r\n    data:{\r\n        name:\"reactivity data\"\r\n    },\r\n    customData: {\r\n        name: 'not reactivity data'\r\n    }.\r\n});\r\nb) 如果是 Component，可以使用 pureData。Component({\r\noptions: {\r\n  pureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段\r\n},\r\ndata: {\r\n  name: \"is reactivity\",\r\n  _name: \"is pureData\",\r\n},\r\n经过实验证明，对于逻辑复杂，数据量大的页面，很好的优化你的 data，对性能提升比较明显。请三思组件间如何通信组件间通信方式：子组件向父组件：triggerEvent父组件向子组件：props父组件向子组件：selectComponent订阅发布模式：emit、on当前前三者，都是小程序直接提供的方式，第四种我们需要写一个公共的 emitter 组件。下面我们来分析下这种情况。1.triggerEvent子组件向父组件通信，这种在开发中非常常见，子组件响应了操作，如果需要同步给父组件，直接用 this.triggerEvent，然后在父组件中定义 bind 就行。2. props父组件向子组件传参，这种也非常常见，如果你需要传参给子组件，需要做如下两步：1、父组件需要在 reactivity 的 data 中设置数据;2、子组件需要在 props 属性中设置接收该数据对象。发现没有，如果你需要传一个参数，那么你需要在父子组件当中都设置为 reactivity 的 data 对象。显然，对于大量的传输数据对象（比如一个大型数据列表），不适合直接这样传参。因为如果这样做的话，显然增大了父子组件成本。3. selectComponent父组件直接调用子组件实例对象，然后直接执行子组件的方法，比如：子组件：Component({\r\n  methods: {\r\n    updateStatus() {}\r\n  }\r\n});\r\n父组件：this.selectComponent(\"#childComponent\").updateStatus();\r\nselectComponent，完美的解决了 props 传参的问题，微信给你另一条道路，也说明了 props 的问题。但是 props 传参方式更符合开发习惯和数据流思维。个人建议，大数据传输，直接用 selectComponent，反之用 props。4. $emit发布订阅模式，大伙都很熟悉了。注册 on(\"key\", () => {})，发布 emit(\"key\", data)。这种方式的优点很明显，完全突破组件直接的关系。任何地方都可以监听，都可以发布。缺点则是无状态的，和组件实例无关，且是全局的。如果页面打开了两个 Page，比如 商祥 -> 店铺 -> 商祥 ，这个时候，如果商详接受到一个消息，两个商祥 Page 都会收到。发布订阅模式需要注意四点：key 是全局的，好好命名。接收消息的区分是不是该实例的。销毁注册消息通常是全部的。A 监听 key,B 监听 key,如果执行 remove(key)，则 key 都会清除。如果不支持粘性事件则需要关注发布订阅时机。（当然你可以选择不把 EventBus 放到全局）友好的使用 sass样式文件，我们一般使用预处理，比如 sass。我们看如下例子。<view class=\"recommend\">\r\n    <view class=\"recommend_header\">\r\n        <view class=\"recommend_header_author\">\r\n            <view class=\"recommend_header_author_img\"></view>\r\n            <view class=\"recommend_header_author_info\">\r\n                <view class=\"recommend_header_author_info_name\"></view>\r\n                <view class=\"recommend_header_author_info_location\"></view>\r\n            </view>\r\n        </view>\r\n        <view class=\"recommend_header_follow\"></view>\r\n    </view>\r\n    <view class=\"recommend_footer\">\r\n    </view>\r\n</view>\r\n.recommend {\r\n  &_header {\r\n    &_author {\r\n      &_img {\r\n      }\r\n      &_info {\r\n        &_name {\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n上述结构和样式，看不出啥，我们经常在 H5 页面的时候都是如此做的，按照页面模块和层级定义结构，使用 sass 逐层写样式，这可以说是标准写法，语义和结构清晰，但是在超大型小程序中，我要 say No!我们知道，sass 是 css 预处理器，最终是需要转换成 css 被浏览器和微信小程序识别。我们看下转换后的样式文件.recommend {\r\n}\r\n.recommend .recommend_header {\r\n}\r\n.recommend .recommend_header .recommend_header_author {\r\n}\r\n.recommend .recommend_header .recommend_header_author {\r\n}\r\n.recommend\r\n  .recommend_header\r\n  .recommend_header_author\r\n  .recommend_header_author_info {\r\n}\r\n.recommend\r\n  .recommend_header\r\n  .recommend_header_author\r\n  .recommend_header_author_info\r\n  .recommend_header_author_info_name {\r\n}\r\n看了之后有没有觉得你哪里不对？重复的 class 太多了，看到这么多重复的，JS 开发人员第一反应：提炼抽取才是正道。想想我们大几十行研发人员开发的小程序，功能如此之多，体积如此之珍贵，岂能如此浪费。回归到 sass，我们使用样式层级作用域的目的是啥呢？我认为无非是绝对标识该样式，类似 js 的作用域，不被其他模块的样式影响，然后能够清晰的定义样式。试想，如果张三在页面 header 模块的用户昵称，定义成 .name，那么李四在 content 模块的用户昵称也可能会被定义成 .name，然而这两个样式完全不一样，但是样式就会相互影响，李四把 .name 样式写好了，然而 header 模块的 .name 样式又不对了，这显然不是我们想要的，所以推荐把样式的名称按层级定义，不会被影响。理由很充分，sass 写起来也很舒服，但是在实际中极力不推荐严格按这种层级定义。那么在大型小程序中，推荐： 最多三级，建议两级。对应上述 wxml ，在结构不变的情况下，样式修正为如下：<view class=\"recommend\">\r\n    <view class=\"recommend_header\">\r\n        <view class=\"recommend_author\">\r\n            <view class=\"recommend_img\"></view>\r\n            <view class=\"recommend_info\">\r\n                <view class=\"recommend_name\"></view>\r\n                <view class=\"recommend_location\"></view>\r\n            </view>\r\n        </view>\r\n        <view class=\"recommend_follow\"></view>\r\n    </view>\r\n    <view class=\"recommend_footer\">\r\n    </view>\r\n</view>\r\n有人会说了，这个 header 模块用户昵称可能是 .recommend_name，但是 footer 模块也有一个用户昵称怎么办？通常一个模块是一个人维护，就算多个人修改，那么样式也只在当前模块内影响，风险完全可控。那么 footer 模块的昵称可以定义成 .recommend_footer_name，增加到第三层，甚至于我推荐直接是 .recommend_footer-name，这样在解析成 css 的时候，仍然是两层。都 21 世纪了，总想着再不断的出现爱因斯坦、牛顿等已经不太现实了。我们要 “微优化”！总结：在可读性仍然很强大的情况下，保证模块直接样式不冲突，建议控制在两层 sass,最多不超过三层。减少文件大小。在模块多的页面中，这种带来 wxml 和 css 体积的缩减其实是很可观的。template & @import根据页面划分组件，大伙都会做。然而实际上在模块中会存在很多共同的结构，但是有时候我们因为逻辑较少等原因没必要抽离成一个组件，这个时候 template 就派上大用场了。单个文件中的共同结构<template name=\"liveItem\"> </template>\r\n<template is=\"liveItem\" data=\"{{list:preLiveList}}\" />\r\n<template is=\"liveItem\" data=\"{{list:liveList}}\" />\r\n多个模块中的共同结构<import src=\"./template.wxml\" />\r\n<template is=\"goodsItem\" data=\"{{item}}\" />\r\n<template is=\"goodsItem\" data=\"{{item}}\" />\r\n当然，wxml 抽离成模块引入了，那么 css 自然也需要抽离成公共的文件。@import \"../../common/common.wxss\";\r\n按照经验，一个呈现稍微复杂一点的页面，如果没有存在 template 和 公共引入 css 文件，大概率重复代码不少。当然，如果你很乐意把组件拆的足够细的话（component 渲染性能慢的问题指南），那么也是可以规避这个问题，但是实际上可能有些代码量反而还增多了， 合理 template 才是正确姿势。理解多页应用的单页应用小程序是一个多页面应用，各个模块独立开发，整个系统是多个 Pages 组成的，但是和我们常规的 H5 不同，访问多个页面之后，这些页面是共存的。访问 A 页面 -> 访问 B 页面，此时 A 页面是仍然在运行，只不过是 hide 的。既然多个页面都存在，但是当前 active 的只有一个页面，因此我们仍然要做一些单页面应用需要做的事，比如：1、停止更新数据 直播的点赞动画，如果当前页面不是 onShow 的，就不要去更新动画了，节省点 CPU 吧！2、及时回收定时器 在 A 页面开启了定时器，显示倒计时，但是到 B 页面了，A 页面的倒计时就没有意义了，应该及时回收和清除。当然如果你需要在页面返回到 A 页面的时候，仍然能看到倒计时，那么请在 onShow 的时候唤醒倒计时，onHide 的时候清除倒计时。只管利用，不善后的可不是好学生哦！3、及时清除不必要的资源。当前访问 A 页面，然后返回，再次访问 A 页面，那么页面的非实例对象数据是不会清除的，我们需要手动清除对象，释放资源，防止重复注册等操作。第三方库第三方库用起来爽呀，一个看起来不简单的三下五除二就搞定了，能不爽吗？比如我们使用 vue 开发页面，有轮播图，引用第三方 swiper，我们需要做时间处理，引用 moment。本人开发这么多页面和系统，这些组件很少引用，我的做法是明确我的需求，如果有类似的，然后不会写的，那么阅读下源码，自己写下就行。因为我知道，开发的组件都是支持最全面的，实际上你根本不需要这么多，比如格式化时间，你的需求可能就是实际十几行代码的事情，为啥要引入一个第三方组件呢？同理一个 swiper，别人支持的各种各种需求，你的可能只是需要普通的滑动切换就行了，为啥要引入强大的第三方组件呢？当然如果第三方组件可以支持良好的 tree-shaking 就另当别论。在 H5 时代，我一般不轻易引入第三方库，对于他人代码我也是持保留意见。但是在大型小程序时代，我是坚决反对用啥直接引用啥。毕竟 【体积 & 内存 & 性能】三座大山摆在眼前。请善待主包如果直接打开子包链接，那么是需要下载 主包 + 当前子包，然后才能访问页面。那么主包的下载对页面首屏的打开，就显得至关重要了。按照我们 H5 开发的逻辑，公共代码都需要抽离成独立的模块，方便共用。但是小程序场景有点不一样。A 子包 require goodsModuleB 子包 require goodsModule这个时候，将 goodsModule 抽离出来，放在主包（因为子包直接相互引用的问题）。看起来一切顺其自然。然而，如果你遵循上面的方案，那么你会发现，在超大型的小程序中，会有大量的 Modules 被放到主包，导致主包严重不足。那如何解决这个问题？我们可以使用 NPM 功能。思想仍然会是模块单独下载，访问了 A 页面，下载 A 子包，然后再访问 B 页面，下载 B 子包。尽管 A 和 B 子包有重复下载的代码。那什么情况放在主包呢？1、主包 Pages 已经有引用了2、至少有三个及以上的子包引用同样的模块善待主包，兼顾总包！:heart: 看完三件事如果你觉得这篇内容对你挺有启发，我想邀请你帮我三个小忙：点赞，让更多的人也能看到这篇内容（收藏不点赞，都是耍流氓 -_-）关注公众号「前端劝退师」，不定期分享原创知识。也看看其它文章劝退师个人微信： huab119也可以来我的 GitHub 博客里拿所有文章的源文件：前端劝退指南：https://github.com/roger-hiro/BlogFN 一起玩耍呀。~"}
{"title": "如何在微信小程序中嵌入html网页信息", "author": "Rolan", "time": "2020-4-28 00:09", "content": "最近公司有一个项目需要使用到拍照出现虚线引导框的功能,但是在html中只有安卓系统的微信单可以实现此功能,所有这时候我们发现微信小程序有自定义拍照的功能,这时候我们就想到将html网页信息嵌入到微信小程序中一:在微信小程序中嵌入html网页文档地址： https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html在微信小程序中我们可以使用web-view标签实现在小程序中嵌入html网页，如<web-view src=\"https://www.baidu.com\"></web-view>这样就可以实现将html网页信息嵌入微信小程序了,这里注意,当我们使用微信小程序正式号时,这时候我们需要将html信息的链接地址加入到微信小程序的业务域名中二：从html页面跳转到微信小程序页面当我们的html页面处理完成之后,这时候我们需要跳转到微信小程序的页面的话，这时候我们就需要使用到微信小程序提供的跳转方法了前提:在html 中我们需要引入下面的jshttps://res.wx.qq.com/open/js/jweixin-1.3.2.js然后我们可以使用如下方法实现从html跳转到微信小程序wx.miniProgram.navigateTo({url: '/pages/test/test'})  \r\nwx.miniProgram.navigateTo({url: '/pages/test/test?id=1'})"}
{"title": "小程序开发的一些细节，你有注意吗？", "author": "Rolan", "time": "2020-4-28 00:11", "content": "最近的弄的小程序差不多有点东西了，就来写一些关于小程序的感悟吧01 前言一般来说，我认为小程序是一个没有什么技术含量的东西，特别是现在有了组件库，而且小程序生态不断完善的情况下，只要对着文档慢慢写就好，就是时间的问题。然后这里也不是教大家怎么去写程序之类的，而是本人在经历过后的一些小建议。02 技术选型其实我觉得技术选型是非常重要的，直接关系到你后来的工作复杂度。怎么说呢？因为小程序的开发就是一个注重业务逻辑的过程，它与算法研究类的研发工作不同。小程序的质量高不高，用户体验好不好完全取决于你的页面设计，页面的交互。所以我觉得在选型的过程中有几个特别值得注意的：组件库支持框架生态框架语法基本上就是这些，首先来说一下第一个关于组件库的支持。组件库支持现在的 组件库 特别多，基本上是可以满足我们日常开发的需要，之前我写了一篇关于《 前端人应该掌握的工具 》里面有写到，大家感兴趣的可以去看一下。可以说组件就是整个程序的重要部分，因为假如你 自己写的话肯定会花费大量的时间 ，即使你已经写出来了可能也就是自己能用，兼容性也会有问题。所以关于组件的开发就 不推荐自己造轮子 了，我们还没有这样的时间和精力。但是我们也不能随便去选择一个组件库，我们必须要 根据小程序的页面设计 ，详细列出里面所有的元素到底是采用何种方法/组件实现的，你 选择的组件库是否所有都满足 。还有一个重要的是，组件库的 社区反馈 如何，有没有很多不可避免的BUG在里面。这一点自己也深有体会，因为组件的兼容性问题，自己往往会花费几天时间来做 兼容和适配 。现在我是选择了 mpvue+vant 的形式来写的。设计图上面的navbar是自定义而且是固定顶部的，一开始也没有怎么注意，觉得没有问题。但是，在我切换不同的机型的时候问题就出来了，各种对不齐的情况接踵而来，特别是苹果系列的机型（刘海屏）。起初我想过自己去适配一下，但是发现头发一直掉，应该在提醒我不能这么搞了。后面就在github找到了一个可以适配的navbar组件，解决了我的问题。也从侧面说明不能自己造轮子。框架生态因为最终还是要编译成官方的小程序格式，难免会有一些问题。所以我们选择一个小程序框架的时候也要考虑到这个问题，看 它与官方的区别 在哪，有哪一些是不支持的，看一下 社区对它的评价如何 。基本上我们 选择一些用户反馈比较积极 的就好， 不要选一些新兴的框架 ，因为往往也是坑比较多，而且你有时候发邮件问他们几个世纪都不回你的。如何选择一个比较好的框架呢？可以看文章的最后github仓库，里面有很多关于小程序的资料，也有一些框架的排名和组件库选择。框架语法语法部分还不是最主要的，因为 前端的语法 都一样，那我说这个的目的其实是说小程序的开发语法与官方的语法有 哪些不兼容 的，要注意一下，一般文档都会给出来的。目前小程序的开发都可以使用vue语法来编写，可以说是非常方便了，但是如果你不熟悉 小程序的生命周期 与 vue的生命周期就 可能会有一些问题。我遇到的问题就是怎么合理使用生命周期函数。有时候你的程序可能会报一些奇怪的错误， 比如提示图片加载失败，然后图片又显示正常 。其实这就是页面渲染的时候还没有识别到图片的原因，是后面加载的，这就是先后的问题。03 开发步骤前期就是一些架构设计以及技术选型的内容，前期的选择尤为重要，技术选型好，后面你会节省很多时间和工作量。代码结构设计开发步骤也要设计，你要规划一些目录结构，比如存放 组件的 、 图片的 、 工具类函数的 、 页面类 的等。虽然说我们的初始化项目都会有相应的目前结构，但是你也要在它的基础上进行稍微的改造。让我们的目前更加清晰。一般来说我们就从我提到的 组件 、 图片 、 工具 、 页面 几个步骤出发。页面部分我们基本上不用怎么改，因为项目初始化都帮你设计好了。组件部分我们就新建一个组件文件夹，用于存放我们的自定义组件，方便后期的复用。值得注意的是，我们一定要 写好组件 ，让我们的 复用效率更高 ，可以通过 传参的形式来控制组件的形态 。关于图片的存储我的建议就是可以 从功能上来划分 ，比如tabbar的图片，navbar的图片，其他的图片也是按照自己的功能来进行划分，这样就显得 逻辑结构清晰 ，后续的 维护 更加方便容易。项目的配置这一方面的话看你的 具体业务需求 怎么样，一般来说我们经常都会调用 第三方库函数/接口 ，如定位等。现在我做的这一个就用到了腾讯地图的第三方接口，这里就不再详细展开。我做的时候会出现域名不合法的情况，你需要在 小程序后台进行域名的配置 ，报错信息都告诉你怎么配置了，把那个域名加上去就好。又或者你的后台请求接口有错误的话一般就是你的接口 域名不是https协议 ，这就有点麻烦了，调试阶段可以在开发者工具的右上角详情部分， 勾上不检验 就好。但是如果你要上线的话就需要有https的服务器放置你的接口了。04、小结好了，以上就是就本次项目的相关总结，但是项目本身还是没有完善的，我也是在早期的设计上面下了一些功夫，主要还是让自己在后面的开发过程中少一些BUG和错误，方便自己后期的维护。其实业务类的小程序更要主要组件的开发和设计，因为很多页面都会公用一个组件，假如你是复制粘贴那也未尝不可，只是维护比较难而已。我们做每一个产品，在必不得已的情况下才会使用一些技巧性的东西，一般来说都会做成一个可伸缩、可维护的产品，也是对自己的要求。小程序仓库： https://github.com/justjavac/awesome-wechat-weapp"}
{"title": "使用银联商务实现微信小程序支付", "author": "Rolan", "time": "2020-4-28 00:32", "content": "最近公司的小程序需要使用到支付功能，我们使用的是银联商务的支付，那么如何在微信小程序中对接银联商务的微信小程序支付呢？这里我记录下我在微信小程序中实现银联商务的微信小程序支付流程一：接口部分：这里注意银联商务的小程序支付目前不支持测试号支付，只有使用正式的参数实现小程序支付1：银联商务的小程序支付接口地址：https://qr.chinaums.com/netpay-route-server/api/2：主要参数说明：(1)：msgSrc消息来源：如：WWW.TEST.COM(2)：msgType消息类型：微信小程序支付参数固定为：wx.unifiedOrder(3)：mid商户号(4)：tid终端号(5)：requestTimestamp报文请求时间，格式yyyy-MM-dd HH:mm:ss(6)：merOrderId订单号，这里注意传递给银联商务的订单号的前缀必须是来源编号，例如测试号的来源编号为3194，那么这里的订单号就必须是以3194开头(7)：instMid机构商户号,这里固定为：MINIDEFAULT(8)：totalAmount订单金额，这里的单位为分，例如一元的话，此参数就为100(9)：tradeType交易类型：这里固定为MINI(10)：signType签名算法：这里的参数有三种分别为MD5,SHA1,RSA，这里我使用的是MD5(11)：subOpenId支付用户openid(12)：notifyUrl支付结果通知地址，及异步回调地址，这里注意：支付通知地址必须是伪静态地址，例如: XXXXX/back/index，不能是XXXX/index.php?r=back/index(13)：sign签名，将上面的参数按照a-z的顺序进行排序，排序完成之后用&字符连接起来，连接起来之后如果存在转义字符，那么去掉转义字符，然后进行md5加密获取到签名接口端微信小程序下单的简单实例如下:$url = 'https://qr.chinaums.com/netpay-route-server/api/';  \r\n$requestTimestamp = date('Y-m-d H:i:s',time());  \r\n$data = [  \r\n    'msgSrc' => 'XXX',//消息来源  \r\n    'msgType' => 'wx.unifiedOrder',//消息类型  \r\n    'requestTimestamp' => $requestTimestamp,  \r\n    'mid' => 'XXX',  \r\n    'tid' => 'XXX',  \r\n    'merOrderId' => 'XXX',  \r\n    'instMid' => 'MINIDEFAULT',  \r\n    'totalAmount' => 1,  \r\n    'tradeType' => 'MINI',  \r\n    'signType' => 'MD5',  \r\n    'subOpenId' => 'XXX',  \r\n    'notifyUrl' => 'XXX',//回调地址  \r\n];  \r\n//获取sign参数  \r\nksort($data);  \r\nreset($data);  \r\n$options = '';  \r\nforeach ($data as $key => $value) {  \r\n    $options .= $key . '=' . $value .'&';  \r\n}  \r\n$options = rtrim($options, '&');  \r\n//存在转义字符，那么去掉转义  \r\nif(get_magic_quotes_gpc()){  \r\n    $options = stripslashes($options);  \r\n}  \r\n$sign = md5($options . $params['mdKey']);  \r\n$data['sign'] = $sign;  \r\n//调用银联商务的微信小程序下单接口  \r\n$client = new Client();  \r\n$response = $client->createRequest()  \r\n    ->setMethod('POST') // 请求方式  \r\n    ->setUrl($url)      // 请求地址  \r\n    ->setData($data)    //数据传数组  \r\n    ->setHeaders(['Content-Type'=>'application/json']) //header  \r\n    ->setFormat(Client::FORMAT_JSON) //提交的数据的格式  \r\n    ->send();  \r\nif (!$response->isOk) {  \r\n    return [  \r\n        'type' => 'error',  \r\n        'message' => '支付调用失败'  \r\n    ];  \r\n}  \r\nif ($response->data\\['errCode'] == 'SUCCESS') {  \r\n    return [  \r\n        'type' => 'success',  \r\n        'message' => '支付调用成功',  \r\n        'data' => $response->data\\['miniPayRequest'\\],//小程序支付用的请求报文，带有签名信息  \r\n    ];  \r\n} else {  \r\n    return [  \r\n        'type' => 'error',  \r\n        'message' => '支付调用失败' . $response->data['errMsg']  \r\n    ];  \r\n}二：小程序端：银联商务接口返回的miniPayRequest参数包含了微信小程序调用支付的所有参数，所以我们在微信小程序端只需要见接口中的数据填充进去就可以实现微信小程序支付了//这里的payData就是接口返回的data参数  \r\nwx.requestPayment({  \r\n  timeStamp: payData.timeStamp,  \r\n  nonceStr: payData.nonceStr,  \r\n  package: payData.package,  \r\n  signType: payData.signType,  \r\n  paySign: payData.paySign,  \r\n  success: (res) => {  \r\n    //支付成功处理  \r\n  },  \r\n  fail: (res) => {  \r\n    //支付失败处理  \r\n  }  \r\n})这里我们就实现了在微信小程序中对接银联商务支付了，微信小程序的支付对调是post传值，具体信息如下:可以根据你项目的具体需求进行处理即可，这里注意在回调的结尾需要输入SUCCESS或FAILED，不然的话可以会出现对此通知的现象"}
{"title": "小程序自定义导航栏，兼容适配所有机型（附完整案例）", "author": "Rolan", "time": "2020-4-28 00:41", "content": "大部分情况下我们都是使用微信官方自带的 navigationBar 配置 ，但有时候我们需要在导航栏集成搜索框、自定义背景图、返回首页按钮等。思路隐藏官方导航栏获取胶囊按钮、状态栏相关数据以供后续计算根据不同机型计算导航栏高度编写新的导航栏页面引用自定义导航正文隐藏官方导航栏隐藏导航栏可以全局配置，也可以单独页面配置，具体根据业务需求来。全局隐藏//app.json\r\n\"window\": {\r\n   \"navigationStyle\": \"custom\"\r\n}\r\n复制代码页面隐藏//page.json\r\n{\r\n  \"navigationStyle\": \"custom\"\r\n}\r\n复制代码获取胶囊按钮、状态栏相关数据以供后续计算公式：导航栏高度 = 状态栏到胶囊的间距（胶囊距上边界距离-状态栏高度） * 2 + 胶囊高度 + 状态栏高度。 由公式得知，我们需要获取 状态栏高度 胶囊高度 胶囊距上距离注：状态栏到胶囊的间距 = 胶囊到下边界距离。所以这里需要*2状态栏高度用 wx.getSystemInfoSync() 官方API 可以获取系统相关信息， statusBarHeight 属性可以获取到状态栏高度const statusBarHeight = wx.getSystemInfoSync().statusBarHeight;\r\n复制代码胶囊高度和胶囊距上边界距离用 wx.getMenuButtonBoundingClientRect() 官方API 可以获取菜单按钮胶囊按钮的布局位置信息。const menuButtonInfo = wx.getMenuButtonBoundingClientRect();//胶囊相关信息\r\nconst menuButtonHeight = menuButtonInfo.height //胶囊高度\r\nconst menuButtonTop = menuButtonInfo.top//胶囊距上边界距离\r\n复制代码实例一般情况下，我们需要在运用启动的初始化生命周期钩子进行计算相关的数据，也就是入口文件 app.js 的 onLaunch 生命周期钩子//app.js\r\nApp({\r\n  onLaunch: function () {\r\n    this.setNavBarInfo()\r\n  },\r\n  \r\n  globalData: {\r\n    //全局数据管理\r\n    navBarHeight: 0, // 导航栏高度\r\n    menuBotton: 0, // 胶囊距底部间距（保持底部间距一致）\r\n    menuRight: 0, // 胶囊距右方间距（方保持左、右间距一致）\r\n    menuHeight: 0, // 胶囊高度（自定义内容可与胶囊高度保证一致）\r\n  },\r\n\r\n  /**\r\n   * @description 设置导航栏信息\r\n   */\r\n  setNavBarInfo () {\r\n    // 获取系统信息\r\n    const systemInfo = wx.getSystemInfoSync();\r\n    // 胶囊按钮位置信息\r\n    const menuButtonInfo = wx.getMenuButtonBoundingClientRect();\r\n    // 导航栏高度 = 状态栏到胶囊的间距（胶囊距上距离-状态栏高度） * 2 + 胶囊高度 + 状态栏高度\r\n    this.globalData.navBarHeight = (menuButtonInfo.top - systemInfo.statusBarHeight) * 2 + menuButtonInfo.height + systemInfo.statusBarHeight;\r\n    this.globalData.menuBotton = menuButtonInfo.top - systemInfo.statusBarHeight;\r\n    this.globalData.menuRight = systemInfo.screenWidth - menuButtonInfo.right;\r\n    this.globalData.menuHeight = menuButtonInfo.height;\r\n  }\r\n})\r\n复制代码页面引用自定义导航//page.wxml\r\n<view class=\"nav\" style=\"height:{{navBarHeight}}px;\">\r\n  <!-- 胶囊区域 -->\r\n  <view class=\"capsule-box\" style=\"height:{{menuHeight}}px; min-height:{{menuHeight}}px; line-height:{{menuHeight}}px; bottom:{{menuBotton}}px;\">\r\n    <view class=\"nav-handle\">\r\n      <image class=\"nav-back-icon\" src=\"/images/nav_back.png\" bind:tap=\"navToBackLastPage\"></image>\r\n      <image class=\"nav-home-icon\" src=\"/images/nav_home.png\" bind:tap=\"navToHomePage\"></image>\r\n    </view>\r\n    <view class=\"nav-title\">导航标题</view>\r\n  </view>\r\n</view>\r\n复制代码// page.js\r\nconst app = getApp()\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    navBarHeight: app.globalData.navBarHeight,//导航栏高度\r\n    menuBotton: app.globalData.menuBotton,//导航栏距离顶部距离\r\n    menuHeight: app.globalData.menuHeight //导航栏高度\r\n  }\r\n\r\n复制代码封装成组件我们可能在各自的页面实现不一样的效果，比如在导航栏添加搜索框，日期等，这个时候我们就可以封装一个自定义组件，大大提高我们的开发效率。新建component// components/navigation/index.wxml\r\n<view class=\"nav\" style=\"height:{{navBarHeight}}px;\">\r\n  <view class=\"nav-main\">\r\n    <!-- 胶囊区域 -->\r\n    <view \r\n      class=\"capsule-box\" \r\n      style=\"height:{{menuHeight}}px; min-height:{{menuHeight}}px; line-height:{{menuHeight}}px; bottom:{{menuBotton}}px;left:{{menuRight}}px;\"\r\n    >\r\n    <!-- 导航内容区域 -->\r\n      <slot></slot>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码// components/navigation/index.wxss\r\n.nav {\r\n  position: fixed;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100vw;\r\n}\r\n.nav-main {\r\n  width: 100%;\r\n  height: 100%;\r\n  position: relative;\r\n}\r\n.nav .capsule-box {\r\n  position: absolute;\r\n  box-sizing: border-box;\r\n  width: 100%;\r\n}\r\n\r\n复制代码// components/navigation/index.js\r\nconst app = getApp()\r\nComponent({\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n    navBarHeight: app.globalData.navBarHeight, //导航栏高度\r\n    menuRight: app.globalData.menuRight, // 胶囊距右方间距（方保持左、右间距一致）\r\n    menuBotton: app.globalData.menuBotton,\r\n    menuHeight: app.globalData.menuHeight\r\n  }\r\n})\r\n复制代码页面引用页面配置引入该自定义组件//index.json\r\n{\r\n  \"navigationStyle\": \"custom\",\r\n  \"navigationBarTextStyle\": \"white\",\r\n  \"usingComponents\": {\r\n    \"navigation\": \"/components/Navigation/index\"\r\n  }\r\n}\r\n复制代码页面中使用<!-- 自定义导航 -->\r\n<navigation>\r\n  <view class=\"current-date\">\r\n     <text>4月24日</text>\r\n  </view>\r\n</navigation>\r\n复制代码总结本文主要是写自定义导航基础的东西，重点在于怎么计算自定义导航的，具体的业务和样式还需要根据自身产品来设定。如有什么问题，欢迎提出一起学习。"}
{"title": "微信小程序自定义组件 - 表格组件来啦", "author": "Rolan", "time": "2020-4-29 00:02", "content": "针对上期打卡需求开发，这期需要以列表的形式展现打卡记录，但是微信小程序并没有表格组件，可能是官方考虑到,在前端开发中，表格一直都是最复杂的组件之一就没有实现吧。没有现成的组件可以使用，针对这个问题，目前有两种解决方案：table组件\r\ntable组件\r\n第一期打卡采用的原生开发的，老板期望第二期需求也能用原生，方便后期的维护。于是乎，我就开始了造轮子啦:joy:。需要table组件满足一下功能：主要用于展示结构化数据；支持自定义操作；支持自定义表头样式；支持固定表头，可左右滚动等功能。table组件效果展示miniprogram-table-component 小程序自定义table组件使用此组件需要依赖小程序基础库 2.2.2 版本，同时依赖开发者工具的 npm 构建。具体详情可查阅 官方 npm 文档 。1.基础表格2.带斑马纹表格3.带间隔边框表格4.自定义无数据的提示文案5.自定义表格头样式6.固定表头7.表格横向滑动8.自定义表格行和单元格样式快速上手一个简易的微信小程序 table组件 诞生了。新鲜热乎的，前面看完了展现效果，接下来介绍使用。 自定义的 table 组件，使用很简单，就是按照npm包和微信自定义组件的方法使用。1、安装和引入安装组件：npm install --save miniprogram-table-component\r\n复制代码引入table自定义组件在页面的 json 配置文件中添加 recycle-view 和 recycle-item 自定义组件的配置{\r\n  \"usingComponents\": {\r\n    \"table-view\": \"../../../miniprogram_npm/miniprogram-table-component\"\r\n  }\r\n}\r\n复制代码注意：npm包的路径。如果这里遇到找不到包的问题，可以查看下方的 微信小程序 npm 找到不到npm包的坑？2、使用table组件在wxml页面需要用到的地方使用，如下：<table \r\n    headers=\"{{tableHeader}}\" \r\n    data=\"{{ row }}\" \r\n    stripe=\"{{ stripe }}\"\r\n    border=\"{{ border }}\"\r\n/>\r\n复制代码在js页面需要用到的地方使用，如下：Page({\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    tableHeader: [\r\n      {\r\n        prop: 'datetime',\r\n        width: 150,\r\n        label: '日期',\r\n        color: '#55C355'\r\n      },\r\n      {\r\n        prop: 'sign_in',\r\n        width: 152,\r\n        label: '上班时间'\r\n      },\r\n      {\r\n        prop: 'sign_out',\r\n        width: 152,\r\n        label: '下班时间'\r\n      },\r\n      {\r\n        prop: 'work_hour',\r\n        width: 110,\r\n        label: '工时'\r\n      },\r\n      {\r\n        prop: 'statusText',\r\n        width: 110,\r\n        label: '状态'\r\n      }\r\n    ],\r\n    stripe: true,\r\n    border: true,\r\n    outBorder: true,\r\n    row: [\r\n      {\r\n          \"id\": 1,\r\n          \"status\": '正常',\r\n          \"datetime\": \"04-01\",\r\n          \"sign_in_time\": '09:30:00',\r\n          \"sign_out_time\": '18:30:00',\r\n          \"work_hour\": 8,\r\n      }, {\r\n          \"id\": 2,\r\n          \"status\": '迟到',\r\n          \"datetime\": \"04-02\",\r\n          \"sign_in_time\": '10:30:00',\r\n          \"sign_out_time\": '18:30:00',\r\n          \"work_hour\": 7,\r\n      }, {\r\n          \"id\": 29,\r\n          \"status\": '正常',\r\n          \"datetime\": \"04-03\",\r\n          \"sign_in_time\": '09:30:00',\r\n          \"sign_out_time\": '18:30:00',\r\n          \"work_hour\": 8,\r\n      }, {\r\n          \"id\": 318,\r\n          \"status\": '休息日',\r\n          \"datetime\": \"04-04\",\r\n          \"sign_in_time\": '',\r\n          \"sign_out_time\": '',\r\n          \"work_hour\": '',\r\n      }, {\r\n          \"id\": 319,\r\n          \"status\": '正常',\r\n          \"datetime\": \"04-05\",\r\n          \"sign_in_time\": '09:30:00',\r\n          \"sign_out_time\": '18:30:00',\r\n          \"work_hour\": 8,\r\n      }\r\n    ],\r\n    msg: '暂无数据'\r\n  },\r\n\r\n  /** \r\n   * 点击表格一行\r\n   */\r\n  onRowClick: function(e) {\r\n    console.log('e: ', e)\r\n  }\r\n})\r\n复制代码3、配置配置部分主要配置这么几个属性，分别是：配置项说明类型可选值默认值必填headers表格头部标题、列宽度、列属性Array{prop: 'datetime', width: 150, label: '日期'}[]yesdata表格列表数据Array[]nostripe是否为斑马纹booleantrue/falsefalsenoborder是否有间隔线booleantrue/falsefalsenoheight纵向内容过多时，可选择设置高度固定表头。stringautonomsg固定无数据情况，展示文案string暂无数据～noheader-row-class-name自定义表格头样式stringnorow-class-name自定义表格行样式stringnocell-class-name自定义单元格样式stringnobind:rowHandle行被点击时会触发该事件functionno配置相关代码:chestnut:：<table  \r\n      header-row-class-name=\"header-class\"\r\n      row-class-name=\"row-class\"\r\n      cell-class-name=\"cell-class\"\r\n      headers=\"{{tableHeader}}\" \r\n      data=\"{{ row }}\" \r\n      stripe=\"{{ stripe }}\"\r\n      height=\"{{ height }}\"\r\n      border=\"{{ border }}\"\r\n      bind:rowClick=\"onRowClick\"\r\n      bind:cellClick=\"onCellClick\" \r\n      no-data-msg=\"{{ msg }}\"\r\n/> \r\n复制代码header-row-class-name 、 row-class-name 、 cell-class-name 是通过externalClasses支持外部样式，在父组件中控制表格的样式， externalClasses外部样式类, 官方说明 。例子源码通过 github地址 查看。实现一个自定义表格组件遇到的坑npm 登录不上和发布不了的问题?之前也发布过 npm 包，遗忘了 npm login 登录不上需要将淘宝镜像改回npm的。还有一点需要注意的是，每次发布都需要更新 package.json 文件里的版本号。微信小程序 npm 找到不到npm包的坑？组件开发完，引入使用的时候，发现npm的包，找不到了？这里比较坑的是小程序的npm有特殊的使用方式。首先在项目的根目录初始化 npm:npm init -f \r\n复制代码然后安装对应的自定义组件包npm install -production miniprogram-table-component\r\n复制代码npm/cnpm/yarn add 均可在微信开发者工具中，设置 —> 项目设置—> 勾选使用npm模块。在微信开发者工具中，工具 —> 构建npm，构建完成会生成 miniprogram_npm 文件夹，项目用到的npm包都在这里。按照自己的使用路径，从 miniprogram_npm 引入需要的包。table组件源码table组件npm地址github地址需求开发时间比较紧迫，也是尽量提高工作效率，把大块时间用来封装组件了。爱越折腾啊，也算是适当给自己的项目增加点难度，多一点追求，技术就会成长的更快。"}
{"title": "小程序集成eslint和prettier，代码风格统一", "author": "Rolan", "time": "2020-4-14 00:21", "content": "微信小程序、支付宝小程序、钉钉小程序都可以适用LZ用的是钉钉小程序，很完美首先你要有vscode这个首先目录结构是这样的一定要src里面放小程序的文件夹，如果全部放在一起，会导致小程序上传过大的问题，我刚开始就吃了这个坑，居然打包了40多m，根本传不上去，后来放在src文件夹下面就解决了，让小程序直接去访问src文件夹{\r\n  \"private\": true,\r\n  \"name\": \"dingproject\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"app.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\r\n    \"precommit\": \"lint-staged\",\r\n    \"clean\": \"rm -rf dist/*\",\r\n    \"lint\": \"eslint -c .eslintrc ./src\"\r\n  },\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {},\r\n  \"devDependencies\": {\r\n    \"babel-eslint\": \"^8.2.1\",\r\n    \"eslint\": \"^3.12.1\",\r\n    \"eslint-config-prettier\": \"^2.9.0\",\r\n    \"eslint-plugin-html\": \"^3.0.1\",\r\n    \"eslint-plugin-import\": \"^2.8.0\",\r\n    \"eslint-plugin-prettier\": \"^2.3.1\",\r\n    \"lint-staged\": \"^6.0.0\",\r\n    \"prettier\": \"^1.8.2\"\r\n  },\r\n  \"lint-staged\": {\r\n    \"src/**/*.js\": [\r\n      \"eslint --fix\",\r\n      \"git add\"\r\n    ]\r\n  }\r\n}.eslintrc 文件{\r\n    \"extends\": [\r\n      \"prettier\",\r\n      \"prettier/standard\"\r\n    ],\r\n    \"useTabs\": false,\r\n    //插件\r\n    \"plugins\": [\r\n      \"prettier\"\r\n    ],\r\n   \r\n    //配置解析器\r\n    \"parser\":\"babel-eslint\",\r\n    \"parserOptions\": {\r\n      \"ecmaVersion\": 6,\r\n      \"sourceType\":\"module\",\r\n    },\r\n   \r\n    \"env\": {//脚本目标的运行环境\r\n      \"browser\":true,\r\n      \"node\":true,\r\n      \"es6\":true,\r\n      \"commonjs\":true\r\n    },\r\n   \r\n    //全局变量\r\n    \"globals\": {\r\n\"__DEV__\":true,\r\n\"__WECHAT__\":true,\r\n\"__ALIPAY__\":true,\r\n\"App\":true,\r\n\"Page\":true,\r\n\"Component\":true,\r\n\"Behavior\":true,\r\n\"wx\":true,\r\n\"getApp\":true,\r\n    },\r\n   \r\n    //规则，只用插件：插件名/规则\r\n    \"rules\": {\r\n\"prettier/prettier\":\"error\",\r\n\"no-console\": 0\r\n    }\r\n  }然后 npm i 安装一下即可npm run lint如何让vscode 可以保存自动并校准文件，可以参考我下一篇文章如何让eslint自动保存并修改不合规范的文件"}
{"title": "完整微信小程序授权登录页面教程", "author": "Rolan", "time": "2020-4-14 00:26", "content": "1、前言\r\n微信官方对getUserInfo接口做了修改，授权窗口无法直接弹出，而取而代之是需要创建一个button，将其open-type属性绑定getUseInfo方法。在参考了网路上各种方案之后，实现了用户在授权之后跳转到小程序首页的授权登录页面。\r\n2、实现效果\r\n\r\n\r\n3、实现思路\r\n在进入小程序时先对授权情况进行判断，若已经过授权则直接跳转到首页，若还未经过授权则进入授权页面，点击页面的授权按钮会弹出选择框，选择“拒绝”则不进行跳转，选择“允许“则进行授权并跳转到小程序首页。\r\n4、实现代码\r\n<!--login.wxml-->\r\n<view wx:if=\"{{canIUse}}\">\r\n  <view class='header'>\r\n    <image src='/assets/tasks_icon/check.png'></image>\r\n  </view>\r\n  <view class='content'>\r\n    <view>申请获取以下权限</view>\r\n    <text>获得你的公开信息(昵称，头像等)</text>\r\n  </view>\r\n  <button class='bottom' type='primary' open-type=\"getUserInfo\" lang=\"zh_CN\" bindgetuserinfo=\"bindGetUserInfo\">\r\n    授权登录\r\n  </button>\r\n</view>\r\n<view wx:else>请升级微信版本</view>\r\n复制代码//login.wxss\r\n.header {\r\n  margin: 90rpx 0 90rpx 50rpx;\r\n  border-bottom: 1px solid #ccc;\r\n  text-align: center;\r\n  width: 650rpx;\r\n  height: 300rpx;\r\n}\r\n\r\n.header image {\r\n  width: 200rpx;\r\n  height: 200rpx;\r\n}\r\n\r\n.content {\r\n  margin-left: 50rpx;\r\n  margin-bottom: 90rpx;\r\n}\r\n\r\n.content text {\r\n  display: block;\r\n  color: #9d9d9d;\r\n  margin-top: 40rpx;\r\n}\r\n\r\n.bottom {\r\n  border-radius: 80rpx;\r\n  margin: 70rpx 50rpx;\r\n  font-size: 35rpx;\r\n}\r\n复制代码//login.js\r\nPage({\r\n  data: {\r\n    //判断小程序的API，回调，参数，组件等是否在当前版本可用。\r\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\r\n  },\r\n\r\n  onLoad: function () {\r\n    var that = this;\r\n    // 查看是否授权\r\n    wx.getSetting({\r\n      success: function (res) {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          wx.getUserInfo({\r\n            success: function (res) {\r\n              // 用户已经授权过,调用微信的 wx.login 接口，从而获取code,再直接跳转到主页\r\n              wx.login({\r\n                success: res => {\r\n                  // 获取到用户的 code 之后：res.code\r\n                  console.log(\"用户的code:\" + res.code);\r\n                }\r\n              });\r\n              wx.switchTab({\r\n                url: '/pages/home/home',    //这里填入要跳转目的页面的url\r\n                success: (result) => {\r\n                  console.log(\"跳转到首页\");\r\n                },\r\n                fail: () => {}\r\n              });\r\n            }\r\n          });\r\n        } else {\r\n          // 用户没有授权，显示授权页面,这里不进行操作\r\n        }\r\n      }\r\n    });\r\n  },\r\n\r\n  bindGetUserInfo: function (e) {\r\n    if (e.detail.userInfo) {\r\n      //用户按了允许授权按钮\r\n      var that = this;\r\n      // 获取到用户的信息了，打印到控制台上看下\r\n      console.log(\"用户的信息如下：\");\r\n      console.log(e.detail.userInfo);\r\n      //授权成功后,跳转页面\r\n      wx.switchTab({\r\n        url: '/pages/home/home',    //这里填入要跳转目的页面的url\r\n        success: (result) => {\r\n          console.log(\"跳转到首页\");\r\n        },\r\n        fail: () => {}\r\n      });\r\n    } else {\r\n      //用户按了拒绝按钮\r\n      wx.showModal({\r\n        title: '警告',\r\n        content: '您拒绝了授权，将无法进入小程序，请授权之后再进入!',\r\n        showCancel: false,\r\n        confirmText: '返回',\r\n        success: function (res) {\r\n          // 用户没有授权成功，不需要改变 isHide 的值\r\n          if (res.confirm) {\r\n            console.log('用户点击了“返回”');\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n})\r\n复制代码最后在app.json文件中将login设置为第一个页面即可。\r\n//app.json\r\n{\r\n\t\"pages\": [\r\n\t\t\"pages/login/login\",\r\n\t\t\"pages/home/home\"\r\n\t]\r\n}"}
{"title": "微信小程序仿Material Design风格的下拉刷新组件", "author": "Rolan", "time": "2020-4-14 00:29", "content": "在微信小程序开发中实现下拉刷新最简单的方式就是在页面对应的json文件中添加enablePullDownRefresh:true，然后在Page.onPullDownRefresh 方法中执行刷新逻辑。这种方式有一些局限性，一是无法自定义下拉刷新效果，只能使用默认的“三个圆点”样式；二是下拉刷新的视图位置是固定在顶部的，如果要刷新的视图元素不是位于页面顶部，那么使用这种方式就不太好了，最常见的场景就是顶部Tab标签栏，下面是要刷新的列表。在小程序基础库版本2.10.1之后，scroll-view支持自定义下拉刷新了，很好地解决了上述的两个问题，缺点当然就是兼容性了。于是想着自己实现一个下拉刷新组件，由于我本身是做Android开发的，所以尝试实现了一个仿Material Design风格的下拉刷新效果（Android中的SwipeRefeshLayout），先附上一张效果图：虽然没能做到百分之百的还原，不过基本功能还是实现了的。相关代码我已经上传到了github。使用方式将组件拷贝到项目中，在页面的json文件中引入，这里就不展示了。组件可设置的属性如下：此外，组件还定义了一个setRefresh()函数，用于设置刷新状态，参数传入一个布尔值，true表示开始刷新，显示下拉刷新圆圈；false表示结束刷新，隐藏下拉刷新圆圈。示例代码如下：index.wxml<swipe-refresh-layout id='refresh' style='width:100vw;height:200rpx;' loadMoreEnable bindrefresh='refresh' bindloadmore='loadMore'>  <!-- 要刷新的内容 --></swipe-refresh-layout>index.jsPage({  /**   * 页面的初始数据   */  data: {},  /**   * 生命周期函数--监听页面加载   */  onLoad: function(options) {    this.swipeRefresh = this.selectComponent('#refresh');  },  /**   * 下拉刷新   */  refresh: function() {    // 模拟获取数据    setTimeout(() => {      // 结束下拉刷新      this.swipeRefresh.setRefresh(false);    }, 3000);  },  /**   * 上拉加载   */  loadMore: function() {    // ...  }})需要注意，使用时必须给swipe-refresh-layout组件一个固定的宽度和高度。实现原理实现原理还是比较简单的，大体上就是通过监听触摸事件，在touchstart事件回调中记录手指按下的坐标；在touchmove事件回调中计算手指在竖直方向上的滑动距离，通过css的transform属性实现下拉刷新圆圈的移动；在touchend事件回调中计算手指抬起时的滑动距离，如果向下的滑动距离超过阈值就触发下拉刷新事件，否则将下拉刷新圆圈归位。由于在滑动的过程中需要频繁地进行用户交互，出于性能方面的考虑，我使用了WXS函数用来响应触摸事件，将事件定义在视图层，解决视图层和逻辑层间通信耗时的问题。虽然整体的实现逻辑不难理解，但是在开发过程中我还是遇到了几个问题，这里简单介绍一下。touchmove导致的卡顿问题一开始我使用的是bindtouchmove属性监听手指滑动事件，在开发工具上测试时没有什么问题，后来运行在安卓真机上才发现手指触摸屏幕下拉时刷新圆圈的移动比较卡顿，不流畅。在微信开放社区查了一下这个问题，发现也有人遇到过，目前的解决方案就是将bindtouchmove改为catchtouchmove。具体原因还不清楚，可能是官方的bug吧，又或者小程序本身就是这样设计的。改为catchtouchmove后确实是解决了下拉卡顿的问题，但是同时会导致页面内容无法滑动，如何解决这个问题呢，我们不妨考虑一下具体的使用场景，正常情况下只有在页面内容处于顶部时才可以下拉刷新，可以利用这个条件来判断是否需要我们自己处理touchmove事件。具体的做法是这样的，首先在组件最外层使用scroll-view，通过bindscroll监听滑动事件：_scroll: function(e) {  if (e.detail.scrollTop <= 50) {    // 滚动到顶部    this.setData({      scrollTop: true    });  } else {    this.setData({      scrollTop: false    });  }}使用一个变量scrollTop来记录是否滑动到了顶部，这里的判断条件为什么是e.detail.scrollTop <= 50而不是e.detail.scrollTop <= 0呢，因为通过测试我发现有时页面滑动到顶部时e.detail.scrollTop的值并不是0，而是一个接近0的整数，为了保证每次页面滑动到顶部都能改变scrollTop的状态，这里就给了一个默认值，取50是因为官方文档上给出的默认阈值就是50。之后在catchtouchmove回调函数中根据scrollTop的值判断是否需要处理滑动事件，如果scrollTop的值为false（页面内容不处位于顶部）就直接return。touchmove: function(e) {  if (!this.data.scrollTop) {    return;  }  // 处理滑动事件  }这样就解决了页面内容始终无法滚动的问题，当然上面的代码只是简单地说明解决方法，详细内容可以参考组件的源码。下拉刷新圆圈的显示层级问题正常情况下下拉刷新圆圈是位于要刷新的内容之上的，并且不会随着内容的滑动而移动，我们很容易就想到使用position:fixed属性，通过z-index属性来设置元素的层叠顺序。但是如果下拉刷新圆圈的z-index指定一个大于0的数，而刷新组件又不是位于页面的顶部，就会导致下拉刷新圆圈始终会显示出来，如下图所示：我这里采取的解决方案就是将下拉刷新圆圈的z-index指定为-1，而刷新内容的z-index指定为-2（取值不是固定的，只要比下拉刷新圆圈的小就可以），这样就可以解决下拉刷新圆圈覆盖在页面普通视图之上的问题。当然我的解决方案可能不是最好的，或者存在一些问题，如果大家有自己的想法欢迎提出，一起交流。总结目前我对于微信小程序的研究还比较浅显，对于CSS属性的运用也不是很熟练，可能组件本身还存在一些问题，或者大家还有更好的实现方案，欢迎提出。最后附上Demo地址，大家可以进行参考。参考文章极致的scroll-view的下拉刷新扩展组件"}
{"title": "小程序input的一些坑点", "author": "Rolan", "time": "2020-4-15 00:31", "content": "最近在开发中遇到的一些坑点\r\n\r\n表单组件(input)如何阻止冒泡\r\n在容器(fixed)中的input如何弹出键盘\r\n\r\n阻止input冒泡\r\n<view bind:tap=\"onTap\" class=\"container\">\r\n    <input bindinput=\"onBindInput\" type=\"text\"/>\r\n</view>\r\n复制代码上例中input操作会冒泡到container，导致onTap响应执行\r\n修正\r\n<view bind:tap=\"onTap\" class=\"container\">\r\n    <input bindinput=\"onBindInput\" type=\"text\" catch:tap=\"empty\"/>\r\n</view>\r\n复制代码冒泡的问题是由input的tap事件导致，因此定义一个empty的空方法，使它响应input的catch:tap，来达到阻止input的冒泡的作用\r\n在容器(fixed)中的input如何弹出键盘\r\n<view class=\"container\" style=\"position: fixed; bottom: 0\">\r\n    <input bindinput=\"onBindInput\" type=\"text\"/>\r\n</view>\r\n复制代码container组件在屏幕底部出现，点击Input组件时，弹出的键盘会遮盖input输入框\r\n修正\r\n<view class=\"container\" style=\"position: fixed; bottom: 0; {{mystyle}}\">\r\n    <input bindinput=\"onBindInput\" bindkeyboardheightchange=\"onkeybord\" type=\"text\"/>\r\n</view>\r\n复制代码Page({\r\n    data: {\r\n        mystyle: '',\r\n    },\r\n    \r\n    onkeybord(e){\r\n        let detail = e.detail\r\n        let kbHeight = detail.height\r\n        let tool = Pager.getElementsById('reminder-tool')\r\n        if (kbHeight === 0) {\r\n          this.setData({\r\n              mystyle: ' '\r\n          })\r\n        }\r\n\r\n        if (kbHeight && kbHeight > 0) {\r\n            this.setData({\r\n                mystyle: `bottom: ${kbHeight-40}px;`\r\n            })\r\n        }\r\n    }\r\n})\r\n复制代码demo"}
{"title": "尝试开发微信公众号消息推送功能并且和小程序关联", "author": "Rolan", "time": "2020-4-16 00:02", "content": "原文转载自「刘悦的技术博客」v3u.cn/a_id_121\r\n之前写了几篇关于微信小程序的开发实践，总的来说没啥难度，感兴趣的请移步：使用Mpvue配合Weui开发面试题题库微信小程序，并且发布到正式环境,这一次我们来尝试开发一下微信公众号，那么公众号和小程序到底有什么区别呢？\r\n首先定位不同\r\n公众号服务于营销与信息传递，小程序面向产品与服务。公众号主要用于信息的传递实现人与信息的连接，借助H5 能够实现简单的交互，主要以营销和信息传递为主简单的服务为辅，而小程序从功能上与公众号有严格区分（不支持关注、消息推送等营销手段），一方面使得产品与服务不至于淹没在公众号营销信息中，另一方支持公众号、朋友圈、群与小程序之间的互动与导流，使得开发者专心做产品与服务，从而为微信带来大量长尾服务叠加微信自身重度服务打造从社交到信息连接再到服务的生态圈。\r\n再者实现技术有区别\r\n公众号基于H5，小程序基于微信自身开发环境与开发语言。小程序是微信内的云端应用（所以无需安装），不是原生App，通过WebSocket 双向通信（保证无需刷新即时通信）、本地缓存（图片与UI 本地缓存降低与服务器交互延时）以及微信底层技术优化实现了接近原生APP 的体验。\r\n首先，我们还是去mp.weixin.qq.com/来注册一个公众号，注册时可以选择订阅号和服务号，这两者都是公众号，可以理解为服务号的功能更强大，但是需要企业级的资质才可以。\r\n 注册成功后，我们可以在公众号设置中设置一些公众号的基本信息\r\n只要用户关注了公众号，就可以看到一些关于公众号的信息了，这里我们来实现一个小功能，就是给关注公众号的粉丝来推送消息。\r\n这个功能在微信官方被称为模板消息推送，官方文档：developers.weixin.qq.com/doc/offiacc…\r\n我们从这里使用沙盒环境来全程模拟线上测试，首先进入微信的官方沙盒环境测试地址：mp.weixin.qq.com/debug/cgi-b…\r\n在这里我们获取到了测试的appid和sceret\r\n 按照说明文档，我们首先要获取token，通过微信官方的接口调试工具就可以在线获取到token，非常方便：mp.weixin.qq.com/debug/cgi-b…\r\n 填入刚刚的appid和appsecret，点击检查问题，就可以获取到你的token，需要注意的是，此token是有时间限制的，超过两小时需要再次请求接口获取\r\n将token保存好，此时再回到沙盒环境网址，关注测试公众号\r\n然后创建一个新增一个测试模板\r\n此时，我们手里已经掌握了模板id，用户的微信号id，这样就可以给关注的用户推送消息啦，聪明如你一定注意到了消息内容有一个{{ first.DATA}} ，这个其实就是一个类似通配符的东西，它可以将消息作为变量发送，这样你就能随时更改消息内容了。\r\n现在我们来利用postman，给关注的用户实时推送一条消息\r\n推送消息的接口地址为：api.weixin.qq.com/cgi-bin/mes…\r\n你需要将token替换为之前通过接口获取的token\r\n根据接口文档，需要传入的参数有token，用户id，模板id，以及跳转网址和data，需要注意一点，发送的参数格式为json，别忘了请求方式为post\r\n请求成功后，我们在公众号里就能看到这条消息\r\n\r\n总体来说模板消息在公众号的生态里是非常优秀的一种消息推送形式：用户查看便捷，信息传递直接：不用像图文消息那样跳到网页查看；和高级群发一样，用户关注即能收到，没有其他发送前提；日调用上限是10万次，且能根据粉丝的量级得到进一步提升；粉丝点击后直达小程序/链接，引流效果好。\r\n整个过程非常简单，当然了，这只是测试的沙盒环境，如果想应用到正式，必须有自己的独立服务器和域名才能使用\r\n模板消息除了单发之外，当然也可以通过多次调用接口的形式实现群发效果，让公众号发给需要接收消息的部分粉丝。\r\n最后，我们可以关联微信小程序，这样用户点击消息后就可以直接跳转小程序的页面了\r\n附上公众号二维码：\r\n\r\n原文转载自「刘悦的技术博客」 v3u.cn/a_id_121"}
{"title": "抽签小程序", "author": "Rolan", "time": "2020-4-16 00:14", "content": "背景今天谁炒菜，谁洗碗，谁买菜...啊，Boss说用抽签吧，于是有了下图这样存在作弊的问题（记住棍子特征，谁先，谁后抽等等）于是有了这个抽签小程序（当然小程序我一个人控制，我想不想作弊看心情了）简介扫码体验数据服务，存储本项目使用的是微信云开发，云数据库声明个抽签chouqianList集合即可（云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代）运行前准备(1) 注册微信小程序 ，获取 appid,替换本项目project.config.json里的appid(2) 开通小程序的云开发具体实现首页首页从上至下有抽签主题，抽签选项，发起抽签，常用抽签，此页面主要功能发起抽签，把抽签内容存到数据库里面。微信审核提示解决这个问题添加的内容调用这个方法（小程序内容安全api，云开发可调用）isCheckMsg: function (msg) {\r\n        return new Promise(function (n, s) {\r\n            wx.cloud.callFunction({\r\n                name: 'msg',\r\n                data: ({\r\n                    text: msg\r\n                })\r\n            }).then(res => {\r\n                if (res.result.errCode === 87014) {\r\n                    // 没通过\r\n                    n(false) \r\n                } else {\r\n                    // (\"通过\")\r\n                    n(true)\r\n                }\r\n            });\r\n        });\r\n    },随机抽签// 递归随机返回抽签项\r\n    edchouqian() {\r\n        let that = this;\r\n        return new Promise(function (n, s) {\r\n            const db = wx.cloud.database()\r\n            // 查询当前用户所有的 chouqianList\r\n            db.collection('chouqianList').where({\r\n                _id: that.data.drawlotsId\r\n            }).get({\r\n                success: res => {\r\n                    that.setData({\r\n                        detail: res.data[0].detail,\r\n                    });\r\n                    let nullDetail = res.data[0].detail.filter(item => item.openid == \"\");//找出没有抽签的选项\r\n                    let arrIndex = Math.floor((Math.random() * nullDetail.length));//从没有抽签的选项随机选择一个选项\r\n                    let objindex = nullDetail[arrIndex].index;\r\n                    n(objindex)\r\n                },\r\n                fail: err => {\r\n                    wx.showToast({\r\n                        icon: 'none',\r\n                        title: '查询记录失败'\r\n                    })\r\n                    console.error('[数据库] [查询记录] 失败：', err);\r\n                    s(err);\r\n                }\r\n            })\r\n        });\r\n    },抽签页抽签页有抽签功能，显示抽签结果，此页面主要功能，从数据库查询是否已经抽签，已抽签显示抽签结果，未抽签随机分配抽签（或者显示抽签次数已用完）。重复抽签问题用函数防抖或者节流抽签结果页抽签结果页，显示所有抽签人员和结果（结果从数据库根据抽签表的id查询）至此完毕 源码地址结语：因为发的时间比较短，页面、功能还需要慢慢完善，发布了的功能也有一些待改进的地方，欢迎同样志同道合的码友们多多指教和交流。ヾ(????)?~前端学习大佬群493671066，美女多多。老司机快上车，来不及解释了。"}
{"title": "【微信小程序】分享朋友圈组件开发实践", "author": "Rolan", "time": "2020-4-16 00:41", "content": "背景在一个完整带用户交互的小程序项目开发中，总会遇到分享这个功能，转发给好友用通用的api方法，分享朋友圈总是有各种各样的招式，一般的交互方案是生成一个带二维码的图，二维码有时候也分带参数和默认的。分享一个前段时间开发的生成分享图的功能，我当时的业务二维码是带参数的，为了识别能定位到固定产品页(生成带参数二维码是用微信云调用提供的方法处理，点此看帖分享图用canvas画布开发，所以对wx封装的canvas相关api要有一定了解开发步骤新建一个share组件文件包，并开发业务逻辑和样式编写含小程序规范的几个文件js/wxml/wxss/json开发代码，在需要引用页面的对应配置文件中加入组件配置在引用的wxml中加入组件代码和传参，js文件写参数的交互效果图代码概览1.share / share.wxml 【参考效果图 步骤2/3备注：1.第一模块 步骤2的分享引导层，点击分享票圈，出来第二模块弹框2.第二模块 步骤3效果图，share-load.gif是一个加载中动画的gif；close.png是关闭图标<!--分享弹窗--><view class=\"share-wrap\" bindtap=\"toClose\">  <!-- 分享的引导层 分 转发票圈或好友 -->  <view class=\"share-mod\" catchtap=\"doNothing\">    <view class=\"share-hd\">      <text class=\"fl\">分享</text>      <image class=\"share-close\" catchtap=\"toClose\" src=\"../../images/icons/close.png\"></image>    </view>    <view class=\"share-guide\">      <view class=\"share-wx\">          <button class=\"share-btn\" open-type=\"share\"></button>          <image src=\"../../images/icons/wx_friend.png\"></image>          <text>分享给好友</text>      </view>      <view class=\"share-line\"></view>      <view class=\"share-wx\" catchtap=\"toShowShareImg\">        <image src=\"../../images/icons/wx_quan.png\"></image>        <text>生成分享海报</text>      </view>    </view>  </view>  <!-- 点击引导层的 转发票圈 触发的生成画布图弹层 -->  <view class=\"share-mod\" hidden=\"{{!showShareImg}}\" catchtap=\"doNothing\">    <view class=\"share-hd\">      <text class=\"fl\">保存到相册</text>      <image class=\"share-close\" catchtap=\"toCloseShareImg\" src=\"../../images/icons/close.png\"></image>    </view>    <view class=\"share-quan\">      <image wx:if=\"{{imgSrc!=''}}\" class=\"share-img\" src=\"{{imgSrc}}\"></image>      <view wx:else>        <image class=\"share-img-load\" src=\"../../images/icons/share-load.gif\"></image>        <text class=\"share-load-text\">{{loadText}}</text>      </view>      <view class=\"save-btn\" catchtap=\"saveImg\">保存图片</view>      <view class=\"save-tip\">保存图片到手机相册后，就可以分享至您的圈子啦</view>    </view>  </view></view>2.share/ share.json{  \"component\": true}3.share/ share.js/*  使用说明↓↓↓1.需要引用的页面json配置文件新增如下配置项\"usingComponents\": {  \"share-win\": \"/component/share/share\"}2.页面wxml文件使用如下 shareInfo格式说明见下文 该组件是否渲染根据该对象是否有具体数据<canvas canvas-id=\"shareCanvas\" style=\"position:fixed;top:0;left:999rpx;width:1000px;height:750px;\"></canvas><share-win share-info=\"{{shareInfo}}\" bindcloseshare=\"closeShareWin\"></share-win>3.页面对应js需要定义一个closeshare事件[由组件里的toClose触发] 内部主要是将shareInfo参数置空4.shareInfo格式*/Component({  properties: {    shareInfo: {      type: Object,      value: {},    }  },  data: {    imgSrc:'',    showShareImg:false,    hasDownload:false,    loadText:'分享图绘制准备中...'  },  ready:function(){  },  methods: {    //点击浮层区域关闭弹窗    toClose:function(){      this.toCloseShareImg();      this.triggerEvent(\"closeshare\")    },    toCloseShareImg:function(){      this.setData({        showShareImg:false      })      if(this.data.hasDownload){        this.triggerEvent(\"closeshare\")      }    },    toShowShareImg:function(){      this.setData({        showShareImg:true      })      this.renderShareImg();    },    doNothing:function(){      return false;    },    setLoadText:function(txt){      this.setData({        loadText:txt      })    },    //渲染分享图    renderShareImg:function(){      //1000x750      const _this = this;      const _obj = _this.data.shareInfo;      //默认题图      let promise1 = new Promise(function (resolve, reject) {        if(_obj.cover==undefined || _obj.cover==''){          _obj.cover = '../../images/share_default.jpg'          resolve({path:_obj.cover});        }else{          _obj.cover = \"https://\"+_obj.cover.split('\\/\\/')[1]          wx.getImageInfo({            src: _obj.cover,            success: function (res) {              resolve(res);            }, fail: function (error) {              console.log(error);              _obj.cover = '../../images/share_default.jpg'              resolve({path:_obj.cover});            }          })        }      });      //小程序码      let promise2 = new Promise(function (resolve, reject) {        wx.cloud.callFunction({          name: 'openapi',          data: {            action:'getWXACodeUnlimit',            page: 'pages/detail/detail',            width: 220,            scene: _obj.id+\"_\"+_obj.goodsId,          },          success: res => {            wx.getImageInfo({              src: res.result[0].tempFileURL,              success: function (suc) {                resolve(suc);              }, fail: function (error) {                resolve({path:\"../../images/qrcode.jpg\"})                console.log(error)              }            })              },          fail: error => {            console.log(JSON.stringify(error))            resolve({path:\"../../images/qrcode.jpg\"})          }        });      });      //加载所有完图片后绘制画布      Promise.all(        [promise1,promise2]      ).then(res => {        //绘制头图的圆角效果        const ctx = wx.createCanvasContext('shareCanvas')        ctx.setFillStyle('#ffffff');        ctx.fillRect(0, 0, 750, 1125);        //绘制题图        _this.setLoadText(\"绘制商品图...\")        ctx.drawImage(res[0].path, 25, 25, 700, 700)       // ...删除了部分 绘制逻辑代码...        //绘制小程序码        _this.setLoadText(\"绘制小程序码...\")        ctx.drawImage(res[1].path, 35, 874, 228, 228);        //画布绘制完成转图片，将地址赋值给图片        _this.setLoadText(\"分享图生成中...\")        ctx.draw();        setTimeout(function () {          wx.canvasToTempFilePath({            width: 750,            height: 1125,            destWidth: 750,            destHeight: 1125,            quality: 1,            canvasId: 'shareCanvas',            success: function (res) {              // console.log(\"canvasToTempFilePath success:\"+res.tempFilePath);              wx.hideLoading({})              _this.setData({                imgSrc: res.tempFilePath,                shareShow: true              })            },            fail: function (res) {            }          })        }, 200)      })    },    //保存图片    saveImg:function(){      //下载文件      const _this = this;      if(_this.data.imgSrc==''){        wx.showToast({          title:\"分享图还在生成中...\",          icon: 'none',          duration:3000        })        return false;      }      wx.saveImageToPhotosAlbum({        filePath: _this.data.imgSrc,        success(res) {          wx.showToast({            title:\"已保存至相册，可以分享啦\",            icon: 'none',            duration:3000          })          _this.setData({            hasDownload:true          })        }      })    },    //图片按比例居中裁剪    calClipImg(oW,oH,mW,mH){      var oR = parseFloat(oW/oH).toFixed(5);      var mR = parseFloat(mW/mH).toFixed(5);      if(oR == mR){        return [0,0,oW,oH]      }else if(oR > mR){        var ratio = parseFloat(mH/oH).toFixed(5);        return [((oW*ratio-mW)/2)/ratio,0,mW/ratio,mH/ratio];      }else{        var ratio = mW/oW;        return [0,((oH*ratio-mH)/2)/ratio,mW/ratio,mH/ratio];      }    },    //绘制圆角    roundRect(x, y, w, h, r,ctx){      var min_size = Math.min(w, h);      if (r > min_size / 2) r = min_size / 2;      // 开始绘制      ctx.beginPath();      ctx.moveTo(x + r, y);      ctx.arcTo(x + w, y, x + w, y + h, r);      ctx.arcTo(x + w, y + h, x, y + h, r);      ctx.arcTo(x, y + h, x, y, r);      ctx.arcTo(x, y, x + w, y, r);      ctx.closePath();    },    //绘制文本方法    drawText(str,ctx,initX,initY,lineHeight,minusW,maxLine){      var curLine = 1;      var lineWidth = 0;      var canvasWidth = 750;      var lastSubStrIndex= 0;      var d = 0;      for(var i=0;i<str.length;i++){        lineWidth += ctx.measureText(str[i]).width;        //判断当前文字行是否超过一行 [减minusW,防止边界溢出]        if((d==0 && lineWidth>canvasWidth-minusW)||(d>0 && ((lineWidth>=canvasWidth-minusW) || ((lineWidth+ctx.measureText(str[i+1]).width)>canvasWidth-minusW)))){          d++;          ctx.fillText(str.substring(lastSubStrIndex,i),initX,initY);          initY+=lineHeight;          lineWidth=0;          lastSubStrIndex=i;          curLine = curLine+1;          if(maxLine!=-1 && curLine>maxLine)break; //最多绘制六行        }        //最后一个字的时候 绘制一行        if(i==str.length-1){          ctx.fillText(str.substring(lastSubStrIndex,i+1),initX,initY);        }      }    }  }})4.share.wxss.share-wrap{  position:fixed;  top:0;  width:750rpx;  height:100%;  background:rgba(0,0,0,.4);  overflow: hidden;  z-index:1001;}.share-mod{  position:fixed;  bottom:0;  width:100%;  background:#fff;  z-index:1001;  overflow: hidden;}.share-mod .share-hd{  padding-left:20rpx;  height:80rpx;  line-height:80rpx;  background:#efefef;  color:#666;  font-size:32rpx;}.share-mod .share-close{  float:right;  margin:15rpx 20rpx;  height:50rpx;  width:50rpx;}.share-guide{  padding:35rpx;  width:680rpx;  height:180rpx;}.share-guide .share-wx,.share-guide .share-line{  float:left;}.share-guide .share-line{  margin-top:60rpx;  height:160rpx;  width:1rpx;  color:#cdcdcd;}.share-guide .share-wx{  width:339rpx;  height:180rpx;  text-align:center;  font-size:24rpx;}.share-guide .share-wx image{  display: block;  margin:20rpx auto;  padding:10rpx;  width:64rpx;  height:64rpx;  border-radius:43rpx;  border:1rpx solid #dedede;}.share-guide .share-btn{  position: absolute;  margin:0;  padding:0;  bottom:40rpx;  left:35rpx;  width:340rpx;  height:180rpx;  background:none;}.share-guide .share-btn:after{  border:none;}.share-quan{  margin:20rpx;  overflow: hidden;}.share-quan .share-img{  display:block;  margin:10rpx auto 28rpx;  height:600rpx;  width:400rpx;  border-radius:8rpx;  box-shadow:0 0 10rpx #cdcdcd;}.share-quan .share-img-load{  display:block;  margin:260rpx auto 20rpx;  height:80rpx;  width:80rpx;}.share-quan .share-load-text{  margin:0 auto 220rpx;  display:block;  widows:100%;  text-align:center;  font-size:28rpx;  color:#b7b7b7;}.share-quan .save-btn{  width:710rpx;  height:80rpx;  line-height:80rpx;  color:#fff;  text-align:center;  letter-spacing:4rpx;  background-color:#e2633f;  border-radius:6rpx;  font-size:34rpx;}.share-quan .save-tip{  margin:18rpx;  text-align:center;  font-size:24rpx;}↓组件开发已经完成，接下去是组件的使用↓1.demo.json备注：usingComponents加入对应组件配置即可{  \"navigationBarBackgroundColor\": \"#ffffff\",  \"navigationBarTextStyle\": \"black\",  \"navigationBarTitleText\": \"xxx\",  \"usingComponents\": {    \"share-win\": \"/component/share/share\"  }}2.demo.wxml备注：点击分享按钮的时候 showShareWin值改变，shareInfo根据渲染需求赋值<view>    <!-- S 其他业务代码 -->    <!-- E 其他业务代码 -->    <!-- 分享 -->    <canvas canvas-id=\"shareCanvas\" style=\"position:fixed;top:0;left:999rpx;width:750px;height:1125px;\"></canvas>    <share-win wx:if=\"{{showShareWin}}\" share-info=\"{{shareInfo}}\" bindcloseshare=\"closeShareWin\"></share-win></view>3.demo.js备注：删除了其他业务代码，仅剩和分享的交互，便于阅读。shareInfo数据在load时就塞进去了，下面没有放出来~Page({  data: {    showTop:false  },  //点击右侧悬浮的分享按钮  doShare:function(){    this.setData({      showShareWin:true    })  }, //触发关闭分享弹框  closeShareWin:function(){    this.setData({      showShareWin:false    })  },})其他说明:步骤4为最终生成效果图，微信识别二维码就可定位到具体业务页~有问题可留言交流~完..."}
{"title": "小程序瘦身之利用gulp压缩wxss", "author": "Rolan", "time": "2020-4-16 00:51", "content": "前言众所周知，微信小程序在发布的时候，对提交的代码是有大小的限制！项目内容太多的时候我们就需要想办法去做一些优化。首先先打开自己项目的文件夹，看看体积最大的是什么，然后在针对它去做一些措施，由于我现在的项目体积最大的基本都是wxss，所以现在主要谈谈如何利用glup来压缩wxss（使用的是微信原生，瞎捉摸的，仅适用于小白，有更好的办法欢迎评论里讨论）华丽的分隔线，前面的碎碎念可以略过，下面才是正文。正文安装gulp1、全局安装cnpm install gulp -g2、检查版本gulp -v在微信小程序中使用先把微信所有项目都塞到一个文件夹使用cmd打开根目录，npm init 创建package.json在更目录下安装gulp-clean-css，压缩CSS文件cnpm install gulp-clean-css -D目录下新建 gulpfile.js 文件，最后文件夹有这些东西gulpfile.js 文件内容var gulp = require('gulp'); // 载入Gulp模块var cleanCss = require('gulp-clean-css');  //加载clean模块  压缩css//定义一个压缩css代码的任务,定义一个cleanCss任务，自定义任务名gulp.task('cleanCss', (cb) => {    console.log('执行压缩!');    gulp.src('./src/pages/index/*.wxss')  //找到原始文件        .pipe(cleanCss())    //压缩css代码        .pipe(gulp.dest('./src/pages/index/min_after'));  //压缩后的代码储存在这里    cb();});执行命令结果"}
{"title": "uni-app转字节跳动、百度小程序手摸手实战", "author": "Rolan", "time": "2020-4-17 00:16", "content": "从最早发布的微信小程序，到后来的支付宝小程序、钉钉小程序，字节跳动小程序、百度小程序、QQ小程序等，面对这么多套的代码，开发者去编写多套原生代码的成本显然非常高，使用H5的话体验又没有原生好，这时候只需编写一套代码，就能够适配多端的能力就显得尤为需要。下面进入正题，给大家介绍下uni-app字节小程序的开发前置准备工作默认头条小程序的APPID已申请成功安装开发工具百度小程序开发者工具字节跳动开发者工具HBuilderX或者其他自己喜欢的IDE都可以项目开发新建项目可以通过 HBuilderX可视化界面 以及 vue-cli命令行 方式进行创建下面主要介绍下通过vue-cli命令行这中方式来新建项目全局安装vue-clinpm install -g @vue/cli\r\n复制代码创建vue create -p dcloudio/uni-preset-vue user-uni-order\r\n复制代码安装成功后提示选择模板，我们选择默认模板就可以了项目整体流程用户下单最短流首页下单-> 订单状态-> 完成支付, 如下：综上我们需要做的页面维度： 首页，地址检索，城市选择，登录，个人中心，订单列表，webview（收费标准 , 预估价格, 订单状态， 订单详情，法律条款）制定目录结构┌─components      //uni-app组件目录\r\n│    └─comp-a.vue     //可复用的a组件\r\n├─common   // 通用的js&css工具等\r\n├─hybrid    //存放本地网页的目录\r\n├─platforms     //存放各平台专用页面的目录\r\n├─pages       //业务页面文件存放的目录\r\n│    ├─index\r\n│    │   └─components   // 页级别组件\r\n│    │   └─vuex  // index页面vuex主要存放index的逻辑\r\n│    │   └─index.vue   // index页面\r\n├─static    //存放应用引用静态资源（如图片、视频等）\r\n│ ├─mp-weixin   //条件编译png\r\n│     │ └─a.png\r\n│     │ └─b.png\r\n├─store // 状态统一管理，将各个页面的vuex汇总\r\n├─service // 汇总请求，api等\r\n│    └─api.js // 接口api相关\r\n│    └─config.js // 环境配置\r\n│    └─index.js\r\n│    └─request.js // 网络请求\r\n├─ttcomponents // 头条小程序自定义组件存放目录 \r\n├─main.js      //Vue初始化入口文件\r\n├─App.vue      //应用配置，用来配置App全局样式以及监听 \r\n├─manifest.json //配置应用名称、appid、logo、版本等打包信息\r\n└─pages.json //配置页面路由、导航条、选项卡等页面类信息\r\n复制代码运行项目想运行到哪个平台小程序，首先需要把相应的APPID, IDE路径对应填写正确npm run dev:mp-toutiao // 实时监听编译\r\n复制代码运行成功如下提示：此时打开字节跳动IDE进行导入操作，就可以看见页面啦~~~Tips：使用字节跳动编译器打开uni-app编译的小程序时，必须进行导入操作，而不是新建，因为新建会默认成代码片段，虽然也可以实时预览效果但是会导致上传功能确实具体页面的开发首页开发页面效果首页目录结构项目中其他页面的目录结构与首页均相同，后面不做多余赘述。├─pages\r\n│    ├─index\r\n│    │   └─components\r\n│    │   └─vuex\r\n│    │   │  └─index.js // 首页逻辑\r\n│    │   └─index.vue\r\n复制代码我们使用vuex来管理状态，每个页面都有自己的vuex, 其中index.js存放对应页面相关逻辑，为了避免频繁切换目录，把state, mutations, actions放在一个文件下，使用时并启用vuex的模块化，如下const IndexPage = {\r\n    namespaced: true,  // 启用模块化vuex\r\n    state: {\r\n        ... // 需要共享的状态\r\n    },\r\n    mutations: {\r\n        ... // 一些方法\r\n    }，\r\n    actions: {\r\n        ... // 请求相关\r\n    }\r\n}\r\n\r\nexport default IndexPage  //最后导出IndexPage\r\n复制代码各个页面的vuex统一放在store里import Vue from 'vue'\r\nimport Vuex from 'vuex'\r\n\r\nimport IndexPage from '../pages/index/vuex'\r\nimport AddressSearch from '../pages/address/vuex/index'\r\nimport CityListPage from '../pages/city-list/vuex/index'\r\n\r\nVue.use(Vuex)\r\n\r\nconst store = new Vuex.Store({\r\n  state: {\r\n  ... // 全局共用的状态\r\n  },\r\n\r\n  mutations: {\r\n  },\r\n\r\n  actions: {\r\n  },\r\n\r\n  modules: {\r\n    IndexPage, // 首页vuex\r\n    AddressSearch, // 地址检索页vuex\r\n\tCityListPage, // 城市列表页vuex\r\n  },\r\n})\r\n\r\nexport default store\r\n复制代码最后，在main.js里面引用import Vue from 'vue'\r\nimport App from './App'\r\nimport store from './store'\r\n\r\nVue.config.productionTip = false\r\n\r\nApp.mpType = 'app'\r\n\r\nconst app = new Vue({\r\n  ...App,\r\n  store\r\n})\r\napp.$mount()\r\n复制代码完整的首页逻辑交互框架就搭建成功了，以下是开发首页时遇见的问题首页开发遇到的问题使用swiper轮播组件，写好子组件，父组件因为无效果问题原因：引入的 import swiper from \"../../components/swiper/swiper\" ,导致把自定义的swiper覆盖，所以不展示解决：引入的 import uniSwiper from \"../../components/swiper/swiper\" ,不和原组件命名冲突即可转百度小程序header报错问题原因：百度设置http请求header如果有中文字符解决：使用条件编译，如果是百度小程序需要encodeURI 一下， 或者删除header的中文部分uni-app的image标签，在小程序端不支持动态引入图片// 引不到\r\n <image class=\"tip_icon\" src=\"/static/sender{{endPoint.address ? '' : '_default'}}.png\"/>\r\n\r\n复制代码// 可以引入\r\n<image class=\"tip_icon\" src=\"/static/sender.png\"/>\r\n复制代码uni.getLocation() 只能获取经纬度，获取不到详细地址信息非 h5 平台 :key 不支持表达式由于:key=\" timer__${idx} \"的写法，编译时控制台会警告，但是不影响页面<view \r\n    class=\"column_item\" \r\n    v-for=\"(item, idx) in item\" \r\n    :key=\"`timer__${idx}`\" // 改成:key=\"idx\" 即可\r\n>\r\n{{item == \"立即用车\" ? \"\" : index == 1 ? \"时\" : index == 2 ? \"分\" : \"\"}}\r\n</view>\r\n复制代码父子组件传参，类型定义不对不提示错误信息，只展示null, 所以遇到null问题可以查看是否是类型定义不一致uni-app中的watch不支持监听小程序，如下watch: {\r\n    searchType (to) {\r\n      if (to) {\r\n      // 如果是起始地回填起始地信息否则回填目的地信息\r\n        if (to === SEARCH_TYPE.START) {\r\n          this.detailAddress = this.startAddress.detailAddress || ''\r\n        } else {\r\n          this.detailAddress = this.endAddress.detailAddress || ''\r\n        }\r\n      }\r\n    }\r\n}\r\n复制代码改成mounted () {\r\n\tif (this.searchType === SEARCH_TYPE.START) {\r\n\t\tthis.detailAddress = this.startAddress.detailAddress || ''\r\n\t} else {\r\n\t\tthis.detailAddress = this.endAddress.detailAddress || ''\r\n\t}\r\n}\r\n复制代码个人中心开发页面效果个人中心主要涉及的H5页面以及小程序的授权登录功能。所以主要部分就是webview的实现。webview的实现// template\r\n<web-view id='web-view' v-if='src' :src='src' @bindmessage='onmessage'></web-view>\r\n复制代码onLoad (options) {\r\n    console.log('H5入口页获取到的参数', options)\r\n    let { src, needLogin} = options\r\n    if(!needLogin){\r\n    \tthis.src = decodeURIComponent(src)\r\n    \treturn\r\n    }\r\n    // 需要登录的 就先获取临时token\r\n    this.fetchTempToken(src)\r\n}\r\n复制代码如果不需要登录的H5我们直接赋值到src即可，需要登录才能正常访问的页面，首先要获取临时token,拿到临时token后回传给服务端并且采用中间页redirectUrl的形式跳转。个人中心开发遇到的问题向网页传递信息要使用头条api的bindmessage官方说明“网页向小程序 postMessage 时，会在特定时机（小程序后退、组件销毁、分享）触发并收到消息”// 在小程序中调起H5中的打电话功能\r\nonmessage (e) {\r\n\tlet { phoneNumber, name } = e.detail\r\n\tif(name == 'makePhoneCall'){\r\n\t\tuni.makePhoneCall({\r\n\t\t\tnumber: phoneNumber\r\n\t\t})\r\n\t}\r\n}\r\n复制代码需要注意的web-view的bindmessage属性并不是实时的真机拨打电话功能不能用// 使用uni.makePhoneCall真机没反应\r\nuni.makePhoneCall({ phoneNumber: '114'});\r\n\r\n复制代码解决：改为头条api的tt开头// 真机模拟器均可正常使用\r\ntt.makePhoneCall({ phoneNumber: '114'});\r\n复制代码登录开发头条授权登录效果百度授权登录效果大致思路：1.首先获取获取服务供应商的信息2.调用 uni.getProvider 获取授权code3.获取用户的手机号（用户登录头条app的）4.从 @getphonenumber 回调中获取到用户信息5.调用授权登录服务api6.获取token, openid等信息// template\r\n<view class=\"login-page\">\r\n\t<view class=\"title\">\r\n\t\t<view class=\"h-line\"></view>\r\n\t\t<view class=\"page-title\">授权登录更快捷</view>\r\n\t\t<view class=\"h-line\"></view>\r\n\t</view>\r\n\t<view class=\"authLogin-wrapper\">\r\n\t\t<!-- #ifdef MP-BAIDU -->\r\n\t\t<button type=\"default\" open-type=\"getPhoneNumber\" @getphonenumber=\"authLoginTap\" class=\"login authLogin\">百度登录更快捷</button>\r\n\t\t<!-- #endif -->\r\n\t\t<!-- #ifdef MP-TOUTIAO -->\r\n\t\t<button \r\n\t\t\ttype=\"default\" \r\n\t\t\tclass=\"login authLogin\"\r\n\t\t\topen-type=\"getPhoneNumber\"\r\n\t\t\t@getphonenumber=\"onGetPhoneNumber\"\r\n\t\t>授权手机号快捷登录</button>\r\n\t\t<!-- #endif -->\r\n\t</view>\r\n</view>\r\n复制代码// 完成渲染调用授权code方法\r\nmounted () {\r\n\tthis.getCode()\r\n}\r\n复制代码// 获取授权code方法\r\nasync getCode () {\r\n\tconst [ errorProvider, provider ] = await uni.getProvider({ service: 'oauth' })\r\n\r\n\tif (errorProvider) {\r\n\t\tconsole.log('获取provider失败')\r\n\t\treturn \r\n\t}\r\n\r\n\tconst [ errLogin, data ] =\tawait uni.login({\r\n\t\tprovider: provider.provider[0],\r\n\t\tforce: true\r\n\t})\r\n\r\n\tif (errLogin) {\r\n\t\tconsole.log('获取code失败')\r\n        // 失败的操作，提示等\r\n\t\treturn\r\n\t}\r\n\r\n\tconst { code } = data\r\n\tthis.code = code\r\n},\r\n\r\n// 头条获取到用户信息  \r\nasync onGetPhoneNumber ({ detail }) {\r\n\tconst { errMsg } = detail\r\n\t// 授权失败\r\n\tif (errMsg.indexOf('auth deny') > -1) {\r\n        // 取消授权进行手机验证码登录\r\n\t\treturn\r\n\t} \r\n\t\r\n\ttry {\r\n        // 调用服务授权接口\r\n\t\tconst { data } = await authLogin({\r\n\t\t\tcode: this.code,\r\n\t\t\t...detail,\r\n\t\t})\r\n\t\t\r\n\t\tif (data.code === SUCCESS) {\r\n\t\t    // 存token, openid等操作\r\n\t\t    // 重新更新个人信息\r\n\t\t} else {\r\n\t        // 失败的提示等\r\n\t\t}\r\n\t} catch (error) {\r\n\t\t// 登录失败异常情况处理\r\n\t}\r\n\t\r\n},\r\n// 百度获取到用户信息同理头条。。。\r\n复制代码登录开发遇到的问题手机验证码开发时，引入 checkbox-group 报错,如下图：原因： components : { [CheckBox.name]: CheckBox } 引入组件方式不支持发布到测试环境以字节跳动为例子，打开字节跳动开发者工具，在工具栏找到上传，填写版本号，发布。版本号不和上一次冲突就可以。Tips: 前面有提过，新建代码片段是在开发者工具上是没有上传按钮的，要导入项目才可以。上传成功后，会提示进入小程序开发者平台，现在可以看到开发者的版本。上图二维码就可以只作为本次的体检版本来扫一扫了。发布到正式环境前置准备，在后台配置好相关线上域名切换到线上环境// 环境相关配置\r\nexport const ENV = {\r\n  // 开发环境\r\n  RD: 'rd',\r\n  // 测试环境\r\n  TEST: 'test',\r\n  // 沙箱环境\r\n  BOX: 'box',\r\n  // 线上环境\r\n  ONLINE: 'online'\r\n}\r\n\r\n// 环境切换\r\nexport function getCurrentEnv() {\r\n  return ENV.ONLINE // 正式环境切到online\r\n}\r\n复制代码在开发者工具中点击上传去小程序开发者平台提审发布发布成功后可在头条搜索栏中搜到，抖音的话目前只有安卓平台上线了小程序功能。结束语以上就是uni-app转字节跳动、百度小程序的部分开发，相信大家对uni-app实战小程序已经有了初步认识，也欢迎大家指正，互相交流，共同进步"}
{"title": "关于微信小程序生产环境体验版获取不到openId的问题(大坑)", "author": "Rolan", "time": "2020-4-17 00:30", "content": "原文转载自「刘悦的技术博客」 v3u.cn/a_id_119我们知道openid是微信用户验证的重要标识，支付功能严重依赖这个东西，之前我们做微信支付的时候是通过在微信客户端直接调用官方接口，通过传code参数来调用，下面这样getOpenId(){  //获取用户的openid\r\n          let _this=this;\r\n          wx.login({\r\n            success(res) {\r\n                  if (res.code) {\r\n                  // 发起网络请求\r\n                  wx.request({\r\n                    url: 'https://api.weixin.qq.com/sns/jscode2session',\r\n                    data: {\r\n                        appid:appId,  //开发者appid\r\n                        secret:secret, //开发者AppSecret(小程序密钥)\t\r\n                        grant_type:\"authorization_code\",  //默认authorization_code\r\n                        js_code: res.code    //wx.login登录获取的code值\r\n                    },\r\n                    success(res) {\r\n                      _this.userinfo.openid=res.data.openid;\r\n                      _this.userinfo.session_key=res.data.session_key;\t\t\t\t\t\t   \r\n                }\r\n                  })\r\n                } else {\r\n                  console.log('登录失败！' + res.errMsg)\r\n                }\r\n            \r\n            }\r\n          })\r\n        }\r\n复制代码这样做理论上也可以拿到openid，但是这里有一个神坑，就是在小程序开发者工具直接测试，使用真机调试，都没有任何问题，但是一旦上传代码，使用小程序的体验版测试的话，就拿不到openid，奇怪的是，如果在体验版开启调试模式，又可以拿到，这是一个非常脑残的问题，直接影响就是开发环境和生产环境在代码相同的情况下，体现的效果不一样，微信官方也没有任何合理解释，经过很长时间的查找资料，获取openid不能直接在微信客户端来获取，应该改用后端来获取openid然后再返回给前端。所以应该用Django来获取openiddef getopenid(request):\r\n    res = {}\r\n    appId = request.GET.get('appId')#开发者appid\r\n    secret = request.GET.get('secret')#开发者AppSecret(小程序密钥)  \r\n    grant_type = \"authorization_code\"  #默认authorization_code\r\n    js_code = request.GET.get('js_code')#wx.login登录获取的code值\r\n\r\n    data = {'appId':appId,'secret':secret,\"grant_type\":grant_type,\"js_code\":js_code}\r\n    url = \"https://api.weixin.qq.com/sns/jscode2session\"\r\n    jscode = requests.get(url,data)\r\n    res = jscode.json()\r\n    return JsonResponse(res,safe=False,json_dumps_params={'ensure_ascii':False})\r\n复制代码而前端获取openid的方法改造成请求本地接口getOpenId(){  //获取用户的openid\r\n          let _this=this;\r\n          wx.login({\r\n            success(res) {\r\n                  if (res.code) {\r\n                  // 发起网络请求,改造成请求本地接口获取openid，规避体验版获取不到的问题\r\n                  wx.request({\r\n                    url: 'http://localhost:8000/getopenid',\r\n                    data: {\r\n                        appid:appId,  //开发者appid\r\n                        secret:secret, //开发者AppSecret(小程序密钥)  \r\n                        grant_type:\"authorization_code\",  //默认authorization_code\r\n                        js_code: res.code    //wx.login登录获取的code值\r\n                    },\r\n                    success(res) {\r\n                      _this.userinfo.openid=res.data.openid;\r\n                      _this.userinfo.session_key=res.data.session_key;               \r\n                }\r\n                  })\r\n                } else {\r\n                  console.log('登录失败！' + res.errMsg)\r\n                }\r\n            \r\n            }\r\n          })\r\n        }\r\n复制代码至此才解决了这个问题，这件事情说明一个问题，就是做任何事情都不能想当然，同时开发小程序的时候，真机测试没有问题并不代表没有问题，一定要到生产环境测一下，另外最后一个忠告，微信小程序获取openid一定要在server端获取再返回给前端，千万不要图省事在前端直接获取openid原文转载自「刘悦的技术博客」 v3u.cn/a_id_119"}
{"title": "开发一个时间小程序", "author": "Rolan", "time": "2020-4-17 00:49", "content": "前言跟异国他乡的朋友们微信聊天的时候，经常面临时差的问题。我每次想要确定对方现在是几点，总是要口算一下，有时忘记具体时差，或者涉及跨天，还得打开浏览器查一下，很不方便。有什么方法可以把朋友们所在城市的时间集中起来随时供自己查看呢？于是想到了微信小程序。找了找市面上的时间小程序，不是功能太杂就是小广告太多，不满意。为什么不自己动手量身打造一个呢？行动起来。首先快速明确需求很简单：需要展示时间的城市初定：加州、纽约，再加北京做对比需要显示具体的时分秒，和年月日需要实时变化在其他国家也能正确展示时间然后创建项目开撸怎么创建和前期的准备就不在这里展开了，相信不少人都熟悉。如果不熟悉小程序开发的可以参考官网 或者我的另一篇文章如何开发微信小程序 ，上面有对如何开发小程序的简明扼要的的介绍。关键逻辑这个小程序的核心是时间的处理。如何得到其他地区的时刻信息？这还不简单？先获取本地时刻，然后加上或者减去另外一个地点与国内（北京时间）的时差（小时），最多再处理一下跨天的情况，不就得到其他地点的时刻了？我一开始也是这么想的，做完觉得还挺美，准备提交的时候，突然意识到问题：我时差全是基于北京时间计算的，换在其他国家访问，获取的本地时间已经不是北京时间了，时差应该变才对，写死了时差可还行？！发布一个只能在国内使用的鸡肋时间工具，可不是我的风格！捣鼓一阵，新方案出炉：想办法获得零时区的时间获取不同地区与零时区的时差（时区）用零时区的时间加减与零时区的时差（时区），得到各地的绝对时间1. 获得零时区的时间零时区，也叫中时区，位于英国格林威治本初子午线上。该时区的地方时，叫做格林威治时间，也叫世界时。我们不能直接获得格林威治时间，但是我们可以获得本地与格林威治的时间差：const diff = new Date().getTimezoneOffset() // 单位为分钟然后根据本地时间和时间差获得格林威治时间：const absTime = new Date().getTime() + diff * 60 * 1000;2. 查询各地时区格林威治本初子午线将地球划分为东西两个半球，格林威治本初子午线为零时区，往西依次为西一区到西十一区，往东依次为东一区到东十一区，西十二区和东十二区重合成为东西十二区，一共划分了24个时区，每个时区相差正好是1个小时。北京是东八区，纽约是西五区，加州是西八区。完整时区地图：3. 计算各地的绝对时间东时区的时刻比零时区快，西时区的时刻比零时区慢，所以东时区为正，西时区为负，所有时间计算记得转换为毫秒。let localTime = new Date(absTime + timeZone * 60 * 60 * 1000);获取任何时区的绝对时间的完整核心代码：/**\r\n * timeZone: 东n区为正，西n区为负, 单位为小时\r\n */\r\nconst getFullTimeInfo = (timeZone, country, spliter) => {\r\n\r\n  //获取本地时间与格林威治时间的时间差(注意是分钟，记得转换)\r\n  const diff = new Date().getTimezoneOffset();\r\n\r\n  //根据本地时间和时间差获得格林威治时间\r\n  const absTime = new Date().getTime() + diff * 60 * 1000;\r\n\r\n  //根据格林威治时间和各地时区，得到各地时区的时间\r\n  let localTime = new Date(absTime + timeZone * 60 * 60 * 1000)\r\n\r\n  return {\r\n    time: formatTime(localTime, spliter)\r\n  };\r\n}发布很快，第一版就完成了。刚开始这个样子略丑，有点裸奔的赶脚。不过第一版最主要是核心功能，简陋的界面只是暂时的。给当地的朋友检验确定时间展示正确后，提交代码、提交审核，2天后收到审核通过的通知（吐槽腾讯的审核效率"}
{"title": "如何开通小程序直播？", "author": "Rolan", "time": "2020-4-20 00:29", "content": "目前小程序支持的直播方式有两种，一种是纯原生方案（小程序提供推流拉流服务器，主播端和收播端页面都已提供好，你直接使用即可），一种是自己搭建推流服务器（只是使用小程序端提供的live-pusher和live-player组件而已，里面的直播页面和功能都自己独立开发！），这里说的是第一种方案：一、准备工作1、一个已经申请开通和正常使用的实实在在的小程序PS：如果开通了直播功能，但是没有审核上架成功过，直播间分享出去的二维码点击会提示页面不存在！！！原因很简单，因为你新开发的直播页面正式版的小程序上并没有新加进去，必须要提审上架到正式版才能生效！二、小程序直播准入门槛满以下条件的电商平台、自营商家，即可开通小程序直播：（同时满足以下1、2、3条件，加上4、5、6条件的其中之一即可。）①满足小程序18个开放类目（包括：电商平台、商家自营-百货、食品、初级食用农产品、酒/盐、图书报刊/音像/影视/游戏/动漫、汽车/其他交通工具的配件、服装/鞋/箱包、玩具/母婴用品(不含食品)、家电/数码/手机、美妆/洗护、珠宝/饰品/眼镜/钟表、运动/户外/乐器、鲜花/园艺/工艺品、家居/家饰/家纺、汽车内饰/外饰、办公/文具、机械/电子器件）②主体下小程序近半年没有严重违规；③小程序近90天内，有过支付行为；④ 主体下公众号累计粉丝数大于100人；⑤ 主体下小程序连续7日日活跃用户数大于100人；⑥ 主体在微信生态内近一年广告投放实际消耗金额大于1万元；三、进入小程序后台直播，创建直播间如果你的小程序满足了第二点。小程序后台会有一个直播的入口（没有的话自己找找原因）点击进入后->创建直播间按提示操作（要输入主播人的微信号，对方初次使用要活体检测+实名认证）即可成功创建直播间。（注意点：开播时间最早不能早于当前时间10分钟后）创建成功后，会有一个开播码。注意这个开播码是给主播用的，主播开播的入口小程序码。主播可以扫码进入直播间开播。四、小程序端开发完成上面3步算是完成主播端的配置了，接下来是收播端（观看直播的小程序端）的开发了。这个是要小程序开发者完成的。所以下面操作都在小程序开发端完成。下面就简单介绍开发逻辑和顺序，具体的要用到的API和接口都不细说，在后面相关链接里面可以点击官方链接查看！（小程序直播 | 微信开放文档）https://developers.weixin.qq.com/miniprogram/dev/framework/liveplayer/live-player-plugin.html）（1）引入直播插件（直接按官方介绍文档操作）正常引入后开发者工具会弹出这个窗口，如果不弹出请认真，静下心来按照官方文档检查自己的引入代码：（2）开发后端（如果你没有小程序端自建直播列表和直播间入口的需求2、3、4都可以跳过，届时你的小程序直播间可以用分享方式进入）后端目前官方只提供了2个接口。一个是获取直播间列表，一个是获取直播间直播完后的相关回放信息，其中第一个接口必须先完成。就是获取到直播间列表，列表里面有带返回直播间的roomid，小程序端必须需要接收到这方面的返回才能接下来的开发。（3）进入直播页面引入直播插件后并对接第二步的后端接口后，你可以直接编码进入直播页面了。像进入普通页面一样，可以通过wxml里面的navigator url=\"xxxx\"的方式和js里的wx.navigateTo跳转页面代码进入直播页面。但是他这个url比较特殊，是下面这样的格式：  url: `plugin-private://${provider}/pages/live-player-plugin?room_id=${roomId}&custom_params=${encodeURIComponent(JSON.stringify(customParams))}`\r\n  provider:插件appid（1）小步里面获取到的\r\n  rommId:直播间id（2）小步里面获取列表后里面的roomId\r\n  customParams:自定义的进入页面参数。（根据需要自己定义的传入直播间收播页面的参数）\r\n进入直播间收播页面后的开发量为0，因为这个是由直播间插件接管并完成相关功能。（4）几个注意点：4.1、后端获取直播间列表接口几个跟官方文档介绍不一致的地方4.2、 livePlayer.getLiveStatus获取直播间状态这个API官方介绍：首次获取立马返回直播状态，往后间隔1分钟或更慢的频率去轮询获取直播状态。实际使用过程中建议也这么干，如果需要轮询直播间状态，建议间隔时间1分钟以上，如果少于这个值，基本上就是卡在这里后面的代码都不执行了。还有，有时候即使超过1分钟后再轮询，也会偶发性出现获取不到卡住的情况。解决方法，大家可以看看开发者工具里面的本地Storage相关的值，然后后面怎么做你懂的。。4.3订阅组件subscribe的样式问题。不多说，你懂的，你加上去就能看到效果4.4后端接口每日调用次数限制的问题。要做好相关缓存到本地的架构设计。4.5运营上一定要注意，按要求直播。别整那些没用的，很容易被禁播的。（5）回放功能开发1.0.4版本后支持0开发的回放功能了。参考后面新增的专门介绍回放功能的使用教程。五、跑路这里的跑路是指代码写累了，带上口罩和吉娃娃去公园跑一圈路回来继续码。最新：1.0.4版本后的回放功能说明，回放功能是这样的1、后台开启该直播间的回放功能2、收播端还是原来的直播入口进行回放，小程序端是plugin-private://${liveplayId}/pages/live-player-plugin?room_id=${roomId}&custom_params=${encodeURIComponent(JSON.stringify(customParams))}`\r\n这里的页面链接，链接到回放页面。获取分享方式，分享出去的直播页面，点击后进入回放。还有一个口，点击原来的分享链接后的直播完成页面，也有一个查看回放的入口，如上图。Tip:如果刚刚直播完可能需要稍等生成回放视频后再次进入相关页面才能看到回放。相关链接：小程序直播 | 微信开放文档（开发必看，而且要熟读，基本有所有你要的开发资料）https://developers.weixin.qq.com/miniprogram/dev/framework/liveplayer/live-player-plugin.html微信小程序直播功能准入要求 | 微信开放文档https://developers.weixin.qq.com/miniprogram/product/live/access-requirement.html“小程序直播”接入指引 | 微信开放社区https://developers.weixin.qq.com/community/develop/doc/0008ce654c4450244c1a7e5de5b801?highLine=%25E7%259B%25B4%25E6%2592%25AD%2520%25E6%25B1%25BD%25E8%25BD%25A6相关知识科普：小程序直播单日直播上限是50场，同时直播上限50场，单场的直播时长上限是12小时。"}
{"title": "小程序以及H5页面上IphoneX底部安全区域小黑条适配问题", "author": "Rolan", "time": "2020-4-20 00:31", "content": "背景公司项目开发中，发现iPhoneX上吸底元素存在被小黑条遮挡的问题原因在苹果 iPhoneX 、iPhone XR等机型上，物理Home键被取消，改为底部小黑条替代home键功能,从而导致吸底元素会被小黑条遮挡覆盖的问题解决方案使用已知底部小黑条高度为34px/68rpx机型适配(不建议)使用微信官方API，getSystemInfo()中的safeArea对象进行适配（建议）使用苹果官方推出的css函数env()、constant()来适配 （建议）安全区域看看图就明白了，中间绿色区域即为安全区域。也就是说，适配安全区域也就是让小程序或者H5的内容显示在绿色区域部分。第一种，使用已知安全距离进行适配34px/68rpx(不建议)小程序app.js文件中判断获取当前设备机型，如果是iphoneX系列机型，那么设计到底部时，则考虑设置底部按钮或选项卡的margin-bottom、padding-bottom、height等，或者添加一个div来占位小黑条的位置。第二种 getSystemInfo()1 使用wx.getSystemInfoSync()中的screenHeight和safeArea对象的bottom属性判断这里使用screenHeight是获取屏幕的高度，因为bottom是以屏幕左上角为原点开始计算的，所以需要的是屏幕高度，对比screenHeight和safeArea，如果相等则说明不需要适配，不相等则需要适配。`const isIPhoneX = () => {let screenHeight = wx.getSystemInfoSync().screenHeightlet bottom = wx.getSystemInfoSync().safeArea.bottomreturn screenHeight !== bottom}`注意 isIPhoneX 返回true则代表不想等，需要进行适配底部选项卡或吸底元素样式判断<view class=\" {{isIPhoneX ? 'marginB' : ''}}\">底部选项卡或吸底元素</view>2 safeArea对象获取底部小黑条的高度,全局存储使用第三种 使用苹果官方推出的css函数env()、constant()来适配 （建议）我也用的这种env()和constant()，是IOS11新增特性，Webkit的css函数，用于设定安全区域与边界的距离，有4个预定义变量：safe-area-inset-left：安全区域距离左边边界的距离safe-area-inset-right：安全区域距离右边边界的距离safe-area-inset-top：安全区域距离顶部边界的距离safe-area-inset-bottom ：安全距离底部边界的距离这里我们只需要关注safe-area-inset-bottom就行了而env()和constant()函数有个必要的使用前提，H5网页设置viewport-fit=cover的时候才生效，小程序里的viewport-fit默认是cover使用案列下图为一个吸底元素，在iphoneX真机上小黑条会遮挡，大概长这样解决方案`.detailBotoom{position: fixed;bottom: 0;width: 100%;display: flex;height: calc(96rpx+ constant(safe-area-inset-bottom));/// 兼容 IOS<11.2 /height: calc(96rpx + env(safe-area-inset-bottom));/// 兼容 IOS>11.2 /background: #fff;border-top: 1rpx solid #eaeef1;z-index: 99;padding-bottom: constant(safe-area-inset-bottom);/// 兼容 IOS<11.2 /padding-bottom: env(safe-area-inset-bottom);/// 兼容 IOS>11.2 /}`注意 constant与env顺序不能改变，先constant再env"}
{"title": "【微信小程序】日历形式的日期选择器", "author": "Rolan", "time": "2020-4-20 00:49", "content": "最近项目中用到了一个日期选择器，原生的不是很好看，所以自己写了一个日历形式的，现在分享给大家。直接上代码： https://gitee.com/piscdong/we...效果图如下月份切换直接用了原生的月份选择器。代码还是相对比较简单的，这里简单分析一下日历部分的代码。日历部分主要是使用js的Date对象来获取指定月份相关信息。首先获取到当月首日的星期，如果不是周日，则在前面补充上相应数量的空view。if (week > 0) {\r\n  for (var i = 0; i < week; i++) {\r\n    days.push({\r\n      day: 0\r\n    })\r\n  }\r\n}每个月的最大天数，和PHP不同，js好像并没有直接获取到的方法，我用了个笨办法，直接根据月份来判断当前月是否大月，2月的时候则是这一年是否闰年。if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n  max = 30\r\n} else if (month == 2) {\r\n  if (((year % 4) == 0 && (year % 100) > 0) || (year % 400) == 0) {\r\n    max = 29\r\n  } else {\r\n    max = 28\r\n  }\r\n}整体使用flex布局，父级的宽度正好是每个子级宽度的7倍，这样就可以每7天换一行。其他基本上都是一些基础的js、css代码，没什么花头。"}
{"title": "教你如何用华为HMS MLKit 图像分割 SDK开发一个证件照DIY小程序", "author": "Rolan", "time": "2020-4-7 00:21", "content": "引子上期给大家介绍了如何使用如何用华为HMS MLKit SDK 三十分钟在安卓上开发一个微笑抓拍神器详情请戳，本次给大家分享一篇新的实战经验。不知道大家是否有这样的经历，忽然学校或者公司需要提供让提供个人的一寸或者两寸头像照片，要办理出入证、学生证什么的，并且对照片的底色有要求，有很多人当前没有拍好的证件照需要到照相馆重拍，又或者之前已经拍过了，但是照片底色不满足要求，小编就有过类似的经历，当时学校让办个出入证，学校照相馆又关门了，匆匆忙忙用手机拍了下，然后用床单作为背景应付，结果被老师大骂了一顿。多年以后华为的HMS MLKit机器学习有了图像分割的功能，使用这个SDK开发一个证件照DIY的小程序，可以完美解决小编当年遇到的尴尬。废话不多说，为了能够制造强烈的视觉冲击，小编也是拼了，翻出来当年大学时代的囧照，给大家展示下华为 HMS MLKit的强大功能：怎么样，效果是不是还可以，只需要写个小程序就可以快速实现！核心提示：此SDK免费，安卓全机型覆盖！证件照DIY开发实战1 开发准备1.1 在项目级gradle里添加华为maven仓打开AndroidStudio项目级build.gradle文件。增量添加如下maven地址：buildscript {\r\n    repositories {        \r\n        maven {url 'http://developer.huawei.com/repo/'}\r\n    }    }allprojects {\r\n    repositories {       \r\n        maven { url 'http://developer.huawei.com/repo/'}\r\n    }}1.2 在应用级的build.gradle里面加上SDK依赖把人脸识别的SDK和基础SDK引入dependencies{ \r\n  // 引入基础SDK \r\n  implementation 'com.huawei.hms:ml-computer-vision:1.0.2.300' \r\n  // 引入人脸检测能力包 \r\n  implementation 'com.huawei.hms:ml-computer-vision-image-segmentation-body-model:1.0.2.301'   \r\n  }1.3 在AndroidManifest.xml文件里面增量添加模型自动下载要使应用程序能够在用户从华为应用市场安装您的应用程序后，自动将最新的机器学习模型更新到用户设备，请将以下语句添加到该应用程序的AndroidManifest.xml文件中：<manifest    \r\n   <application  \r\n       <meta-data                     \r\n           android:name=\"com.huawei.hms.ml.DEPENDENCY\"          \r\n           android:value= \"imgseg \"/>                    \r\n   </application>\r\n</manifest>1.4 在AndroidManifest.xml文件里面申请相机和存储权限<!--使用存储权限--><uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />2 代码开发关键步骤2.1 动态权限申请@Overrideprotected void onCreate(Bundle savedInstanceState) {\r\n    super.onCreate(savedInstanceState);\r\n    setContentView(R.layout.activity_main);\r\n    if (!allPermissionsGranted()) {\r\n        getRuntimePermissions();\r\n    }}@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,\r\n                                       @NonNull int[] grantResults) {\r\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults);\r\n\r\n    if (requestCode != PERMISSION_REQUESTS) {\r\n        return;\r\n    }\r\n    boolean isNeedShowDiag = false;\r\n    for (int i = 0; i < permissions.length; i++) {\r\n        if (permissions[i].equals(Manifest.permission.READ_EXTERNAL_STORAGE) && grantResults[i] != PackageManager.PERMISSION_GRANTED) {\r\n            // 如果相机或者存储权限没有授权，则需要弹出授权提示框\r\n            isNeedShowDiag = true;\r\n        }\r\n    }\r\n    if (isNeedShowDiag && !ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CALL_PHONE)) {\r\n        AlertDialog dialog = new AlertDialog.Builder(this)\r\n                .setMessage(getString(R.string.camera_permission_rationale))\r\n                .setPositiveButton(getString(R.string.settings), new DialogInterface.OnClickListener() {\r\n                    @Override                    \r\n                    public void onClick(DialogInterface dialog, int which) {\r\n                        Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);\r\n                        intent.setData(Uri.parse(\"package:\" + getPackageName())); // 根据包名打开对应的设置界面\r\n                        startActivityForResult(intent, 200);\r\n                        startActivity(intent);\r\n                    }\r\n                })\r\n                .setNegativeButton(getString(R.string.cancel), new DialogInterface.OnClickListener() {\r\n                    @Override                    \r\n                    public void onClick(DialogInterface dialog, int which) {\r\n                        finish();\r\n                    }\r\n                }).create();\r\n        dialog.show();\r\n    }}2.2 创建图像分割检测器可以通过图像分割检测配置器“MLImageSegmentationSetting”创建图像分割检测器。MLImageSegmentationSetting setting = new MLImageSegmentationSetting.Factory()\r\n                .setAnalyzerType(MLImageSegmentationSetting.BODY_SEG)\r\n                .setExact(true)\r\n                .create();        \r\nthis.analyzer = MLAnalyzerFactory.getInstance().getImageSegmentationAnalyzer(setting);2.3 通过android.graphics.Bitmap创建“MLFrame”对象用于分析器检测图片可以通过图像分割检测配置器“MLImageSegmentationSetting”创建图像分割检测器。MLFrame mlFrame = new MLFrame.Creator().setBitmap(this.originBitmap).create();2.4 调用“asyncAnalyseFrame ”方法进行图像分割。// 创建一个task，处理图像分割检测器返回的结果。 Task<MLImageSegmentation> task = analyzer.asyncAnalyseFrame(frame); // 异步处理图像分割检测器返回结果 Task<MLImageSegmentation> task = this.analyzer.asyncAnalyseFrame(mlFrame);\r\n            task.addOnSuccessListener(new OnSuccessListener<MLImageSegmentation>() {\r\n                @Override                public void onSuccess(MLImageSegmentation mlImageSegmentationResults) {\r\n                    // Transacting logic for segment success.\r\n                    if (mlImageSegmentationResults != null) {\r\n                        StillCutPhotoActivity.this.foreground = mlImageSegmentationResults.getForeground();\r\n                        StillCutPhotoActivity.this.preview.setImageBitmap(StillCutPhotoActivity.this.foreground);\r\n                        StillCutPhotoActivity.this.processedImage = ((BitmapDrawable) ((ImageView) StillCutPhotoActivity.this.preview).getDrawable()).getBitmap();\r\n                        StillCutPhotoActivity.this.changeBackground();\r\n                    } else {\r\n                        StillCutPhotoActivity.this.displayFailure();\r\n                    }\r\n                }\r\n            }).addOnFailureListener(new OnFailureListener() {\r\n                @Override                public void onFailure(Exception e) {\r\n                    // Transacting logic for segment failure.\r\n                    StillCutPhotoActivity.this.displayFailure();\r\n                    return;\r\n                }\r\n            });2.5 更换图片背景。this.backgroundBitmap = BitmapUtils.loadFromPath(StillCutPhotoActivity.this, id, targetedSize.first, targetedSize.second);BitmapDrawable drawable = new BitmapDrawable(backgroundBitmap);this.preview.setDrawingCacheEnabled(true);this.preview.setBackground(drawable);this.preview.setImageBitmap(this.foreground);this.processedImage = Bitmap.createBitmap(this.preview.getDrawingCache());this.preview.setDrawingCacheEnabled(false);结后语就这样，一款证件DIY的小程序就制作好了，给大家看下Demo的演示效果：基于图像分割能力不仅仅可以用来做证件照DIY程序，还可以实现如下相关功能：生活照的人像抠图，更换背景制作一些趣味的照片，或者对背景做虚化得到更美、更有艺术效果的照片。识别图像中的天空、植物、美食、猫狗、花朵、水面等、沙面、建筑、山峰等元素，针对这些元素做特殊的美化，比如让天空更蓝，水更清澈。识别视频流中的对象，对视频流进行特效编辑、更换背景。其它功能请大家一起开脑洞吧！更详细的开发指南参考华为开发者联盟官网华为开发者联盟机器学习服务开发指南往期链接： Android | 教你如何用华为HMS MLKit SDK 三十分钟在安卓上开发一个微笑抓拍神器内容来源： https://developer.huawei.com/consumer/cn/forum/topicview?tid=0201203408959360433&fid=18原作者：AI_talking"}
{"title": "小程序如何在业务系统中接入图片安全校验", "author": "Rolan", "time": "2020-4-7 00:45", "content": "在小程序开发的过程中，如果你的小程序中存在图片上传的能力，经常会遇到同一个原因被拒绝审核：「没有对上传信息做审核」，想要过审核也很简单，只要将用户上传的图片提交审核就可以了。而且，微信也提供了这样的接口给开发者，让开发者做接入。如果你使用了云开发，那就更加的简单，只需要使用云调用，一行代码就可以完成产品的调用。如何使用云函数中接入图片安全校验不少人看过一个视频，里面的代码大致是这样写的，很简单，但很有效的完成了图片的安全检测// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const img = (await cloud.downloadFile({\r\n    fileID:event.fileID\r\n  })).fileContent;\r\n  return await cloud.openapi.security.imgSecCheck({\r\n    media:{\r\n      contentType:'image/png',\r\n      value:img\r\n    }\r\n  });\r\n}这段代码在绝大多数情况下都是不会出现运行问题的，但是，这个大多数情况是指 这个图片没有安全问题 ，如果这个图片的内容有问题，你的小程序运行就会报错，就像下面这样。这样的报错有问题么？没有的，因为这个就是系统的运行机制，但是，这样的问题如果不做处理，就会在实际应用过程中出现问题。这段报错的意思是： 由于检测的内容出现了问题，导致系统出现了异常，从未抛出了一个异常，在这种情况下，开发者需要做的就是捕获这个异常。在 JavaScript 中，我们只需要在我们的项目中加入 try...catch... 就可以处理了。加入 try...catch... 后，我们得到的代码是这样的// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const img = (await cloud.downloadFile({\r\n    fileID:event.fileID\r\n  })).fileContent;\r\n  try {\r\n    await cloud.openapi.security.imgSecCheck({\r\n      media:{\r\n        contentType:'image/png',\r\n        value:img\r\n      }\r\n    });\r\n    return {\r\n      code: 0,\r\n      msg: \"ok\"\r\n    }\r\n  } catch (err) {\r\n    return {\r\n      code: 1,\r\n      msg: err\r\n    }\r\n  }\r\n}这段代码会在图片没有问题的时候回复一个 { \"code\": 0, \"code\":\"ok\"} ,如果图片有问题的话，就会返回 {\"code\":1,\"msg\":\"错误的原因\"} 。在这种情况下，你只需要在云函数的返回值中获取到 code ，如果等于 0 ，就说明用户上传的图片通过审核。如果返回 1 ，则说明用户的图片没有通过审核。如何在业务系统中加入图片安全校验前面的内容介绍了如何开发出一个图片安全校验的云函数，接下来，我们来看看如何在业务系统中接入这个功能。实际上，我们有两种方式在业务系统中实现图片安全校验，一种是前置校验，一种是后置校验。前置校验是指用户所提交的数据还没有提交到数据库前对图片进行校验，如果图片不合格，就不允许图片提交到数据库中。后置校验则是指用户所提交的数据先提交到数据库中，并标记为审核中状态， 后续通过审核再修改状态为通过，从而让用户提交的内容在前台可见。一般而言，推荐大家使用前置校验，这样可以避免错误的数据进入到你的数据库中，后续可能有风险。如果你的系统对于性能的要求特别特别的高，而安全校验接口返回速度慢一些，在这种情况下，你可以选择后置校验，降低用户在提交数据时的等待时间。不过，后置校验的话，一定记得在前端进行查询的时候，将未审核的部分提醒用户，不可访问，避免出现审核问题。总结在小程序中接入图片安全校验功能很简单， 不过，在实际的接入过程中， 你还是需要配合自己的实际业务情况来选择如何接入。如果你在开发的过程中有任何问题，欢迎在下方留言告诉我。"}
{"title": "谈谈小程序自动化", "author": "Rolan", "time": "2020-4-8 00:02", "content": "浏览器领域，我们有如selenium和puppeteer这样的库，可以自动化控制浏览器执行自动化脚本，以完成自动化端对端测试、定时自动化任务等。随着持续集成、持续部署也就是CI/CD的需求日益增长，自动化也成为必不可少的一环。对于日益增长的小程序开发需求，我们能不能自动化控制小程序呢，进而达成自动测试、自动发布等任务呢？针对微信小程序，自2019年5月，微信官方也开始提供了一个官方的自动化SDK： miniprogram-automator 。这是一个通过NodeJS操控开发者工具以及远程真机中微信的SDK。通过这个SDK，可以控制小程序跳转到指定页面、获取小程序页面数据、获取小程序页面元素状态、触发小程序元素绑定事件、往 AppService 注入代码片段、调用 wx 对象上任意接口等等。这个SDK通过脚本控制本机的微信开发者工具来近似达到自动化测试业务的目的，同时，也可通过远程控制真机，达到真机测试的目的。原理与初步体验我们首先来体验一下这个SDK。首先，你需要确保你安装了微信开发者工具，并且版本大于1.02.1907232，并设置你的基础库版本在2.7.3以上，同时请安装NodeJS 8.0以上的版本。我们知道，微信开发者工具提供了命令行与 HTTP 服务两种接口供外部调用，开发者可以通过命令行或 HTTP 请求指示工具进行登录、预览、上传等操作。SDK通过命令行方式将微信开发者工具调起，再通过外部方式导入目标项目。微信开发者工具通过读取目标项目的project.config.js，初始化项目。并读取启动命令的 --auto-port 参数，使得SDK可以通过此端口的Websocket服务，实现与对应的目标小程序调试窗口进行交互。这就是 miniprogram-automator 工作的大致原理。感兴趣的读者可以尝试使用微信开发者工具的cli方式来尝试运行此命令。cli auto --project { 项目路径 } --auto-port { websocket的端口 }为了运行上述命令，我们需要找到微信开发者工具的安装目录。不同的操作系统位置不同。Mac位于:<安装路径>/Contents/MacOS/cli，windows位于: <安装路径>/cli.bat。对于经常使用的读者，建议将cli所在的目录放在系统的环境变量中。你可能遇到IDE服务超时的情况。因此，为了保证开发者工具能够通过命令行打开，需要将开发者工具的HTTP服务调用接口打开。打开的方式是，进入微信开发者工具，选择：设置 > 安全设置。在服务端口中选择：打开。此时，微信开发者工具会自动指定一个可用的端口号。细心的读者会发现这里又出现了一个“端口”。不同于上面提到的端口，这个端口是IDE提供对外服务的端口。如上图所示，36146是IDE服务的端口。你在启动IDE之后，可以访问 http://127.0.0.1:36146/open你的IDE就会聚焦到你的面前。 http://127.0.0.1:36146/ 是IDE服务的根域名，open是命令，读者可以参考 命令索引 通过不同的URL发出不同的命令。好，安装好了SDK，我们来操练一下：首先，我们init一个npm库如 auto ，通过： npm i miniprogram-automator --save-dev 或 yarn add miniprogram-automator --dev 即可安装 miniprogram-automator 。接下来，我们下载一个 微信示例程序 ，并解压在~/demo-miniapp/下面，我们新建一个文件，如index.js，内容如下：const automator = require('miniprogram-automator')\r\n\r\nautomator.launch({\r\n  projectPath: '~/demo-miniapp/', // 项目文件地址\r\n}).then(async miniProgram => {\r\n  const page = await miniProgram.reLaunch('/page/tabBar/component/index')\r\n  await page.waitFor(500)\r\n  const element = await page.$('.kind-list-text')\r\n  console.log(await element.attribute('class'))\r\n  await element.tap()\r\n  await page.waitFor(500)\r\n\r\n  await miniProgram.close()\r\n})现在，让我们运行起来。 node index.js 。我们看到，IDE自动启动，并加载了我们的项目文件，并自动地点开了第一个项目，过一段时间之后，程序自动的退出。这就是我们对于自动运行的初步体验。API组成截至目前（2020年4月初）最新的SDK的API主要分四个模块：Automater、MiniProgram、Page和Element等。Automator 模块提供了启动及连接开发者工具的方法。开发者可以对连接地址、端口号、项目路径等作出设置。归根结底是对于cli的包装。详见： AutomatorMiniProgram提供对小程序的控制。提供以下几类支持，详见： MiniProgram ：路由方法。控制小程序的跳转系统信息。与API的wx.getSystemInfo等价转调、mock以及恢复微信API对象wx上的方法在APP对象上注入方法、向小程序暴露方法截图、滚动等方法测试真机、截图、测试账号、关闭等方法打印事件、报错事件Page 模块提供了控制小程序页面的方法。提供以下几类支持，详见： Page ：页面路径方法页面元素选取方法页面元素/逻辑钩子方法页面数组方法页面行为方法页面方法调用代理Element 模块提供了控制小程序页面元素的方法。提供以下几类支持，详见： Element ：元素本身属性获取方法元素子代与后继选择器方法元素事件触发方法元素数据访问方法元素方法访问代理方法可以看出，除Automator之外，每个API模块都在自己的领域内提供对小程序自身内容的访问特性以及扩充特性。这比较类似于Pupputeer的API设定。与测试框架的整合miniprogram-automator 本身不提供测试框架，我们可以选用熟悉的测试框架与之整合。这里我们以jest为例。其他诸如mocha、jasmine、Cucumber都比较类似。现在，在我们之前的项目 auto 里安装jest。 npm i jest -g 或 yarn global add jest简单科普下jest的工作原理。在项目中，jest识别三种测试文件：以.test.js结尾的文件以.spec.js结尾的文件放到 tests 文件夹中的文件。Jest 在进行测试的时候，它会在整个项目进行查找，只要碰到这三种文件它都会执行。Jest有以下设定：一个describe块称为一个“测试套件”。一个it/test块，称为“测试用例”。测试用例是测试的最小单位。每个测试文件应至少包含一个describe或一个it/test块。一个describe块应至少包含一个或多个it/test块。每个测试用例，可以组合各种断言来判定是否符合预期。Jest 测试提供了一些测试的生命周期 API。可以辅助我们在每个 case 的开始和结束做一些处理。 这样，在进行一些和数据相关的测试时，可以在测试前准备一些数据，在测试后，清理测试数据。 4 个主要的生命周期函数：afterAll(fn, timeout): 当前文件中的所有测试执行完成后执行 fn, 如果 fn 是 promise，jest 会等待 timeout 毫秒，默认 5000afterEach(fn, timeout): 每个 test 执行完后执行 fn，timeout 含义同上beforeAll(fn, timeout): 同 afterAll，不同之处在于在所有测试开始前执行beforeEach(fn, timeout): 同 afterEach，不同之处在于在每个测试开始前执行回到 miniprogram-automator 。我们可以在 auto 项目中加入一个index.spec.js文件。const automator = require('miniprogram-automator')\r\nlet miniProgram, page\r\n\r\nbeforeAll(async () => {\r\n    miniProgram = await automator.launch({\r\n        projectPath: '/Users/liuguanyu/devspace/demo-miniapp/'\r\n    })\r\n    page = await miniProgram.reLaunch('/page/tabBar/component/index')\r\n    await page.waitFor(500)\r\n}, 50000)\r\n\r\nafterAll(async () => {\r\n    await miniProgram.close()\r\n})现在，你在 auto 下运行 jest 会报错。意思是需要我们增加至少一个测试套件或测试用例。为此我们增加一个测试套件，并增加一些测试用例，修改如下：const automator = require('miniprogram-automator')\r\nlet miniProgram, page\r\n\r\nbeforeAll(async () => {\r\n    miniProgram = await automator.launch({\r\n        projectPath: '/Users/liuguanyu/devspace/demo-miniapp/'\r\n    })\r\n    page = await miniProgram.reLaunch('/page/tabBar/component/index')\r\n    await page.waitFor(500)\r\n}, 50000)\r\n\r\ndescribe(\"测试微信小程序\", () => {\r\n    // 1. 测试顶部描述\r\n    it(\"标题栏\", async () => {\r\n        const desc = await page.$('.index-desc')\r\n        // 要求测试标签名必须为view\r\n        expect(desc.tagName).toBe('view')\r\n        // 要求测试内容包含文字以下将展示小程序官方组件能力\r\n        expect(await desc.text()).toContain('以下将展示小程序官方组件能力')\r\n    })\r\n\r\n    // 2. 测试列表项\r\n    it('列表项', async () => {\r\n        const lists = await page.$$('.kind-list-item')\r\n        // 测试共有7个列表项\r\n        expect(lists.length).toBe(7)\r\n        const list = await lists[0].$('.kind-list-item-hd')\r\n        //第一个列表元素的标题应该是“视图窗器”\r\n        expect(await list.text()).toBe('视图容器')\r\n    })\r\n\r\n    // 3. 测试列表项行为\r\n    it('列表行为', async () => {\r\n        const listHead = await page.$('.kind-list-item-hd')\r\n\r\n        // 点击应展开未展开项\r\n        expect(await listHead.attribute('class')).toBe('kind-list-item-hd')\r\n        await listHead.tap()\r\n        await page.waitFor(200)\r\n        expect(await listHead.attribute('class')).toBe(\r\n            'kind-list-item-hd kind-list-item-hd-show',\r\n        )\r\n\r\n        // 再次点击应合上\r\n        await listHead.tap()\r\n        await page.waitFor(200)\r\n        expect(await listHead.attribute('class')).toBe('kind-list-item-hd')\r\n\r\n        // 点击子列表项应该会跳转到指定页面\r\n        await listHead.tap()\r\n        await page.waitFor(200)\r\n        const item = await page.$('.index-bd navigator')\r\n        await item.tap()\r\n        await page.waitFor(1500)\r\n        expect((await miniProgram.currentPage()).path).toBe('page/component/pages/view/view')\r\n    })\r\n\r\n    // 4. 验证wxml方法和setData方法及快照比对\r\n    it('验证WXML', async () => {\r\n        const element = await page.$('page')\r\n        expect(await element.wxml()).toMatchSnapshot()\r\n        await page.setData({\r\n            list: []\r\n        })\r\n        expect(await element.wxml()).toMatchSnapshot()\r\n    })\r\n\r\n    // 5. mock方法测试并还原\r\n    it('伪造请求结果', async () => {\r\n        // 伪造请求数据\r\n        const mockData = [{\r\n            rule: 'testRequest',\r\n            result: {\r\n                data: 'test',\r\n                cookies: [],\r\n                header: {},\r\n                statusCode: 200,\r\n            }\r\n        }]\r\n\r\n        // mock方法\r\n        await miniProgram.mockWxMethod(\r\n            'request',\r\n            function (obj, data) {\r\n                for (let i = 0, len = data.length; i < len; i++) {\r\n                    const item = data[i]\r\n                    const rule = new RegExp(item.rule)\r\n                    if (rule.test(obj.url)) {\r\n                        return item.result\r\n                    }\r\n\r\n                    // 没命中规则的真实访问后台\r\n                    return new Promise(resolve => {\r\n                        obj.success = res => resolve(res)\r\n                        obj.fail = res => resolve(res)\r\n                        this.origin(obj)\r\n                    })\r\n                }\r\n            },\r\n            mockData\r\n        )\r\n\r\n        // 请求mock的方法\r\n        const result = await miniProgram.callWxMethod('request', {\r\n            url: 'https://14592619.qcloud.la/testRequest',\r\n        })\r\n        expect(result.data).toBe('test')\r\n        // 还原方法\r\n        await miniProgram.restoreWxMethod('request')\r\n    }, 30000)\r\n})\r\n\r\nafterAll(async () => {\r\n    await miniProgram.close()\r\n})此时，我们在 auto 目录下再次运行 jest ，则得到如下结果：我们看到所有的测试都已通过。真机测试真机测试可以自动测试以及扫码测试。此时可以在beforeAll里面加入 await miniProgram.remote(true) 。这个true如果不写，就需要用真机扫码测试。当编译好之后，开发者工具会自动将小程序和调试工具发送到真机。并在侧边增加了测试条。当不写true时候，运行到remote时，会弹出这样的对话框：小结发布3年多，微信小程序已经从微信生态的一环，逐步向多领域渗透。随着开发者的日益增多，面向开发的工具也逐步完善。本文试图管中窥豹，给大家介绍了微信自动化的主要环节。时至今日，小程序已经成长为一种重要的产品形式和生态环境。越来越多的小程序平台正在自己的领域以不同的形式给小程序这个产品形式添砖加瓦。小程序生态和开发环节的完善和成长，也需要广大平台、开发者共同努力，将这一Created in China 的生态体系发扬光大。"}
{"title": "微信小程序初始化项目架构", "author": "Rolan", "time": "2020-4-8 00:12", "content": "好维护的项目需要一个好的架构开始，下面的架构是我根据七个微信小程序项目总结开发者新建项目该架构未使用 云开发 ，需要 云开发 额外勾选使用npm从小程序基础库版本 2.2.1 或以上、及开发者工具 1.02.1808300 或以上开始，小程序支持使用 npm 安装第三方包。 首先我们需要初始化项目包，可以看到项目根目录生成了包配置文件 package.jsonnpm init -y\r\n复制代码使用vant-ui使用ui框架可以帮助我们提高开发效率，重复造轮子。 Vant-Weapp 框架就是一个不错的选择。步骤一 通过 npm 安装# 通过 npm 安装\r\nnpm i @vant/weapp -S --production\r\n复制代码步骤二 构建 npm 包 打开微信开发者工具，点击 工具 -> 构建 npm，并勾选 使用 npm 模块 选项，构建完成后，即可引入组件behaviors公用行为behaviors 是用于组件间代码共享的特性，类似于 vue 中的“mixins”。每个 behavior 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。 每个组件可以引用多个 behavior ， behavior 也可以引用其他 behavior 。详细的参数含义和使用请参考 Behavior 参考文档。 在behaviors目录下新建testBehavior.js，一般我会根据模块创建 behavior ,像用户模块会新建userBehavior.js<!--behaviors/testBehavior.js-->\r\nexport default Behavior({\r\n  properties: {\r\n\r\n  },\r\n  data: {\r\n    testData: {}\r\n  },\r\n  \r\n  methods: {\r\n    /**\r\n     * @description 测试方法\r\n     */\r\n    testMethods () {\r\n\r\n    }\r\n  }\r\n})\r\n复制代码components公用组件全局公用组件components该目录存放着项目中公共的组件，包括一些弹出层，加载组件等。组件以大驼峰命令，组件中可以再抽离各个小组件形成。页面的业务组件components每个页面组件应该由不同的小组件组件，这样拆成各个小组件开发，有助于我们维护开发。页面引入组件{\r\n  \"usingComponents\": {\r\n    \"index-child\": \"./components/IndexChild/index\",\r\n    \"index-child2\": \"./components/IndexChild2/index\"\r\n  }\r\n}\r\n复制代码页面由各个组件组件，分别处理组件的业务逻辑<!--index.wxml-->\r\n<view class=\"container\">\r\n  <index-child />\r\n  <index-child2 />\r\n</view>\r\n复制代码config配置在config目录新建index.js配置项目所需的要配置const BASE_URL = 'https://shop.freshlejia.com/apiStore/'  //接口请求的基本路径\r\n\r\nexport default {\r\n  BASE_URL,\r\n  UPLOAD_URL: `${BASE_URL}api/common/upload` //上传服务器的路径\r\n}\r\n复制代码icons目录配置iconfont字体步骤一：在iconfont.cn新建项目组步骤二：添加项目所需的icon，下载相对对应的文件步骤三： 项目引入相关文件 在根目录新建icons,存放刚才下载的文件吗，修改 iconfont.css文件成 iconfont.wxss全局项目文件中引入/**app.wxss**/\r\n@import './icons/iconfont';\r\n复制代码images图片资源存放图片资源，也可按模块新建子目录存放。小图标可以转base64，具体项目根据自己需求来。utils工具包utils目录存放和项目有关的工具包文件使用http请求库flyio小程序提供的官方提供了request请求，但是我们需要封装成我们项目使用的请求才行，因为我们总会需要全局请求拦截处理，全局请求响应处理等，我们能不能在小程序中像 vue 项目中使用 axios 一样, fiyio 工具包就可以帮助我们使用这个问题。我们可以有以下两种方式实现选择（推荐后者面向对象）：封装请求包对象步骤一：下载 flyio 包存放在 utils 下步骤二：封装http.js文件<!--utils/http.js-->\r\nimport config from '../config/index'\r\nconst Fly = require('./flyio/index')\r\nconst fly = new Fly\r\n\r\n//定义请求的基本路径\r\nfly.config.baseURL = config.BASE_URL\r\n\r\n//请求拦截器\r\nfly.interceptors.request.use(request => {\r\n  //拦截处理\r\n  request.headers = { //请求头\r\n    \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n  }\r\n  return request\r\n})\r\n\r\n//响应拦截\r\nfly.interceptors.response.use(response => {\r\n  //拦截处理操作\r\n  return response\r\n})\r\n\r\n\r\nexport const api = {\r\n  //返回结果的状态码\r\n  CODE: {\r\n    SUCCESS: 200000, //调用成功\r\n    OPTIONS_ERROR: 5000100 //参数错误\r\n  },\r\n\r\n  get: (params) => {\r\n    return fly.get(params.url, params.data)\r\n  },\r\n\r\n  post: (params) => {\r\n    return fly.post(params.url, params.data, params.options)\r\n  }\r\n}\r\n复制代码封装请求基类(ES6的class方式实现)重写封装中(待定)...项目工具tool处理函数文件新建tool.js文件，编写项目工具小函数const formatNumber = n => {\r\n  n = n.toString()\r\n  return n[1] ? n : '0' + n\r\n}\r\n\r\nmodule.exports = {\r\n  formatNumber: formatNumber\r\n}\r\n复制代码项目业务相关工具函数文件新建index.js文件，编写业务相关函数/**\r\n * @description 检查是否需要更新小程序\r\n */\r\nexport function checkUpdateApp() {\r\n  if (wx.canIUse('getUpdateManager')) {\r\n    const updateManager = wx.getUpdateManager()\r\n    updateManager.onCheckForUpdate(function (res) {\r\n      // 请求完新版本信息的回调\r\n      if (res.hasUpdate) {\r\n        console.log('res.hasUpdate====')\r\n        updateManager.onUpdateReady(function () {\r\n          wx.showModal({\r\n            title: '发现新版本',\r\n            content: '升级至新版本，享受最新最全的活动内容',\r\n            showCancel: false,\r\n            success: function (res) {\r\n              // res: {errMsg: \"showModal: ok\", cancel: false, confirm: true}\r\n              if (res.confirm) {\r\n                // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启\r\n                updateManager.applyUpdate()\r\n              }\r\n            }\r\n          })\r\n        })\r\n        updateManager.onUpdateFailed(function () {\r\n          // 新的版本下载失败\r\n          wx.showModal({\r\n            title: '已经有新版本了哟~',\r\n            content: '新版本已经上线啦~，请您删除当前小程序，重新搜索打开哟~',\r\n            showCancel: false\r\n          })\r\n        })\r\n      }\r\n    })\r\n  }\r\n}\r\n复制代码models模块封装类该模块主要是采用 MVC 的M层，处理数据层面，主要包括相关的http请求等。import { api } from '../utils/http'\r\n\r\nclass UserModel{\r\n  /**\r\n   * @description 获取当前登录的用户信息\r\n   */\r\n  getUserInf (id) {\r\n    return api.post({\r\n      url: 'store/user/info',\r\n      data:{\r\n        id\r\n      }\r\n    })\r\n  }\r\n\r\n}\r\n\r\nexport default UserModel\r\n复制代码pages视图层该模块主要是采用 MVC 的V层，建议按照模块分目录解构，比如用户模块的业务全部建议在user文件夹下。wxs过滤器项目中我们总会需要对数据进行过滤修改，我们就需要在项目中使用wxs过滤器<!--order.wxs-->\r\n/**\r\n * @description 将整数保留两位小数，若为整数或一位小数则补零\r\n * @param x \r\n */\r\nvar keepTwoDecimals = function(x) {\r\n  var f = Math.round(x * 100) / 100;\r\n  var s = f.toString();\r\n  var rs = s.indexOf('.');\r\n  if (rs < 0) {\r\n  rs = s.length;\r\n  s += '.';\r\n  }\r\n  while (s.length <= rs + 2) {\r\n  s += '0';\r\n  }\r\n  return s;\r\n}\r\n\r\nmodule.exports = {\r\n  keepTwoDecimals:keepTwoDecimals\r\n}\r\n复制代码页面组件中使用wxs<!-- order.wxml -->\r\n<wxs src=\"../../../../../filter/store.wxs\" module=\"tools\"></wxs>\r\n<view class=\"statistics-content-total__count\">\r\n{{earnings.earningsAllCount ? tools.keepTwoDecimals(earnings.earningsAllCount) : 0.00}}\r\n</view>\r\n复制代码vscode插件预处理器转wxss辅助开发less在开发微信小程序时，写css会比较麻烦，效率不高，最好的办法就是使用less或者sass，可以使用gulp等配置编译，但是使用此法又略显麻烦，最好的办法就是使用Vscode装一个less转wxss插件， Easy LESS1.在Vscode中搜索easy less 插件并安装； 2.在项目下建一个.vscode文件夹，并在.vscode文件夹下建一个settings.json，settings.json 中配置内容如下：\"less.compile\": {\r\n    \"outExt\": \".wxss\"\r\n}\r\n复制代码3.outExt 参数为导出文件名，默认为.css，可以配置为.wxss，其他配置项可查看 文档 也可以配置文件生成目录：\"less.compile\": {\r\n    \"out\": \"${workspaceRoot}\\\\css\\\\css\\\\\"\r\n}\r\n复制代码${workspaceRoot}代表当前项目的根目录，后面路径自行配置。"}
{"title": "增强微信小程序API，远离回调地狱", "author": "Rolan", "time": "2020-4-8 00:31", "content": "增强微信小程序API为什么要增强微信小程序API微信小程序因其双线程框架，导致大部分API都是异步API，比如，最常用的wx.request。而小程序的API的设计，都是采用回调形式。这样，业务过于复杂的时候，就会陷入回调地狱中，而且代码的可读性也变差。材料准备提到异步编程，Promise就该闪亮登场了。Promise微信小程序有众多的API，总不能用到哪个，封装哪个，这样太繁琐了，还是得统一封装一下，复制一套微信小程序API，代理异步方法，封装成Promise。说道代理，Proxy要闪亮登场了，但是，微信小程序除了iOS10+以上的系统，其他环境并不支持Proxy，好吧，只能让Proxy歇歇了。老老实实的使用Object.defineProperty代理吧。Object.defineProperty撸代码环节工具函数走起判断是否为对象function isObject (object) {\r\n  return Object.prototype.toString.call(object) === '[object Object]'\r\n}递归深拷贝对象function copy (object, target) {\r\n  let copyobject = target || {}\r\n  const keys = Object.keys(object)\r\n  keys.forEach(key => {\r\n    if (isObject(object[key])) {\r\n      copy(object[key], copyobject[key])\r\n    } else {\r\n      copyobject[key] = object[key]\r\n    }\r\n  })\r\n  return copyobject\r\n}代理走你function proxyProperty (object, property) {\r\n  const value = object[property]\r\n  Object.defineProperty(object, property, {\r\n    get () {\r\n      if (typeof value === 'function' && !/(Sync)$/.test(property)) {\r\n        return function(params, ...args) {\r\n          return new Promise((resolve, reject) => {\r\n            value ({\r\n              ...params,\r\n              success: res => {\r\n                params && params.success && params.success(res);\r\n                resolve(res);\r\n              },\r\n              fail: err => {\r\n                params && params.fail && params.fail(err);\r\n                reject(err)\r\n              }\r\n            }, ...args);\r\n          });\r\n        }.bind(object);\r\n      } else {\r\n        return value\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nfunction proxy (object) {\r\n  const keys = Object.keys(object)\r\n  keys.forEach(key => {\r\n    if (isObject(object[key])) {\r\n      proxy(object[key])\r\n    } else {\r\n      proxyProperty(object, key)\r\n    }\r\n  })\r\n}\r\n\r\nlet wxapi = copy(wx)\r\nproxy(wxapi)导出增强APIexport {\r\n  wxapi\r\n}app.js中导入挂载import { wxapi } from './utils/util.js';\r\nApp({\r\n  wxapi\r\n})END尽情的then，async/await吧。·"}
{"title": "Taro 小程序云开发实战", "author": "Rolan", "time": "2020-4-9 00:11", "content": "Taro是一套遵循 React 语法规范的 多端开发 解决方案。现如今市面上端的形态多种多样，Web、React-Native、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。使用 Taro ，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ/京东小程序、快应用、H5、React-Native 等）运行的代码。特性Taro遵循 React 语法规范，它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持使用 JSX 语法 ，让代码具有更丰富的表现力，使用 Taro 进行开发可以获得和 React 一致的开发体验。安装Taro项目基于 node，请确保已具备较新的 node 环境（>=8.0.0），推荐使用 node 版本管理工具 nvm 来管理 node，这样不仅可以很方便地切换 node 版本，而且全局安装时候也不用加 sudo 了。首先，你需要使用 npm 或者 yarn 全局安装 @tarojs/cli ，或者直接使用 npx ；# 使用 npm 安装 CLI\r\n$ npm install -g @tarojs/cli\r\n# OR 使用 yarn 安装 CLI\r\n$ yarn global add @tarojs/cli\r\n# OR 安装了 cnpm，使用 cnpm 安装 CLI\r\n$ cnpm install -g @tarojs/cli\r\n复制代码项目初始化使用命令创建模板项目$ taro init myApp\r\n复制代码npm 5.2+ 也可在不全局安装的情况下使用 npx 创建模板项目$ npx @tarojs/cli init myApp\r\n复制代码选择wxcloud / 小程序云开发模板模板目录结构├── client                                  小程序端目录\r\n│   ├── config                              配置目录\r\n│   │   ├── dev.js                          开发时配置\r\n│   │   ├── index.js                        默认配置\r\n│   │   └── prod.js                         打包时配置\r\n│   ├── dist                                编译结果目录\r\n│   ├── package.json\r\n│   ├── src                                 源码目录\r\n│   │   ├── app.scss                        项目总通用样式\r\n│   │   ├── app.js                          项目入口文件\r\n│   │   ├── components                      组件文件目录\r\n│   │   │   └── login                       login 组件目录\r\n│   │   │       └── index.weapp.js          login 组件逻辑\r\n│   │   └── pages                           页面文件目录\r\n│   │       └── index                       index 页面目录\r\n│   │           ├── index.scss              index 页面逻辑\r\n│   │           └── index.js                index 页面样式\r\n├── cloud                                   服务端目录\r\n│   └── functions                           云函数目录\r\n│       └── login                           login 云函数\r\n│           ├── index.js                    login 函数逻辑\r\n│           └── package.json\r\n└── project.config.json                     小程序项目配置\r\n复制代码使用要点开发时，进入 client 目录，在此目录下运行相关编译预览或打包命令使用微信开发者工具调试项目，请将项目 整个文件夹 作为运行目录。 注意： 不是 client 中生成的 dist 文件夹小程序云函数登陆云函数示例const cloud = require('wx-server-sdk')\r\ncloud.init()\r\nexports.main = async () => {\r\n const wxContext = cloud.getWXContext()\r\n return {\r\n openid: wxContext.OPENID,\r\n appid: wxContext.APPID,\r\n unionid: wxContext.UNIONID,\r\n }\r\n}\r\n复制代码在页面中调用Taro.cloud\r\n .callFunction({\r\n name: \"login\",\r\n data: {}\r\n })\r\n .then(res => {\r\n this.setState({\r\n context: res.result\r\n })\r\n })\r\n复制代码云开发踩坑筛选小程序云开发数据库的 Collection 的时间查询和 Aggregate 的时间筛选是不一样的。Collectiondb.collection('record').where({\r\n        date: _.and([_.gte(first_day), _.lte(last_day)]),\r\n      })\r\n      .get()\r\n复制代码Aggregate 中筛选日期，需要先使用 dateFromString 转换日期格式，再进行查询let queryStart = $.dateFromString({new Date('your start date').toJSON()\r\n            })\r\n            let queryEnd = $.dateFromString({new Date('your end date').toJSON()\r\n })\r\n \r\n.aggregate()\r\n            db.collection('day_record').addFields({\r\n                matched: $.and([$.gte(['$date', queryStart]), $.lte(['$date', queryEnd])])\r\n            })\r\n            .match({\r\n                matched: true,\r\n                type: type,\r\n                _openid: openid\r\n            })\r\n            .group({\r\n                _id: null,\r\n                total_money: $.sum('$money')\r\n            })\r\n            .end()\r\n复制代码定时触发器需要在目录添加 config.json{\r\n  \"triggers\": [\r\n    {\r\n      \"name\": \"timeTrigger\",\r\n      \"type\": \"timer\",\r\n      \"config\": \"0 0 9 * * * *\" // 每天早上 9 点触发\r\n    }\r\n  ]\r\n}\r\n复制代码订阅消息步骤一：小程序添加消息模板没开通的要先在微信公众平台开通订阅消息功能步骤二：获取模板ID步骤三：获取下发权限 wx.requestSubscribeMessage步骤四：调用接口下发订阅消息 subscribeMessage.send云调用需在 config.json 中配置 subscribeMessage.send API 的权限， 详情{\r\n  \"permissions\": {\r\n    \"openapi\": [\r\n      \"subscribeMessage.send\",\r\n      \"subscribeMessage.getTemplateList\" // 获取订阅消息模板列表\r\n    ]\r\n  }\r\n}\r\n复制代码发送消息订阅消息const result = await cloud.openapi.subscribeMessage.send({\r\n                touser: _openid,\r\n                page: 'pages/start/index',\r\n                data: {\r\n                    amount4: {\r\n                        value: pay + '元'\r\n                    },\r\n                    amount5: {\r\n                        value: income + '元'\r\n                    },\r\n                    amount10: {\r\n                        value: sum + '元'\r\n                    },\r\n                    thing9: {\r\n                        value: '昨日账单'\r\n                    },\r\n                    date12: {\r\n                        value: common.dateFormat(\"YYYY-mm-dd HH:MM:SS\", date)\r\n                    }\r\n                },\r\n                templateId: data[0].priTmplId // 目前只有一个订阅消息，后期要加这里记得改\r\n            })\r\n            return result\r\n复制代码"}
{"title": "你可以零侵入式实现小程序的全局状态管理吗", "author": "Rolan", "time": "2020-4-9 00:41", "content": "哈喽，今天我们聊聊小程序的状态管理～（有这玩意吗）\r\n我们要实现什么\r\n很简单，实现一个全局响应式的globalData，任何地方修改=>全局对应视图数据自动更新。\r\n并且我希望在此过程中尽量不去change原有的代码逻辑。\r\n为啥要实现\r\n写过小程序的都知道，状态管理一直是小程序的一大痛点。\r\n由于小程序官方没有一个全局状态管理机制，想要使用全局变量只能在app.js里调用App()创建一个应用程序实例，然后添加globalData属性。但是，这个globalData并不是响应式的，也就是说在某个页面中修改了其某个值（如果初始化注入到data中）无法完成视图更新，更别说全局页面和组件实例的更新了。\r\n当前的主流做法\r\n我们先来了解下当下比较流行的方案。\r\n我们以westore为例，这是鹅厂出的一款覆盖状态管理、跨页通讯等功能的解决方案，主要流程是通过自维护一个store（类似vuex）组件，每当页面或组件初始化时注入并收集页面依赖，在合适的时候手动update实现全局数据更新。提供的api也很简洁，但是如果使用的话需要对项目原有代码做一些侵入式的改变。比如说一：创建页面或组件时只能通过该框架的api完成。二：每次改变全局对象时都要显式的调用this.update()以更新视图。这里附上源码\r\n其他一些方案也都是类似的做法。但我实在不想重构原项目（其实就是懒），于是走上了造轮子的不归路。\r\n准备工作\r\n正式开始前，我们先理一下思路。我们希望实现\r\n\r\n将globalData响应式化。\r\n收集每个页面和组件data和globalData中对应的属性和更新视图的方法。\r\n修改globalData时通知所有收集的页面和组件更新视图。\r\n\r\n其中会涉及到发布订阅模式，这块不太记得的可以看看我之前的文章哟。（传送门：发布订阅模式）\r\nTalk is cheap. Show me the code.\r\n说了这么多，也该动动手了。\r\n首先，我们定义一个调度中心Observer用来收集全局页面组件的实例依赖，以便有数据更新时去通知更新。\r\n但这里有个问题，收集整个页面组件实例未免太浪费内存且影响初始化渲染（下面的obj），如何优化呢？\r\n// 1.Observer.js\r\nexport default class Observer {\r\n  constructor() {\r\n    this.subscribers = {};\r\n  }\r\n\r\n  add (key, obj) { // 添加依赖 这里存放的obj应该具有哪些东东？\r\n    if (!this.subscribers[key]) this.subscribers[key] = [];\r\n    this.subscribers[key].push(obj);\r\n  }\r\n\r\n  delete () { // 删除依赖\r\n    // this.subscribers...\r\n  }\r\n\r\n  notify(key, value) { // 通知更新\r\n    this.subscribers[key].forEach(item => {\r\n      if (item.update && typeof item.update === 'function') item.update(key, value);\r\n    });\r\n  }\r\n}\r\n\r\nObserver.globalDataObserver = new Observer(); // 利用静态属性创建实例（相当于全局唯一变量）\r\n复制代码相信很多同学想到了，其实我们只需要收集到页面组件中data和更新方法（setData）就够了，想到这里，不妨自定义一个Watcher类（上面的obj），每次页面组件初始化时new Watcher()，并传入需要的数据和方法，那我们先完成初始化注入的部分。\r\n// 2.patcherWatcher.js\r\n// 相当于mixin了Page和Component的一些生命周期方法\r\nimport Watcher from './Watcher';\r\nfunction noop() {}\r\n\r\nconst prePage = Page;\r\nPage = function() {\r\n  const obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\r\n  const _onLoad = obj.onLoad || noop;\r\n  const _onUnload = obj.onUnload || noop;\r\n\r\n  obj.onLoad = function () {\r\n    const updateMethod = this.setState || this.setData; // setState可以认为是diff后的setData\r\n    const data = obj.data || {};\r\n    // 页面初始化添加watcher 传入方法时别忘了绑定this指向\r\n    this._watcher = this._watcher || new Watcher(data, updateMethod.bind(this));\r\n    return _onLoad.apply(this, arguments);\r\n  };\r\n  obj.onUnload = function () {\r\n    // 页面销毁时移除watcher\r\n    this._watcher.removeObserver();\r\n    return _onUnload.apply(this, arguments);\r\n  };\r\n  return prePage(obj);\r\n};\r\n// 。。。下面省略了Component的写法，基本上和Page差不多\r\n复制代码接着，根据我们的计划，完成Watcher的部分。这里会对传入的data做层过滤，我们只需要和globalData对应的属性（reactiveData），并在初始化时注入Observer。\r\n// 3.Watcher.js\r\nimport Observer from './Observer';\r\nconst observer = Observer.globalDataObserver;\r\nlet uid = 0; // 记录唯一ID\r\n\r\nexport default class Watcher {\r\n  constructor() {\r\n    const argsData = arguments[0] ? arguments[0] : {};\r\n    this.$data = JSON.parse(JSON.stringify(argsData));\r\n    this.updateFn = arguments[1] ? arguments[1] : {};\r\n    this.id = ++uid;\r\n    this.reactiveData = {}; // 页面data和globalData的交集\r\n    this.init();\r\n  }\r\n\r\n  init() {\r\n    this.initReactiveData();\r\n    this.createObserver();\r\n  }\r\n\r\n  initReactiveData() { // 初始化reactiveData\r\n    const props = Object.keys(this.$data);\r\n    for(let i = 0; i < props.length; i++) {\r\n      const prop = props[i];\r\n      if (prop in globalData) {\r\n        this.reactiveData[prop] = getApp().globalData[prop];\r\n        this.update(prop, getApp().globalData[prop]); // 首次触发更新\r\n      }\r\n    }\r\n  }\r\n\r\n  createObserver() { // 添加订阅\r\n    Object.keys(this.reactiveData) props.forEach(prop => {\r\n      observer.add(prop, this);\r\n    });\r\n  }\r\n\r\n  update(key, value) { // 定义observer收集的依赖中的update方法\r\n    if (typeof this.updateFn === 'function') this.updateFn({ [key]: value });\r\n  }\r\n\r\n  removeObserver() { // 移除订阅 通过唯一id\r\n    observer.delete(Object.keys(this.reactiveData), this.id);\r\n  }\r\n}\r\n复制代码最后，利用Proxy完成一个通用的响应式化对象的方法。\r\n这里有个小细节，更改数组时set会触发length等一些额外的记录，这里就不细说了，有兴趣的同学可以了解尤大在vue3.0的是如何处理的（避免多次 trigger）。\r\n// 4.reactive.js\r\nimport Observer from './Observer';\r\nconst isObject = val => val !== null && typeof val === 'object';\r\n\r\nfunction reactive(target) {\r\n  const handler = {\r\n    get: function(target, key) {\r\n      const res = Reflect.get(target, key);\r\n      return isObject(res) ? reactive(res) : res; // 深层遍历\r\n    },\r\n    set: function(target, key, value) {\r\n      if (target[key] === value) return true;\r\n      trigger(key, value);\r\n      return Reflect.set(target, key, value);\r\n    }\r\n  };\r\n  const observed = new Proxy(target, handler);\r\n  return observed;\r\n}\r\n\r\nfunction trigger(key, value) { // 有更改记录时触发更新 => 会调用所有Watcher中update方法\r\n  Observer.globalDataObserver.notify(key, value);\r\n}\r\n\r\nexport { reactive };\r\n复制代码最后的最后，在app.js引用就好啦。\r\n// app.js\r\nrequire('./utils/patchWatcher');\r\nconst { reactive } = require('./utils/Reactive');\r\n\r\nApp({\r\n  onLaunch: function (e) {\r\n    this.globalData = reactive(this.globalData); // globalData响应式化\r\n    // ...\r\n  },\r\n  // ...\r\n  globalData: { /*...*/ }\r\n复制代码总结\r\n综上，我们一步一步从 页面组件初始化注入=>定义Watcher类=>将Watcher收集到Observer中 并在此触发更新=>app.js全局引入 这几个步骤完成globalData的响应式化，结果是通过新增4个文件 app.js3行代码（包括注释等共100多行代码），几乎以零侵入的方式完成，并且实现了功能分离，具有一定的可扩展性。\r\n时间仓促，文中肯定会有一些不够严谨的地方，欢迎大家指正和讨论。\r\n感谢阅读的你！\r\n（码字不易，都看到这里了，求波点赞不过分吧。 over～）"}
{"title": "利用云函数来实现获取特定路径+参数的小程序码", "author": "Rolan", "time": "2020-4-9 00:51", "content": "背景\r\n在小程序中，可以直接分享小程序到聊天窗口，但是无法分享小程序到朋友圈，但是朋友圈又是一个重要的推广场地，所以分享小程序码就成了重要途径。常常被朋友圈刷屏的各种带有小程序码的海报，就是一个应用场景。\r\n普通的分享小程序码，直接在后台放一个通用的小程序码就可以了。但是如果需要分享一个特定路径+参数的小程序码就必须要借助小程序提供的API来实现了。\r\n此次来和大家说一说如何利用云函数来实现获取特定路径+参数的小程序码。\r\n接口\r\n云函数为我们提供了三种获取小程序码的API：\r\n\r\n前两个都有数量限制，无法满足一些类似详情分享的场景，所以留给我们的道路只有wxacode.getUnlimited接口了。\r\n先来看一下这个接口的主要参数：\r\n\r\n\r\n\r\n其他参数就不一一列举了，有需要可以直接去官方文档查看。\r\n根据上面的参数，我们可以指定任意page，而且还可以传入页面参数，最终在小程序页面加载的时候，通过options来获取到scene，从而做数据加载。\r\n实现\r\n云函数\r\n先来看一下云函数如何配置。\r\n新建一个云函数qrcode后，在config.json中配置如下：\r\n{\r\n  \"permissions\": {\r\n    \"openapi\": [\r\n      \"wxacode.getUnlimited\"\r\n    ]\r\n  }\r\n}\r\n复制代码然后在index.js中加入如下代码：\r\n// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\n\r\ncloud.init()\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  try {\r\n    let param = {\r\n      // 小程序传入的 scene 参数\r\n      scene: event.scene,\r\n      // 可以换成任意 page\r\n      page: 'pages/index/index',\r\n    };\r\n    // 调用接口\r\n    var result = await cloud.openapi.wxacode.getUnlimited(param)\r\n    return result\r\n  } catch (err) {\r\n    return err\r\n  }\r\n}\r\n复制代码然后部署到云端，云函数部分就完成了。\r\n小程序\r\n再来看看小程序端如何调用：\r\nrequestQrcode(scene) {\r\n    let that = this;\r\n    wx.cloud.callFunction({\r\n        name: 'qrcode',\r\n        data: {\r\n          scene: scene\r\n        }\r\n      })\r\n      .then((res) => {\r\n        let path = wx.env.USER_DATA_PATH + '/' + res.requestID + '.jpg'\r\n        if (res.result.contentType == 'image/jpeg') {\r\n          // 返回的结束是 base64 编码的二进制流\r\n          // 这里直接保存到文件\r\n          wx.getFileSystemManager()\r\n            .writeFile({\r\n              filePath: path,\r\n              data: res.result.buffer,\r\n              encoding: 'base64',\r\n              success: (res) => {\r\n              },\r\n              fail: (res) => {\r\n              }\r\n            })\r\n        } else {\r\n          // 异常处理\r\n        }\r\n      })\r\n  },\r\n复制代码最终在页面的onLoad(options)中可以这样获取到小程序码传递的参数scene：\r\nonLoad: function(options) {\r\n  let scene = options.scene;\r\n},\r\n复制代码这样就完成了利用云函数来生成特定路径+参数的小程序码了，后面就可以利用这个小程序码来绘制海报。\r\n问题\r\n不知道你是否注意到scene参数有一个限制,最大32个可见字符，有时候很容易就超出了，那岂不是就没法用了？\r\n没有什么可以难倒程序员！如果有，那一定是需求不合理~\r\n短链，一个很好的方案。把所有的参数生成一个唯一的短链，作为scene参数传递，最后在加载的时候先解析短链，就可以获取到超长参数啦~\r\n小技巧\r\n如果你不需要给页面传入参数，直接在小程序管理平台最上方，有个工具->生成小程序码，填上页面路径就可以生成小程序码素材啦~\r\n结尾\r\n最后分享一个成品~"}
{"title": "ZZ需求，小程序纯文本实现@功能", "author": "Rolan", "time": "2020-4-9 00:53", "content": "前言 大家肯定对@功能不陌生，在如今的各大社交软件中它是一种不可或缺的功能。实现@人的功能并不复杂，只需将@人员的id传给后端，后端下发通知即可。主要的复杂点在于一键删除功能与变色功能，web端可以使用现成库caret.js或者At.js来实现。但笔者需要在小程序中实现这个功能，而且在textarea标签里实现，当然@人名的变色功能自然而然就砍掉了。准备工作 怎么来实现一键删除呢？首先想到对@人名前后用特殊符号标记+正则来实现，但结果不是很理想，扩展性也比较差，如果还要匹配话题之类的就得多写一套代码，所以就试着找其他方法解决。发现wx.getSelectedTextRange可以获取文本框聚焦时的光标，这样就可以将@人员插入文本指定位置。文本框事件@input的可以获取到变化的数据与位置，那就可以根据变化的位置与变化的数据来判断是否命中@人员，@人员的位置可以通过计算获取。 // bindinput事件返回值 \r\n// value为变化后的值 cursor为变化的位置 keyCode为触发的键值 \r\nconst {value, cursor, keyCode} = event.detail \r\n// 获取光标位置，聚焦时生效 \r\nwx.getSelectedTextRange({\r\n    complete: res => {\r\n        console.log('光标位置：', res.start, res.end)\r\n    }\r\n})复制代码准备工作做好了就进入实践环节，毕竟实践是检验真理的唯一标准。设计图呈现：通过点击@按钮到人员列表页面，选择人员后返回，具体如下图。这里涉及页面之间的通信问题，可以通过状态管理器、数据缓存、获取页面栈设置数据等来实现，本例中使用数据缓存。数据组装 从人员列表返回用wx.navigateBack，会触发onShow这个生命周期，所以需要在onShow里组装@数据。获取到的@人员根据光标位置对文本进行字符串截取组装，若未获取到光标位置则直接将@人员添加到文本末尾。然后对@人员数据、文本数据等进行备份，用于后续的计算。    initAtFn() {\r\n        // 获取@人员数据\r\n        const me = this\r\n        const initMemberList = wx.getStorageSync('atMemberList')\r\n        const atMemberArr = initMemberList ? initMemberList : []\r\n        // 赋值后清除@人员数据\r\n        wx.removeStorageSync('atMemberList')\r\n        // 获取上一次光标的位置\r\n        const preCursor = wx.getStorageSync('blurCursor') ? parseInt(wx.getStorageSync('blurCursor')) : me.content.length\r\n        // 将 @人员数据 并入内容区域\r\n        if (atMemberArr.length > 0) {\r\n          // 获取人员名称\r\n          const atMemberName = `@${atMemberArr[0].name}`\r\n          // 如果上次光标有记录 就根据光标分割字符串 并入@人员名称\r\n          if (preCursor.toString().length !== me.content.length) {\r\n            const start = me.content.substring(0, preCursor)\r\n            const end = me.content.substring(preCursor)\r\n            me.content = `${start}${atMemberName}${end}`\r\n          } else {\r\n            me.content += `${atMemberName}`\r\n          }\r\n          me.atArr = me.atArr.concat(atMemberArr) // 合并人员\r\n          wx.setStorageSync('blurCursor', preCursor + atMemberName.length)\r\n        }else {\r\n          wx.setStorageSync('blurCursor', me.content.length)\r\n        }\r\n        me.focus = true\r\n        me.copyContent = me.content\r\n        me.executeArr = me.getAtMemberPosFn() // 获取@人员位置\r\n      }复制代码计算@人员位置对@人员数组进行遍历，计算@人员在文本中的位置区间。通过indexOf来获取起点(这里有一个缺陷，也是需要优化的点，当手动输入的内容中有和@人员名字相同的字段时，那么位置靠前的那一个将会生效)，终点为起点+名字长度。这里有个问题：如果重复@相同的人员，删除时怎么区分呢？笔者想当然的使用了时间戳，结果发现在遍历中使用时间戳并不准确，只有规规矩矩生成唯一值。计算时收集了人员位置的最值区间，在这个范围之外增减文本不会影响@人员的完整性。下面是代码：    getAtMemberPosFn() {\r\n        const me = this\r\n        const [tipArr, left, right] = [ [], [], [] ]\r\n        // 根据@人员的数组来匹配计算所处位置\r\n        me.atArr.map(item => {\r\n          const name = item.name\r\n          const userId = item.userId\r\n          // 此处有一个缺陷 如果手输入的和获取的@人名字相同 第一个会生效 第二个不会生效\r\n          let start = me.copyContent.indexOf(name)\r\n          \r\n          if (tipArr.length > 0) {\r\n            const _arr = tipArr.filter(v => v.name.includes(name))\r\n            if (_arr.length > 0) {\r\n              start = me.copyContent.indexOf(name, _arr[_arr.length - 1].end)\r\n            }\r\n          }\r\n          \r\n          const end = name.length + start // end\r\n          left.push(start)\r\n          right.push(end)\r\n          //  获取唯一标识 是用于重复@的区分\r\n          const guid = me.createGuidFn()\r\n          const tipObj = {\r\n            start: start - 1, // @ - 1\r\n            end,\r\n            name,\r\n            atName: `@${name}`,\r\n            type: item.userId, \r\n            userId: userId,\r\n            code: guid\r\n          }\r\n          tipArr.push(tipObj)\r\n        })\r\n        \r\n        // 获取区间左右最值\r\n        right.length > 0 ? me.maxAt = Math.max(...right) : me.maxAt = 0\r\n        left.length > 0 ? me.minAt = Math.min(...left) : me.minAt = 0\r\n        me.atArr = tipArr\r\n        return tipArr\r\n      }复制代码一键删除功能@人员的位置区间已经计算出来了，接下来监听输入框的内容变化实现一键删除功能，当输入框文本内容变化，会触发@input事件，它会返回变化后的值value，变化的位置cursor，我们将利用这两个数据作为是否命中@人员的判断依据。将情况分为以下几种：变化后的value为空，即清空了输入框。数据变化的光标位置大于@人员位置最值区间的最大值，即不影响@人员位置。当数据变化影响@人员时，这里对增加减少内容做了区分处理:增加时，如果增加位置小于最值的最小值，则直接重新计算位置。如果增加值的位置命中@人员位置，则过滤掉失效人员，再重新计算。这里需要注意，移动端输入法会有一次性输入多个字符，变化的位置不再是返回的光标位置，而是以光标位置减去变化前后数据的差值。删除时，获取删除的起始位置（A，B)，然后与@人员位置（start, end）作比较。\r\n当 !(A < start || B > end) 时，则为命中，将命中的@人员过滤掉即可。     changeFn(txt) {\r\n        const me = this\r\n        const { value, cursor, keyCode } = txt.detail // 改变后的值，改变的位置，按键\r\n          \r\n        // 如果改变后的值为'', 就直接返回\r\n        if(!value) {\r\n          me.content = value\r\n          me.copyContent = value\r\n          me.atArr = []\r\n          return false\r\n        }\r\n        \r\n        // 判断值改变的增减\r\n        const changeLen = value.length - me.copyContent.length\r\n        // 值改变的光标位置 不影响@人员的则不管\r\n        if (cursor > me.maxAt) {\r\n          me.copyContent = me.content\r\n          return false\r\n        }\r\n    \r\n        // 判断为 增加值\r\n        if (changeLen > 0) {\r\n          const addCursor = cursor - changeLen // 重新计算增加位置 防止移动端一次性粘贴导致失效问题\r\n          me.copyContent = me.content\r\n          // 增加值的位置 小于左区间最值 则重新计算位置\r\n          if(addCursor < me.minAt) {\r\n            me.executeArr = me.getAtMemberPosFn()\r\n            return false\r\n          }\r\n          \r\n          me.executeArr.map(item => {\r\n            const { start, end, name, code } = item\r\n            if (addCursor < end && addCursor > start) {\r\n              // 删除命中人员，则该人员失效\r\n              me.atArr = me.atArr.filter(v => v.code !== code)\r\n            }\r\n          })\r\n          \r\n          // 需要重新计算位置\r\n          me.executeArr = me.getAtMemberPosFn()\r\n        } else {\r\n          let replaceStr = '' // 应被删除的字段\r\n          const left = [] // 删除左值集合\r\n          const right = [] // 删除右值集合\r\n          const delLen = cursor - changeLen // 本身删除的长度\r\n          const deleteString = me.copyContent.substring(cursor, delLen) // 本身删除的字段 [cursor, changeLen）\r\n          // 获取应被删除的左右位置\r\n          function pushArrEvent(s, e) {\r\n            left.push(s)\r\n            right.push(e)\r\n          }\r\n    \r\n          me.executeArr.map(item => {\r\n            let { start, end, name, code } = item\r\n            // D大 <= B小 || D小 >= B大\r\n            // 命中部分为 删除部分与@人员的交集\r\n            if (!(delLen <= start || cursor >= end)) {\r\n              // 命中判定，命中位置在名字区间 左边/右边/之间/或者多选中删除的\r\n              if (delLen <= end && cursor >= start) {\r\n                pushArrEvent(start, end)\r\n              } else {\r\n                if (cursor > start) {\r\n                  if (delLen > end) {\r\n                    pushArrEvent(start, delLen)\r\n                  } else {\r\n                    pushArrEvent(start, end)\r\n                  }\r\n                } else if (cursor < start) {\r\n                  if (delLen > end) {\r\n                    pushArrEvent(cursor, delLen)\r\n                  } else {\r\n                    pushArrEvent(cursor, end)\r\n                  }\r\n                } else {\r\n                  pushArrEvent(cursor, delLen)\r\n                }\r\n              }\r\n    \r\n              // 获取一键删除区间 \r\n              const del_left = Math.min(...left)\r\n              const del_right = Math.max(...right)\r\n              // 根据区间获取一键删除字段\r\n              replaceStr = me.copyContent.substring(del_left, del_right)\r\n              // 删除后的赋值\r\n              me.content = me.copyContent.substring(0, del_left) + me.copyContent.substring(del_right)\r\n              \r\n              // @人员数组生成\r\n              me.atArr = me.atArr.filter(v => v.code !== code)\r\n            }\r\n          })\r\n          // 执行完后 重新赋值计算\r\n          me.copyContent = me.content\r\n          me.executeArr = me.getAtMemberPosFn()\r\n        }\r\n      }复制代码添加标签我们还差最后一步，那就是给@人名添加标签，用于显示时与一般文本做区分。这里踩了一个坑，用正则替换时，如果名字与名字之间存在包含关系，则会失效，所以用记录位置的方式来对文本进行截取组装。    submitTxtFn() {\r\n        const copyTxt = this.content\r\n        const arr = JSON.parse(JSON.stringify(this.atArr))\r\n        const atUserIds = [...new Set(arr.map(v=>v.userId))] // 获取@人员id\r\n        let targetContent = ''\r\n        let count = 0\r\n        // 给@人员添加wxml标签，此处用了jyf-Parser富文本解析插件，href里面的值用于点击传参\r\n        if(arr.length > 0) {\r\n          arr.forEach((item, index)=>{\r\n            let _tip = ''\r\n            const txt = copyTxt.substring(count, item.start)\r\n            // 加空格\r\n            _tip = `${txt}${item.name}\">${item.atName} `\r\n            targetContent += _tip\r\n            // 处理最后一个标签后面的文本\r\n            if(index + 1 === arr.length) {\r\n              if(item.end < copyTxt.length) {\r\n                targetContent += copyTxt.substring(item.end)\r\n              }\r\n            }\r\n            count = item.end\r\n          })\r\n        }else {\r\n          targetContent = this.content\r\n        }\r\n        \r\n        // 目标数据\r\n        const targetObj = {\r\n          content: targetContent,\r\n          atIds: atUserIds\r\n        }\r\n        \r\n        this.submitData = targetObj\r\n        return targetObj\r\n      }复制代码以上就实现了纯文本的@功能，通过计算位置来实现的优点是具有扩展性，比如一套代码可以实现#话题功能和@功能共存，只需加个type作为区分即可。缺点是一键删除时体验不是很好，并且删除后不能控制光标位置，不能实现人员名称变色等。虽然功能比较ZZ，但也比较有趣，所以就分享给大家，如果大家有更好的解决方案，评论区有请。 完整代码请移步语雀结语若有什么不对的地方，请轻点指教。"}
{"title": "微信小程序canvas图片融合及画布隐藏问题记录", "author": "Rolan", "time": "2020-4-10 00:07", "content": "近期公司项目中有一个定制卡封面需求，是将几张图片融合成一张，并可以切换卡片横竖版的效果，最终需求如图：这个需求乍一听起来并没有什么问题，只要看下小程序画布API就可以，但是实际上遇到的问题我花费两个晚上才基本解决，而且还有一个至今无法解决的问题也希望大家给出宝贵建议!知道大家不喜欢墨迹，我先上完整代码，如果大家着急需要，直接过去拿代码就可以了，里面注释很丰富！如果可以希望大家给文章点个赞，码农不易感谢支持！GitHub - BaoYuHan/applet-canvas-image: 微信小程序使用canvas图片合成案例及相关踩坑处理如果各位同学感兴趣，那可以往下看我的思路流程和踩坑记录、注意事项……思路流程图：坑：canvas的隐藏问题：对于切换横竖屏时隐藏相应的canvas这个实现，首先大家想到的肯定是wx:if，但是很遗憾，并不好使，网上查阅相关资料后发现可以添加一个父盒子宽高0+overflow:hidden，模拟器完美运行，跑到真机上还是无效。最后发现大家都是用了一个终极办法，那就是送他离开千里之外~的position:fixed+left:10000px让canvas在不该用户看到的时候滚出屏幕注意点1：用户操作：用一张能铺满canvas的图片合成，后再次点击选择图片，用一张不能铺满canvas的图片合成我这里的图片裁剪，模拟的是aspectFill模式，保证短边完全显示，长边裁剪，可能会出现图片不能铺满屏幕的情况，这时候如果用户复现上述操作，没铺满的剩余空间会显示上次绘制的内容，体验很不好。所以要在用户选择图片成功后，注意是成功，调用ctx.draw()使用填充色绘制一遍，即清空canvas注意点2：不需要处理图片裁剪以及不使用网络图片的同学可以不用wx.getImageInfo我的代码中使用了wx.getImageInfo用于获取图片信息来裁剪图片，不需要的同学可以直接在用户选择图片后就开始绘制，但是注意小程序中canvas.drawImage不能使用网络图片，网络图片要通过 getImageInfo / downloadFile 先下载到本地并获取路径后才能绘制注意点3：绘制圆角后，再绘制文字前注意设置填充色我们这里绘制圆角的原理是将画布裁剪四个弧形角，后面的内容都在这个圆角矩形中绘制，绘制圆角矩形时使用了ctx.setFillStyle('transparent')，防止图片出现圆弧有溢出颜色的情况，所以圆角矩形绘制完后注意恢复填充色，否则文字无法绘制了。注意点4：wx.canvasToTempFilePath获取失败问题1：fail回调：官网文档说明：在 draw() 回调里调用该方法才能保证图片导出成功。2. 以往的写法需要在执行 wx.canvasToTempFilePath之前开启一个一秒的计时器，因为生成canvas是异步的而且还需要耗费时间。但是在我开发中我发现去掉了也是没有问题的，可能是官方补充了这里的逻辑？未实现问题：wx.previewImage 预览合成的图片，点击发送给朋友或保存图片，图片圆角剩余部分是黑色的，如果有能解决的小伙伴欢迎评论！感谢文章：1.图片裁剪：微信小程序 画布drawImage实现图片截取 - Favour丶in - 博客园2.图片圆角：canvas图片圆角处理"}
{"title": "小程序webview分享", "author": "Rolan", "time": "2020-4-10 00:13", "content": "webview中的h5页面做某些操作后需要修改当前的分享页面，但是,此时H5页面的链接没有改变。需要有一个机制通知小程序页面要修改分享参数了。技术解决根据小程序文档，支持webview中页面以postMessage的形式向小程序通信（仅在分享，返回等特殊操作时，才触发）要点:使用wx.miniProgram.postMessage向小程序通信，当用户转发时页面可以监听到消息页面监听到的消息为历史列表，且不清除，需要自行处理小程序页面设置了onShareAppMessage可以支持分享，默认分享为当前页面用户点击转发后，会先触发webview的onMessage，再调用onShareAppMessage设置分享配置h5和小程序约定的postMessage消息格式:{\r\n    type:'消息类型',//setShareOption\r\n    ...restData // 其他参数\r\n}\r\n复制代码h5页面设置分享参数：/**\r\n * 设置weapp分享链接\r\n * @param option \r\n * @example setWeappShareOption({title:\"分享标题\",path:\"分享链接\",imageUrl:'分享图片可为空'})\r\n */\r\nexport function setWeappShareOption(option:{title:string,path:string,imageUrl:string}){\r\n    if(window['wx'] && window['wx'].miniProgram && window['wx'].miniProgram.postMessage){\r\n        window['wx'].miniProgram.postMessage({\r\n            type:'setShareOption',\r\n            title:option.title,\r\n            path:option.path,\r\n            imageUrl:option.imageUrl\r\n        });\r\n    }\r\n}\r\n复制代码小程序页面支持分享:源码地址import Taro from '@tarojs/taro'\r\nimport { WebView } from '@tarojs/components'\r\nimport {\r\n  getCurrentChannelEventHash,\r\n  resetChannelHash,\r\n} from './WebViewHashChannelData'\r\nimport { unpackUrl,packUrl } from '../../src/core/UrlHelper'\r\n\r\nconst DEFAULT_WEB_PATH = 'https://xxx.x.com/xxx' // to 参数默认的域名前缀\r\n/**\r\n * 小程序Page页面\r\n * @param to 要跳转的h5页面地址 e.g:/xxx/xxx or 完整地址 https://xxx....\r\n * @param title 要跳转的h5页面标题\r\n */\r\nexport default class H5WebView extends Taro.Component {\r\n  config = {\r\n    navigationBarTitleText: ' ',\r\n  }\r\n\r\n  state = {\r\n    url: '', // url不支持Hash\r\n    hash: '',\r\n  }\r\n\r\n  isBack = false\r\n\r\n  shareOption = {\r\n    title: null,\r\n    path: null,\r\n  }\r\n\r\n  componentWillMount() {\r\n    this.isBack = false\r\n    const to = decodeURIComponent(this.$router.params.to || '')\r\n    const urlObj = unpackUrl(to)\r\n    let url = urlObj.pathWithSearch\r\n    let hash = urlObj.hash\r\n    let title = this.$router.params.title\r\n    if (title) {\r\n      title = decodeURIComponent(title)\r\n      Taro.setNavigationBarTitle({ title: title })\r\n    }\r\n    this.setState({\r\n      url,\r\n      hash,\r\n    })\r\n    console.log('[H5WebView] mount', url, hash)\r\n  }\r\n\r\n  componentDidShow() {\r\n    // onShow\r\n    if (this.isBack) {\r\n      // 小程序页面回退，通知h5\r\n      let channelEventHash = getCurrentChannelEventHash()\r\n      // if (!channelEventHash) {// TODO 仅白名单的页面增加backPush 通过postMessage??\r\n      //     channelEventHash = getBackEventHash();// 通知游戏，上层的Page 移走了\r\n      // }\r\n      this.setState({\r\n        hash: channelEventHash,\r\n      })\r\n      // 通知完毕 重置\r\n      resetChannelHash()\r\n      console.log('[H5WebView] show set hash', channelEventHash, this.state.url)\r\n    } else {\r\n      console.log('[H5WebView] show first')\r\n    }\r\n    this.isBack = true\r\n  }\r\n \r\n  _getLastData(itemList, type) {\r\n    if (!itemList || itemList.length === 0) {\r\n      return null\r\n    }\r\n    let lastIdx = itemList.length - 1\r\n    while (lastIdx >= 0) {\r\n      let item = itemList[lastIdx]\r\n      if (item && item.type === type) {\r\n        return item\r\n      }\r\n    }\r\n  }\r\n  handleMessage(e) {\r\n    let { data } = e.detail\r\n    // 设置最后一条share\r\n    let shareOption = this._getLastData(data, 'setShareOption')\r\n    if (shareOption) {\r\n      this.shareOption = {\r\n        title: shareOption.title,\r\n        imageUrl: shareOption.imageUrl,\r\n        path: shareOption.path,\r\n      }\r\n    }\r\n    console.log('withWV handleMessage', data)\r\n  }\r\n\r\n  /**\r\n   * 支持分享消息\r\n   */\r\n  onShareAppMessage() {\r\n    if (this.shareOption) {\r\n      let path = null\r\n      if (this.shareOption.path) {\r\n        path = packUrl(this.$router.path, {\r\n          to: this.shareOption.path,\r\n          title: this.shareOption.title,\r\n        })\r\n      }\r\n      return {\r\n        title: this.shareOption.title,\r\n        path,\r\n        imageUrl: this.shareOption.imageUrl,\r\n      }\r\n    }\r\n  }\r\n\r\n  onWebViewLoad(e) {\r\n    console.log('withWV onWebViewLoad', e.detail.src, this.state.hash)\r\n    this.shareOption.path = e.detail.src //默认分享页面为当前页面\r\n  }\r\n\r\n  _normalizeTo() {\r\n    let to = this.state.url\r\n    if (!to) {\r\n      return null\r\n    }\r\n    if (to.substr(0, 4) !== 'http') {\r\n      to = DEFAULT_WEB_PATH + to\r\n    }\r\n    if (this.state.hash) {\r\n      to += '#' + this.state.hash\r\n    }\r\n    return to\r\n  }\r\n\r\n  render() {\r\n    let to = this._normalizeTo()\r\n    if (!to) {\r\n      return null\r\n    }\r\n    return (\r\n      <WebView\r\n        src={to}\r\n        onMessage={this.handleMessage}\r\n        onLoad={this.onWebViewLoad}\r\n      />\r\n    )\r\n  }\r\n}\r\n\r\n复制代码TODO可以在postMessage中加一个字段id,每次处理完后，记录上次处理的最后一条消息的id,下次处理从那条消息之后处理"}
{"title": "van-picker 在微信小程序中的用法 - 省市区多级联动", "author": "Rolan", "time": "2020-4-10 00:49", "content": "成品图一、数据格式数据是树形结构的数据数据结构 二、在xxx.json文件中引入vant组件{\"usingComponents\": {\"van-picker\":\"/components/vant-weapp/dist/picker/index\",\"van-popup\":\"/components/vant-weapp/dist/popup/index\",  },\"navigationBarTitleText\":\"用户注册\"}三、在xxx.wxml使用组件wxml页面代码四、xxx.jsjs代码js部分代码主要强调以下几点：1.多列数据格式：对象数组，其中可在页面的 value-key 来指定文字对应的 key 也就是列上所展示的内容。2.change方法的参数中 ： value： 代表当前改变之后，各列选中的数据；index：当前改变的是第几列，0代表第一列，以此类推；picker：当前多列对象picker.setColumnValues() 方法:用来设置更新各列数据。参数：columnIndex(更新第几列), values(该列数据).3.confirm方法：点击弹框的确定按钮，返回当前选中各列数据。"}
{"title": "小程序数据埋点实践之曝光量", "author": "Rolan", "time": "2020-4-13 00:02", "content": "什么是数据埋点所谓数据埋点就是应用在规定流程中 对特定行为或事件进行数据采集 。使用采集的数据做用户分析和页面分析，可以获得应用的总体使用情况，为后续优化产品和运营提供数据支撑。常见数据埋点内容包括：访问量、停留时长、曝光量、点击量、跳出率等等。微信小程序也为我们提供了自定义分析统计，其中包括 API 上报（代码埋点），填写配置（无埋点，只需在公众后台配置）。而第三方统计平台比较有名的就是阿拉丁统计，只需引入集成的 SDK，开发成本低，能够满足大部分的需求。数据埋点需要分析页面流程，确定埋点需求，选择埋点方式。如果是代码埋点，主要关注触发时机、条件判断、捕获数据，其次要注意是否有遗漏的场景没有做到埋点。代码埋点虽然成本较大（侵入代码），但是精准度较高，能够很好的满足埋点需求。什么是曝光量曝光量顾名思义是 指定元素出现在可观察视图内的次数 ，也可以理解为展示量。通常我们会使用 点击量 / 曝光量 得出 点击率 ，作为衡量一个内容是否受用户喜爱的指标之一。比如，曝光 100 次只有 10 人点击，和曝光 100 次 有 100 个人点击，很明显后者更受用户喜爱。利用这些数据参考，可以推荐更多用户喜爱的内容，以此来留住用户。交叉观察者IntersectionObserver 接口，提供了一种异步观察 目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态 的方法，祖先元素与视窗(viewport)被称为根(root)。简单来说就是，观察的目标是否和祖先元素和视窗发生交叉，即进入或离开。小程序从基础库 1.9.3 开始支持 wx.createIntersectionObserver 接口(组件内使用 this.createIntersectionObserver )，使用此接口可创建 IntersectionObserver对象 。对此接口不了解的可以查看 官方文档 。基础使用// 创建实例\r\nlet ob = this.createIntersectionObserver()\r\n// 相对于文档视窗监听\r\nob.relativeToViewport()\r\n    .observe('.box', res => {\r\n        // res.intersectionRatio 为相交比例\r\n        if (res.intersectionRatio > 0) {\r\n            console.log('进入页面')\r\n        } else {\r\n            console.log('离开页面')\r\n        }\r\n    })阈值在创建实例时可以传入一些配置，其中 thresholds （阈值）是比较重要的一项配置，它可以控制触发回调的时机。 thresholds 是一个数字类型的数组，默认为 [0] 。即相交比例为 0 时触发一次回调，下面我们来设置阈值，看看会有什么改变：// 创建实例\r\nlet ob = this.createIntersectionObserver({\r\n    thresholds: [0, 0.5, 1]\r\n})从图上可以看到，元素在相交比例为 0 、 0.5 、 1 都各自触发了一次回调。在统计曝光量设置阈值非常有用，通常我会设置为 1 ，表示元素要完全展示在页面上才会进行记录，这样数据会更加真实准确。收缩和扩展参照区域除了阈值之外还有另一项重要的设置，在使用 relativeTo 或 relativeToViewport 规定参照区域时，我们可以传入配置 margins 来收缩和扩展参照区域。 margins 包括 left 、 right 、 top 、 bottom 四个参数配置。// 创建实例\r\nlet ob = this.createIntersectionObserver()\r\n// 相对于文档视窗监听\r\nob.relativeToViewport({\r\n        bottom: -330\r\n    })\r\n    .observe('.box', res => {\r\n        // res.intersectionRatio 为相交比例\r\n        if (res.intersectionRatio > 0) {\r\n            console.log('进入页面')\r\n        } else {\r\n            console.log('离开页面')\r\n        }\r\n    })上面将参照区域底部收缩 330px，可以理解为整体的区域从底部开始被裁剪 330px，因此元素只有进入页面上半区才会触发回调。进入正题经过以上一些介绍，相信大家对交叉观察者的好处和使用都了解的差不多。接下来进入正题 ~背景此次我做的项目是资讯类目的小程序，主要用于发布和转载一些学术文章。对于这种资讯的项目，需要通过数据埋点来收集用户的阅读习惯，以此来为用户推荐文章。埋点方面用微信后台提供的自定义分析以文章为单位进行收集，而我们自己后台会以用户为单位进行收集。前者得出整体用户阅读偏好和文章热度，后者主要精确到用户，分析用户单位的阅读偏好。改造组件在分析页面布局和pm的商讨后，多处需要统计曝光量的文章区域展示都大致相同，刚好也在封装的列表组件里。于是将收集曝光量的逻辑都交由组件内部处理。组件改造：isObserver\r\nlist\r\n以下部分代码省略，只展示主要逻辑：<block wx:for=\"{{list}}\" wx:key=\"id\">\r\n    <view class=\"artic-item artic-item-{{index}}\" data-id=\"{{item.id}}\" data-index=\"{{index}}\">\r\n    </view>\r\n</block>const app = getApp()\r\nComponent({\r\n    data: {\r\n        currentLen: 0\r\n    }\r\n    properties: {\r\n        list: {\r\n            type: Array,\r\n            value: []\r\n        },\r\n        isObserver: {\r\n            type: Boolean,\r\n            value: false\r\n        }\r\n    },\r\n    observers: {\r\n        list(list) {\r\n            if (this.data.isObserver === false) {\r\n                return\r\n            }\r\n            if (list.length) {\r\n                // currentLen 记录当前列表的长度\r\n                // 用于计算监听元素的索引，对已经监听过的元素不再重复监听\r\n                let currentLen = this.data.currentLen\r\n                for (let i = 0; i < list.length - currentLen; i++) {\r\n                    let ob = this.createIntersectionObserver({\r\n                        thresholds: [1]\r\n                    })\r\n                    ob.relativeToViewport()\r\n                        .observe('.artic-item-' + (currentLen + i), res => {\r\n                            // 获取元素的dataset\r\n                            let {\r\n                                id,\r\n                                index\r\n                            } = res.dataset\r\n                            if (res.intersectionRatio === 1) {\r\n                                // 此处收集曝光量，内部处理逻辑会在下面提及\r\n                                this.sendExsureId(id)\r\n                                // 元素出现后取消观察者监听，避免重复触发\r\n                                ob.disconnect()\r\n                            }\r\n                        })\r\n                }\r\n            }\r\n            this.data.currentLen = list.length\r\n        }\r\n    }\r\n})发现:bug:理想情况应该是切换到第二个分类打印3个文章，但由于组件开始记录第一个分类列表的 currentLen ，在切换到第二个分类时， currentLen 没有被清除，导致循环长度错误。解决：首先记录列表第一项的 id ，当监听列表变化，用新列表的第一项 id 作与之比较。若不相等，则表示列表被重新赋值，此时将 currentLen 置为0。Component({\r\n    data: {\r\n        flagId: 0,\r\n        currentLen: 0\r\n    }\r\n    properties: {\r\n        list: {\r\n            type: Array,\r\n            value: []\r\n        },\r\n        isObserver: {\r\n            type: Boolean,\r\n            value: false\r\n        }\r\n    },\r\n    observers: {\r\n        list(list) {\r\n            if (this.data.isObserver === false) {\r\n                return\r\n            }\r\n            if (list.length) {\r\n                // 比较id\r\n                if (this.data.flagId != list[0].id) {\r\n                    this.data.currentLen = 0\r\n                }\r\n                let currentLen = this.data.currentLen\r\n                for (let i = 0; i < list.length - currentLen; i++) {\r\n                    let ob = this.createIntersectionObserver({\r\n                        thresholds: [1]\r\n                    })\r\n                    ob.relativeToViewport()\r\n                        .observe('.artic-item-' + (currentLen + i), res => {\r\n                            let {\r\n                                id,\r\n                                index\r\n                            } = res.dataset\r\n                            if (res.intersectionRatio === 1) {\r\n                                this.sendExsureId(id)\r\n                                ob.disconnect()\r\n                            }\r\n                        })\r\n                }\r\n            }\r\n            // 设置列表第一项id\r\n            this.data.flagId = list[0] ? list[0].id : 0\r\n            this.data.currentLen = list.length\r\n        }\r\n    }\r\n})组件优化因为需要提前监听文章的相交状态，在 list 传入时就开始循环 observe 。现在假设一个场景，在进入页面时，已经为一些文章注册完成回调，但用户并没有看过这些文章就退出页面。那是不是表示这些实例都没有被 disconnect 。解决：在 observe 时将每一个观察者实例存入数组，当组件销毁时检查数组中是否有观察者实例，如果有，则调用这些实例的 disconnect 。Component({\r\n    data: {\r\n        currentLen: 0,\r\n        obItems: [] // 存放实例的数组\r\n    },\r\n    observers: {\r\n        list(list) {\r\n            if (this.data.isObserver === false) {\r\n                return\r\n            }\r\n            if (list.length) {\r\n                if (this.data.flagId != list[0].id) {\r\n                    this.data.currentLen = 0\r\n                    // 取消实例的监听\r\n                    this.removeObItems()\r\n                }\r\n                let currentLen = this.data.currentLen\r\n                for (let i = 0; i < list.length - currentLen; i++) {\r\n                    let ob = this.createIntersectionObserver({\r\n                        thresholds: [1]\r\n                    })\r\n                    ob.relativeToViewport().observe('.artic-item-' + (currentLen + i), res => {\r\n                        let {\r\n                            index,\r\n                            id\r\n                        } = res.dataset\r\n                        if (res.intersectionRatio === 1) {\r\n                            this.sendExsureId(id)\r\n                            ob.disconnect()\r\n                            // 取消监听后 将实例移出数组\r\n                            this.data.obItems.shift()\r\n                        }\r\n                    })\r\n                    // 将实例存入数组\r\n                    this.data.obItems.push(ob)\r\n                }\r\n            } else {\r\n                // 取消实例的监听\r\n                this.removeObItems()\r\n            }\r\n            this.data.flagId = list[0] ? list[0].id : 0\r\n            this.data.currentLen = list.length\r\n        }\r\n    },\r\n    lifetimes: {\r\n        detached() {\r\n            // 组件销毁时 取消实例的监听\r\n            this.removeObItems()\r\n        }\r\n    },\r\n    methods: {\r\n        removeObItems() {\r\n            if (this.data.obItems.length) {\r\n                this.data.obItems.forEach(ob => {\r\n                    ob.disconnect()\r\n                })\r\n            }\r\n        }\r\n    }\r\n})收集处理现在组件能够收集到曝光文章的ID，剩下的就是往后台发送数据。那么问题来了，难道文章曝光一次就发起一次请求吗？如果不怕和后端同事干架的话，你可以这么做。要知道多次发起请求，服务器:pear:会很大。用户量比较大后，对服务器能够承受的并发量会有很大的考验。所以正确的做法应该是，把收集到的ID缓存起来，在达到一定数量的时候一起发送过去。接下来对收集的数据做些处理：// 这个上面收集曝光量的函数\r\nsendExsureId(id) {\r\n    if (typeof app.globalData.exposureIds === 'undefined') {\r\n        // exposureIds 是定义在全局用于存放曝光文章 ID 的数组\r\n        app.globalData.exposureIds = []\r\n    }\r\n    app.globalData.exposureIds.push(id)\r\n    // 当数组到达 50 个，开始上报数据\r\n    if (app.globalData.exposureIds.length >= 50) {\r\n        wx.$api.recordExposure({\r\n            // 因为 ID 比较多，我和后端约定好使用逗号分隔\r\n            ids: app.globalData.exposureIds.join(',')\r\n        })\r\n        // 上报后清空数组\r\n        app.globalData.exposureIds = []\r\n    }\r\n}看起来好像实现到这里就大功告成，但是我们还要考虑一种情况。假如用户只看了 40 个就退出小程序，而上报条件是达到 50 个才会发送数据，那么这部分有用的数据就会被丢失。因为小程序没有回调能够监听到小程序被销毁，这里只能使用小程序的 onHide 函数来做些事情。当小程序进入后台时 onHide 函数就会被执行，此时可以在函数里上报数据。App({\r\n    onHide() {\r\n        if (this.globalData.exposureIds.length) {\r\n            wx.$api.recordExposure({\r\n                ids: this.globalData.exposureIds.join(',')\r\n            })\r\n            this.globalData.exposureIds = []\r\n        }\r\n    }\r\n})写在最后说实话，在埋点这方面的知识不算很熟悉，业务场景也比较简单。因为没有大佬指导，也是看着需求往这方面去做，有哪里错误或遗漏请指出。如果你有更好的方案或经验，欢迎评论区交流:sparkling_heart:~"}
{"title": "写微信小程序这一个月", "author": "Rolan", "time": "2020-4-13 00:21", "content": "最近在做一个微信小程序的项目，遇到了不少坑，不得不说微信小程序的官方文档写的真的不怎么样，一开始技术选型的时候也有考虑过第三方框架，mpvue，uniapp等，但是最后考虑了下，还是先了解一下原生小程序比较好，我始终认为一开始就上第三方框架并不是很好。下面我总结了一些坑点和开发过程中容易遇到的问题。wxss or less对于写惯了less的开发来书，写wxss实在是效率低下，太煎熬了，对此可以使用vscode插件 easy-less 来解决，我是用vscode来写代码，微信开发工具只作预览。网络请求wx.request是小程序的网络请求方法，默认情况下，我们希望success是在服务器响应的状态码在2xx的时候触发，实际上不是，只要网络请求成功发出了，success方法就会触发，比如500状态码也会触发success，所以fail也只在网络请求没有发出的情况下触发，所以你必须在success重复写判断逻辑,而且也不能用promise，所以有必要封装一下// 封装前\r\nwx.request({\r\n  url: 'test.php', //仅为示例，并非真实的接口地址\r\n  data: {\r\n    x: '',\r\n    y: ''\r\n  },\r\n  header: {\r\n    'content-type': 'application/json' // 默认值\r\n  },\r\n  success (res) {\r\n    // 假设服务器的响应体是{success: true, data: 123}\r\n    if (res.statusCode === 2xx) {\r\n        fn(res.data.data)\r\n    } else {\r\n        wx.showToast({            icon: 'none',            title: res.data.message || '网络异常',            duration: 1500        })\r\n    }\r\n  },\r\n  fail (res) {\r\n    console.log(res);\r\n  }\r\n})\r\n\r\n// 封装后\r\n// request.js\r\nmodule.exports = function ({url, data, method}) {    const app = getApp();    return new Promise((resolve, reject) => {        wx.request({            method: method,            url: `${app.globalData.apiUrl}/${url}`,            data: data,            header: {                token: app.globalData.token            },            success: function (res) {                if (res.statusCode === 200) {                    const data = res.data.data;                    resolve(data);                } else if (res.statusCode === 401) {\r\n                    // 登录失效,包含业务逻辑，根据需求添加\r\n                    wx.setStorageSync('token', null); // 清除token                                        app.globalData.token = null;                    wx.setStorageSync('userInfo', {}); // 清除用户数据                    app.globalData.userInfo = {};                    wx.switchTab({                        url: '/pages/user/user'                    });                    reject(res.data);                } else if (res.statusCode >= 500) {                    wx.showToast({                        icon: 'none',                        title: res.data.message || '网络异常',                        duration: 1500                    });                    reject(res.data);                }            },            fail: function () {                wx.showToast({                    icon: 'none',                    title: '网络异常',                    duration: 1500                });            }        });    })}\r\n\r\n// app.js\r\nconst request = require('./utils/request.js');App({    onLaunch: function () {        this.request = request;    },    globalData: {        token: wx.getStorageSync('token'),        userInfo: wx.getStorageSync('userInfo'),        apiUrl: 'http://localhost:3300/api/'            }})// index.js\r\nconst app = getApp();app.request({\r\n   method: 'GET',   url: '/test'}).then(res => {    // do something});复制代码Promise finally因为在某些接口请求前会加loading，防止多次点击，然后在接口的finally中取消loading即可，在开发工具中，一切正常，但是一到真机调试就会报错，查阅资料发现微信小程序不支持promise finally，太坑了，只能加个 polyfill canvas绘图小程序一般都会有分享图片的需求，图片一般都带用户信息和小程序码，这时候就要用到canvas，而原生的canvas是如此难用和坑，所以想使用三方库，一开始试了html2canvas，html2canvas它确实很强大，可以直接获取dom绘制，但是微信小程序无法获取dom，引入之后直接报错，thirdScriptError Cannot read property 'document' of undefined TypeError: Cannot read property 'document' of undefinedhtml2canvas(document.body).then(function(canvas) {\r\n    document.body.appendChild(canvas);\r\n});复制代码Painterpainter可以使用json数据描述绘图，不用繁琐操作canvas的一大坨函数，方便很多，基本能满足需求了。中间遇到一个小问题，开发工具里，绘图后保存到相册是有头像的，但是发小程序正式包后，真机操作时，绘图的头像就会丢失，一开始以为是painter的兼容问题，后来才发现是因为开发工具是开启了不校验合法域名的，但是线上包会校验合法域名，天真的以为微信自己的头像域名不用添加，结果并不是，微信连自己都不放过，在微信小程序后台添加下合法域名就好了 https://wx.qlogo.cn获取小程序码微信有3中方式获取小程序码wxacode.createQRCode获取小程序二维码，适用于需要的码数量较少的业务场景。通过该接口生成的小程序码，永久有效，有数量限制wxacode.get获取小程序码，适用于需要的码数量较少的业务场景。通过该接口生成的小程序码，永久有效，有数量限制wxacode.getUnlimited获取小程序码，适用于需要的码数量极多的业务场景。通过该接口生成的小程序码，永久有效，数量暂无限制好像没有什么理由不选第三种吧这3个接口返回的都是图片Buffer，我们需要做下处理，有2种方式方式1：把图片存到服务器本地或转存到alioss等第三方对象服务器上，最后把地址返回给小程序前端// 服务器\r\nlet readable;\r\nlet filePath = xxx; // 自己创建一个存图片的目录\r\nconst url = `https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=${access_token}`;const result = await axios.post(url, {                scene: `a=${xxx}` // 小程序码带的参数，比如带一个邀请码            }, {                 headers: {                    'Content-Type': 'application/json' // POST 参数需要转成 JSON 字符串，不支持 form 表单提交。                },                responseType: 'arraybuffer'             });            readable = result.data;            readable.pipe(fs.createWriteStream(filePath));复制代码方式2：把Buffer转成base64返回给小程序前端，前端在转成图片存到小程序本地// 服务器\r\nconst url = `https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=${access_token}`;            const result = await axios.post(url, {                scene: `a=${xxx}` // 小程序码带的参数，比如带一个邀请码            }, {                 headers: {                    'Content-Type': 'application/json' // POST 参数需要转成 JSON 字符串，不支持 form 表单提交。                },                responseType: 'arraybuffer'             });            const base64 = Buffer.from(result.data).toString('base64');\r\n            // 返回前端            res.send({                success: true,                data: `data:image/jpg;base64,${base64}`            });\r\n\r\n// 小程序前端\r\n// base64src.js base64转图片存到小程序临时目录中\r\nconst fsm = wx.getFileSystemManager();const FILE_BASE_NAME = 'qrcode_base64src';const base64src = function(base64data) {  return new Promise((resolve, reject) => {    const [, format, bodyData] = /data:image\\/(\\w+);base64,(.*)/.exec(base64data) || [];    if (!format) {      reject(new Error('ERROR_BASE64SRC_PARSE'));    }    const filePath = `${wx.env.USER_DATA_PATH}/${FILE_BASE_NAME}.${format}`;    const buffer = wx.base64ToArrayBuffer(bodyData);    fsm.writeFile({      filePath,      data: buffer,      encoding: 'binary',      success() {        resolve(filePath);      },      fail() {        reject(new Error('ERROR_BASE64SRC_WRITE'));      },    });  });};module.exports = base64src;// index.js\r\nlet base64Data = xxx; // 服务器返回的base64数据base64src(base64Data).then((src) => {                wx.getImageInfo({                    src: src,                    success: function (r) {                        console.log(r.path); // 图片本地路径                    },                    fail: function (r) {                        console.log(r);                    }                });            });\r\n\r\n复制代码自定义组件 behavior有时候某些自定义组件会有大部分的相似功能，小部分差异，这时候可以使用behavior封装共同的属性和方法等，类似vue中的mixins。"}
{"title": "Golang：通过小程序获取微信 openid", "author": "Rolan", "time": "2020-3-24 00:13", "content": "为什么要获取小程序的 openid在开发微信小程序的过程中，小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。那么这个用户身份标识就是 openid。小程序获取 openid 的流程那么小程序获取 openid 的流程具体如下，这里我简化了一下，因为我们只需要获取到 openid 即可，具体可以参考 这里我们需要在小程序中调用 wx.login() 获取 code 码，然后将这个 code 码发送给后端，后端带着这个 code 码和 appid，appsecret 向微信接口发起 http 请求获取 openid。注意事项在开发的小程序中的 AppID 一定要和后端使用的 AppID 保持一致，否则会获取 openid 失败我们请求的微信 API 为 auth.code2Session ，请求地址为：GET https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code所需的四个参数为：属性类型默认值必填说明appidstring是小程序 appIdsecretstring是小程序 appSecretjs_codestring是登录时获取的 codegrant_typestring是授权类型，此处只需填写 authorization_codejs_code 就是我们通过 wx.login 得到的 code，grant_type 为 authorization_code，只剩下 appid 和 secret 需要我们登录 微信公总平台 里面找小程序代码演示为了方便操作，我们在 index 页面编写了一个 button，通过 button 触发事件<!--index.wxml-->\r\n<view class=\"container\">\r\n  <button bindtap=\"onGetOpenId\">点击获取openid</button>\r\n</view>然后编写事件函数：//index.js\r\nPage({\r\n  onGetOpenId() {\r\n    wx.login({\r\n      success: res => {\r\n        if (res.code) {\r\n          wx.request({\r\n            url: \"http://localhost:2020/openid\",\r\n            method: \"POST\",\r\n            data: {\r\n              code: res.code\r\n            },\r\n            success: res => {\r\n              console.log(res);\r\n            }\r\n          });\r\n        }\r\n      }\r\n    });\r\n  }\r\n});那么，在小程序中发送 http 请求强制要求地址必须为 https，由于我们在开发中，我们可以把强制 https 的设置关闭Go 语言后端代码演示小程序发过来的数据和去微信 API 获取的数据都是放在 http body 里，所以我们要从 body 获取package main\r\n\r\nimport (\r\n    \"encoding/json\"\r\n    \"fmt\"\r\n    \"net/http\"\r\n)\r\n\r\nfunc main() {\r\n    http.HandleFunc(\"/openid\", getOpenID)\r\n    http.ListenAndServe(\":2020\", nil)\r\n}\r\n\r\nfunc getOpenID(writer http.ResponseWriter, request *http.Request) {\r\n    if request.Method != http.MethodPost {\r\n        return\r\n    }\r\n\r\n    var codeMap map[string]string\r\n    err := json.NewDecoder(request.Body).Decode(&codeMap)\r\n    if err != nil {\r\n        return\r\n    }\r\n    defer request.Body.Close()\r\n\r\n    code := codeMap[\"code\"]\r\n    openid, err := sendWxAuthAPI(code)\r\n    if err != nil {\r\n        return\r\n    }\r\n    fmt.Println(\"my openid\", openid)\r\n}\r\n\r\nconst (\r\n    code2sessionURL = \"https://api.weixin.qq.com/sns/jscode2session?appid=%s&secret=%s&js_code=%s&grant_type=authorization_code\"\r\n    appID           = \"你的AppID\"\r\n    appSecret       = \"你的AppSecret\"\r\n)\r\n\r\nfunc sendWxAuthAPI(code string) (string, error) {\r\n    url := fmt.Sprintf(code2sessionURL, appID, appSecret, code)\r\n    resp, err := http.DefaultClient.Get(url)\r\n    if err != nil {\r\n        return \"\", err\r\n    }\r\n    var wxMap map[string]string\r\n    err = json.NewDecoder(resp.Body).Decode(&wxMap)\r\n    if err != nil {\r\n        return \"\", err\r\n    }\r\n    defer resp.Body.Close()\r\n\r\n    return wxMap[\"openid\"], nil\r\n}运行结果运行代码，在小程序中点击：结果："}
{"title": "记一次小程序样式优化重构", "author": "Rolan", "time": "2020-3-24 00:28", "content": "上周花了 3 天的时间和老大一起重构了一下小程序的样式开发，虽然说在开发的过程中遇到了一些问题，但是最终减少了不少样式代码，同时功能上也更加强大。进一步来说，如果在后面我们的小程序用户想要自己定制化主题，也可以很快的实现。全局样式开发之前的小程序开发中，我们全方面使用了\tComponent 构造小程序组件以及页面(页面也可以使用 Component 构造器来编写)。当然一方面是因为小程序 Component 的开发体验非常好，拥有类似于 Vue mixin, watch 的\tbehaviors 和\tobservers ，比 Page 构造器强大了很多。另一方面，对于业务较重的小程序来说, Component 也有性能优势。可以参照\t滴滴开源小程序框架Mpx 中的Page与Component setData性能对照 。在开发过程中，有很多样式是可以复用的。如果在之前开发中经常使用\tBootstrap 之类的 ui 库，那么你就会习惯使用这种库的\tutilities 类。但是默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。不会受到全局样式 app.wxss 的影响。所以我们只能通过增加\t@import 语法来辅助各个组件进行开发。@import \"xxx.css\";如果你使用 CSS 预处理器来辅助小程序开发的话，可能就需要通过\tgulp-insert 为编译出来的 wxss 文件前置添加该语句。请注意: 之所以\t@import 需要前置，是因为\t@import 语法会把引入的样式按照导入的位置来生效，也就是说，按照 CSS 同等权重看先后的规则来说，如果把\t@import 放在中间位置，前面位置定义的样式可能会被\t@import 给覆盖掉。小程序全局样式当然，小程序基础库版本在 2.2.3 以上就支持了addGlobalClass 配置项,即在 Component 的 options 中设置\taddGlobalClass: true 。Component({\r\n  options: {\r\n    addGlobalClass: true\r\n  }\r\n})该配置项目表示页面级别的 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面。也就是说我们可以用该配置替代之前的每个组件的 @import。只要在 app.wxss 上导入 CSS 样式即可，同时我们可以在页面上对组件内部的样式进行修改。不过需要说明的是: 该配置并不影响父子组件间的样式。各个子组件只受到 app.wxss 和页面的样式的侵入。小程序开发基本上以页面为单位，所以这个配置是非常适合开发的。不过在之前的开发中并没有在意过这个配置。组件样式隔离当然了，在后面的版本 2.6.5 中，微信小程序也提供了更为详细的隔离选项\tstyleIsolation 。Component({\r\n  options: {\r\n    styleIsolation: 'isolated'\r\n  }\r\n})isolated 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（一般情况下的默认值）。apply-shared 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面。shared 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了\tapply-shared 或\tshared 的自定义组件。（这个选项在插件中不可用）。styleIsolation 浅析如果大家不想了解太多，只想使用的话, 简短来说:大家在组件中直接使用\tapply-shared ，如果当前的 Component 构造器应用于页面，那么不要配置隔离选项即可。其余的隔离选项都是基本没什么用的。styleIsolation 详解isolated 等同于什么都不干，设置不设置一般没有区别，所以可以当该配置项目不存在。apply-shared 等同于\taddGlobalClass: true ，也是最有用的配置项 。shared 最复杂，在子组件设置了样式，不但会影响自身和页面（同时包括了其他设置了\tapply-shared 或\tshared 的自定义组件），同时呢，又会被页面样式和其他设置了\tshared 的组件样式影响。在我使用该功能的过程中，我认为，这个配置项千万不要在组件中去使用，除非你“疯了”。但是不介绍这个配置项目又不行，因为当你使用 Component 去构建页面时候，该页面的配置项目默认就是\tshared 。这是因为页面又需要全局样式，又需要影响其他设置了\tapply-shared 或shared 的自定义组件。不过可以放心的是: 小程序样式隔离是以页面为单位，不会影响全局样式，即使当前页面你有组件使用了以\tshared 影响了当前页面。跳转到下一个页面中，不会出现问题。所以我们基本上按照上面的设置即可。针对于页面级别的 Component 还有几个额外的样式隔离选项可用：page-isolated 表示在这个页面禁用 app.wxss ，同时，页面的 wxss 不会影响到其他自定义组件；page-apply-shared 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式不会影响到其他自定义组件，但设为\tshared 的自定义组件会影响到页面；page-shared 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式会影响到其他设为\tapply-shared 或\tshared 的自定义组件，也会受到设为\tshared 的自定义组件的影响。基本上这些配置都会让页面上禁用 app.wxss，所以在开发中并不使用。大家如果有需求，可以自行研究。从小程序基础库版本\t2.10.1 开始，也可以在页面或自定义组件的 json 文件中配置\tstyleIsolation （这样就不需在 js 文件的\toptions 中再配置）。例如：{\r\n  \"styleIsolation\": \"isolated\"\r\n}其他样式配置功能诸如) 和引用页面或父组件的样式) 这些功能,大家也可酌情学习使用。不过有了组件样式隔离之后,这些功能可能就有些鸡肋，我可以直接通过页面的样式控制组件内部的样式。而且外部样式类功能需要父组件直接提供样式，不会被 app.wxss 所影响。在样式隔离功能使用的情况下，我们可以大幅度减少各个组件的代码。并且让整个小程序内部更加干净整洁，可重用性更高。同时我们的主题色等全局配置都可以通过修改 app.wxss 来修改。CSS var 定制主题var 功能简单描述如果当年 CSS 预处理器变量对于我来说是开启了新世界的大门，那么 CSS 变量这个功能对于无疑就是晴天霹雳。// 在 body 选择器中声明了两个变量\r\nbody {\r\n  --primary-color: #7F583F;\r\n  --secondary-color: #F7EFD2;\r\n}\r\n\r\n/** 同一个 CSS 变量，可以在多个选择器内声明。优先级高的会替换优先级低的 */\r\n.a {\r\n  --primary-color: #FFF;\r\n  --secondary-color: #F4F4F4;\r\n}\r\n\r\n/** 使用 CSS 变量 */\r\n.btn-primary {\r\n  color: var(--primary-color)\r\n}在前端的领域中，标准的实现总是比社区的约定要慢的多，前端框架最喜欢的 $ 被 Sass 变量用掉了。而最常用的 @ 也被 Less 用掉了。官方为了让 CSS 变量也能够在 Sass 及 Less 中使用，无奈只能妥协的使用 --。当然，我们也可以通过 JS 来操作 CSS 变量。如此，CSS 变量可以动态的修改。// 设置变量\r\ndocument.body.style.setProperty('--primary', '#7F583F');\r\n\r\n// 读取变量\r\ndocument.body.style.getPropertyValue('--primary').trim();\r\n// '#7F583F'\r\n\r\n// 删除变量\r\ndocument.body.style.removeProperty('--primary');var 默认配置事实上，var() 函数还可以使用第二个参数，表示变量的默认值。如果该变量此前没有定义，就会使用这个默认值。如果让我来思考，我肯定无法想象出结合 Less 和 CSS 变量便可以实现小程序样式的默认配置。这里我们参考了有赞的\tVant Weapp 的做法。有赞代码\ttheme.less 如下所示:// 先导入所有 less 变量\r\n@import (reference) './var.less';\r\n\r\n// 利用正则去替换变量\r\n.theme(@property, @imp) {\r\n  @{property}: e(replace(@imp, '@([^() ]+)', '@{$1}', 'ig'));\r\n  @{property}: e(replace(@imp, '@([^() ]+)', 'var(--$1, @{$1})', 'ig'));\r\n}函数效果如下所示:@import '../common/style/theme.less';\r\n\r\n.van-button {\r\n  // ... 其他省略\r\n  .theme(height, '@button-default-height');\r\n  .theme(line-height, '@button-line-height');\r\n  .theme(font-size, '@button-default-font-size');\r\n}\r\n\r\n// => 编译之后\r\n\r\n.van-button{\r\n   // ... 其他省略\r\n  height:44px;\r\n  height:var(--button-default-height,44px);\r\n  line-height:20px;\r\n  line-height:var(--button-line-height,20px);\r\n  font-size:16px;\r\n  font-size:var(--button-default-font-size,16px);\r\n}我们可以看到每调用一次 Less 函数将会被编译成两个属性。第一个属性的设定对于不支持 CSS 变量的设备可以直接使用，如果当前设备支持 CSS 变量，则会使用 CSS 变量，但是由于当前 css 变量未定义，就会使用变量的默认值。经过这种函数的修改，我们就可以完成定制主题。详细请参考\tVant Weapp 定制主题 。// component.wxml\r\n<van-button class=\"my-button\">\r\n  默认按钮\r\n</van-button>\r\n\r\n// component.wxss\r\n\r\n.my-button {\r\n  --button-border-radius: 10px;\r\n  --button-default-color: #f2f3f5;\r\n}大家可能有时候会想，这样的话，不是有更多的代码了吗？其实未必，事实上我们可以直接直接在页面内部定义变量样式。其他组件直接通过样式隔离去使用页面内的变量。当然了，事实上书写的代码多少，重点在于想要控制默认样式的粒度大小。粒度越小，则需要在各个组件内部书写的变量越多，粒度大，我们也就不必考虑太多。当然了，我们可以基于用户机型提供默认和适合当前机型修改的的样式配置，这样的话。即使用户想要自己定义，也不会出现样式特别怪异的状况。参考资料小程序 组件模板和样式CSS 变量教程Vant Weapp 样式覆盖鼓励一下如果你觉得这篇文章不错，希望可以给与我一些鼓励，在我的 github 博客下帮忙 star 一下。博客地址"}
{"title": "京喜小程序的高性能打造之路", "author": "Rolan", "time": "2020-3-27 00:26", "content": "本文阅读时长约15分钟。京喜小程序开发团队核心成员倾力之作，都是干货，读完一定会收获满满，请大家耐心阅读～背景京喜小程序自去年双十一上线微信购物一级入口后，时刻迎接着亿级用户量的挑战，细微的体验细节都有可能被无限放大，为此，“极致的页面性能”、“友好的产品体验” 和 “稳定的系统服务” 成为了我们开发团队的最基本执行原则。首页作为小程序的门户，其性能表现和用户留存率息息相关。因此，我们对京喜首页进行了一次全方位的升级改造，从加载、渲染和感知体验几大维度深挖小程序的性能可塑性。除此之外，京喜首页在微信小程序、H5、APP 三端都有落地场景，为了提高研发效率，我们使用了 Taro 框架实现多端统一，因此下文中有部分内容是和 Taro 框架息息相关的。怎么定义高性能？提起互联网应用性能这个词，很多人在脑海中的词法解析就是，“是否足够快？”，似乎加载速度成为衡量系统性能的唯一指标。但这其实是不够准确的，试想一下，如果一个小程序加载速度非常快，用户花费很短时间就能看到页面的主体内容，但此时搜索框却无法输入内容，功能无法被流畅使用，用户可能就不会关心页面渲染有多快了。所以，我们不应该单纯考虑速度指标而忽略用户的感知体验，而应该全方位衡量用户在使用过程中能感知到的与应用加载相关的每个节点。谷歌为 Web 应用定义了以用户为中心的性能指标体系，每个指标都与用户体验节点息息相关：其中，“是否有用？” 这个问题是非常主观的，对于不同场景的系统可能会有完全不一样的回答，所以 FMP 是一个比较模糊的概念指标，不存在规范化的数值衡量。小程序作为一个新的内容载体，衡量指标跟 Web 应用是非常类似的。对于大多数小程序而言，上述指标对应的含义为：FCP：白屏加载结束；FMP：首屏渲染完成；TTI：所有内容加载完成；综上，我们已基本确定了高性能的概念指标，接下来就是如何利用数值指标来描绘性能表现。小程序官方性能指标小程序官方针对小程序性能表现制订了权威的数值指标，主要围绕 渲染表现 、 setData 数据量 、 元素节点数 和 网络请求延时 这几个维度来给予定义（下面只列出部分关键指标）：首屏时间不超过 5 秒；渲染时间不超过 500ms；每秒调用 setData 的次数不超过 20 次；setData 的数据在 JSON.stringify 后不超过 256kb；页面 WXML 节点少于 1000 个，节点树深度少于 30 层，子节点数不大于 60 个；所有网络请求都在 1 秒内返回结果；详见 小程序性能评分规则我们应该把这一系列的官方指标作为小程序的性能及格线，不断地打磨和提升小程序的整体体验，降低用户流失率。另外，这些指标会直接作为小程序体验评分工具的性能评分规则（体验评分工具会根据这些规则的权重和求和公式计算出体验得分）。我们团队内部在官方性能指标的基础上，进一步浓缩优化指标系数，旨在对产品体验更高要求：setData\r\n体验评分工具小程序提供了 体验评分工具（ Audits 面板） 来测量上述的指标数据，其集成在开发者工具中，在小程序运行时实时检查相关问题点，并为开发者给出优化建议。以上截图均来自小程序官方文档体验评分工具是目前检测小程序性能问题最直接有效的途径，我们团队已经把体验评分作为页面/组件是否能达到精品门槛的重要考量手段之一。小程序后台性能分析我们知道，体验评分工具是在本地运行小程序代码时进行分析，但性能数据往往需要在真实环境和大数据量下才更有说服力。恰巧， 小程序管理平台 和 小程序助手 为开发者提供了大量的真实数据统计。其中，性能分析面板从 启动性能 、 运行性能 和 网络性能 这三个维度分析数据，开发者可以根据客户端系统、机型、网络环境和访问来源等条件做精细化分析，非常具有考量价值。其中，启动总耗时 = 小程序环境初始化 + 代码包加载 + 代码执行 + 渲染耗时第三方测速系统很多时候，宏观的耗时统计对于性能瓶颈点分析往往是杯水车薪，作用甚少，我们需要更细致地针对某个页面某些关键节点作测速统计，排查出暴露性能问题的代码区块，才能更有效地针对性优化。京喜小程序使用的是内部自研的测速系统，支持对地区、运营商、网络、客户端系统等多条件筛选，同时也支持数据可视化、同比分析数据等能力。京喜首页主要围绕 页面 onLoad 、 onReady 、 数据加载完成 、 首屏渲染完成 、 各业务组件首次渲染完成 等几个关键节点统计测速上报，旨在全链路监控性能表现。另外，微信为开发者提供了 测速系统 ，也支持针对客户端系统、网络类型、用户地区等维度统计数据，有兴趣的可以尝试。了解小程序底层架构为了更好地为小程序制订性能优化措施，我们有必要先了解小程序的底层架构，以及与 web 浏览器的差异性。微信小程序是大前端跨平台技术的其中一种产物，与当下其他热门的技术 React Native、Weex、Flutter 等不同，小程序的最终渲染载体依然是浏览器内核，而不是原生客户端。而对于传统的网页来说，UI 渲染和 JS 脚本是在同一个线程中执行，所以经常会出现 “阻塞” 行为。微信小程序基于性能的考虑，启用了 双线程模型 ：视图层 ：也就是 webview 线程，负责启用不同的 webview 来渲染不同的小程序页面；逻辑层 ：一个单独的线程执行 JS 代码，可以控制视图层的逻辑；上图来自小程序官方开发指南然而， 任何线程间的数据传输都是有延时的 ，这意味着逻辑层和视图层间通信是异步行为。除此之外，微信为小程序提供了很多客户端原生能力，在调用客户端原生能力的过程中，微信主线程和小程序双线程之间也会发生通信，这也是一种异步行为。这种异步延时的特性会使运行环境复杂化，稍不注意，就会产出效率低下的编码。作为小程序开发者，我们常常会被下面几个问题所困扰：小程序启动慢；白屏时间长；页面渲染慢；运行内存不足；接下来，我们会结合小程序的底层架构分析出这些问题的根本原因，并针对性地给出解决方案。小程序启动太慢？小程序启动阶段，也就是如下图所示的展示加载界面的阶段。在这个阶段中（包括启动前后的时机），微信会默默完成下面几项工作：1. 准备运行环境：在小程序启动前，微信会先启动双线程环境，并在线程中完成小程序基础库的初始化和预执行。小程序基础库包括 WebView 基础库和 AppService 基础库，前者注入到视图层中，后者注入到逻辑层中，分别为所在层级提供其运行所需的基础框架能力。2. 下载小程序代码包：在小程序初次启动时，需要下载编译后的代码包到本地。如果启动了小程序分包，则只有主包的内容会被下载。另外，代码包会保留在缓存中，后续启动会优先读取缓存。3. 加载小程序代码包：小程序代码包下载好之后，会被加载到适当的线程中执行，基础库会完成所有页面的注册。在页面注册过程中，基础库会调用页面 JS 文件的 Page 构造器方法，来记录页面的基础信息（包括初始数据、方法等）。4. 初始化小程序首页：在小程序代码包加载完之后，基础库会根据启动路径找到首页，根据首页的基础信息初始化一个页面实例，并把信息传递给视图层，视图层会结合 WXML 结构、WXSS 样式和初始数据来渲染界面。综合考虑，为了节省小程序的“点点点”时间（小程序的启动动画是三个圆点循环跑马灯），除了给每位用户发一台高配 5G 手机并顺带提供千兆宽带网络之外，还可以尽量 控制代码包大小 ，缩小代码包的下载时间。无用文件、函数、样式剔除经过多次业务迭代，无可避免的会存在一些弃用的组件/页面，以及不被调用的函数、样式规则，这些冗余代码会白白占据宝贵的代码包空间。而且，目前小程序的打包会将工程下所有文件都打入代码包内，并没有做依赖分析。因此，我们需要及时地剔除不再使用的模块，以保证代码包空间利用率保持在较高水平。通过一些工具化手段可以有效地辅助完成这一工作。文件依赖分析在小程序中，所有页面的路径都需要在小程序代码根目录 app.json 中被声明，类似地，自定义组件也需要在页面配置文件 page.json 中被声明。另外，WXML、WXSS 和 JS 的模块化都需要特定的关键字来声明依赖引用关系。WXML 中的 import 和 include ：<!-- A.wxml -->\r\n<template name='A'>\r\n  <text>{{text}}</text>\r\n</template>\r\n\r\n<!-- B.wxml -->\r\n<import src=\"A.wxml\"/>\r\n<template is=\"A\" data=\"{{text: 'B'}}\"/><!-- A.wxml -->\r\n<text> A </text>\r\n\r\n<!-- B.wxml -->\r\n<include src=\"A.wxml\"/>\r\n<text> B </text>WXSS 中的 @import ：@import './A.wxss'JS 中的 require / import ：const A = require('./A')所以，可以说小程序里的所有依赖模块都是有迹可循的，我们只需要利用这些关键字信息递归查找，遍历出文件依赖树，然后把没用的模块剔除掉。JS、CSS Tree-ShakingJS Tree-Shaking 的原理就是借助 Babel 把代码编译成抽象语法树（AST），通过 AST 获取到函数的调用关系，从而把未被调用的函数方法剔除掉。不过这需要依赖 ES module，而小程序最开始是遵循 CommonJS 规范的，这意味着是时候来一波“痛并快乐着”的改造了。而 CSS 的 Tree-Shaking 可以利用 PurifyCSS 插件来完成。关于这两项技术，有兴趣的可以“谷歌一下”，这里就不铺开细讲了。题外，京东的小程序团队已经把这一系列工程化能力集成在一套 CLI 工具中，有兴趣的可以看看这篇分享： 小程序工程化探索 。减少代码包中的静态资源文件小程序代码包最终会经过 GZIP 压缩放在 CDN 上，但 GZIP 压缩对于图片资源来说效果非常低。如 JPG 、 PNG 等格式文件，本身已经被压缩过了，再使用 GZIP 压缩有可能体积更大，得不偿失。所以，除了部分用于容错的图片必须放在代码包（譬如网络异常提示）之外，建议开发者把图片、视频等静态资源都放在 CDN 上。需要注意， Base64 格式本质上是长字符串，和 CDN 地址比起来也会更占空间。逻辑后移，精简业务逻辑这是一个 “痛并快乐着” 的优化措施。“痛” 是因为需要给后台同学提改造需求，分分钟被打；“快乐” 则是因为享受删代码的过程，而且万一出 Bug 也不用背锅了...（开个玩笑）通过让后台承担更多的业务逻辑，可以节省小程序前端代码量，同时线上问题还支持紧急修复，不需要经历小程序的提审、发布上线等繁琐过程。总结得出， 一般不涉及前端计算的展示类逻辑，都可以适当做后移 。譬如京喜首页中的幕帘弹窗（如下图）逻辑，这里共有 10+ 种弹窗类型，以前的做法是前端从接口拉取 10+ 个不同字段，根据优先级和 “是否已展示”（该状态存储在本地缓存） 来决定展示哪一种，最后代码大概是这样的：// 检查每种弹窗类型是否已展示\r\nPromise.all([\r\n  check(popup_1),\r\n  check(popup_2),\r\n  // ...\r\n  check(popup_n)\r\n]).then(result => {\r\n  // 优先级排序\r\n  const queue = [{\r\n    show: result.popup_1\r\n    data: data.popup_1\r\n  }, {\r\n    show: result.popup_2\r\n    data: data.popup_2\r\n  }, \r\n  // ...\r\n  {\r\n    show: result.popup_n\r\n    data: data.popup_n\r\n  }]\r\n})逻辑后移之后，前端只需负责拿幕帘字段做展示就可以了，代码变成这样：this.setData({\r\n  popup: data.popup\r\n})复用模板插件京喜首页作为电商系统的门户，需要应对各类频繁的营销活动、升级改版等，同时也要满足不同用户属性的界面个性化需求（俗称 “千人千面”）。如何既能减少为应对多样化场景而产生的代码量，又可以提升研发效率，成为燃眉之急。类似于组件复用的理念，我们需要提供更丰富的可配置能力，实现更高的代码复用度。参考小时候很喜欢玩的 “乐高” 积木玩具， 我们把首页模块的模板元素作颗粒度更细的划分，根据样式和功能抽象出一块块“积木”原料（称为插件元素） 。当首页模块在处理接口数据时，会启动插件引擎逐个装载插件，最终输出个性化的模板样式，整个流程就好比堆积木。当后续产品/运营需要新增模板时，只要在插件库中挑选插件排列组合即可，不需要额外新增/修改组件内容，也更不会产生难以维护的 if / else 逻辑，so easy～当然，要完成这样的插件化改造免不了几个先决条件：用户体验设计的统一 。如果设计风格总是天差地别的，强行插件化只会成为累赘。服务端接口的统一 。同上，如果得浪费大量的精力来兼容不同模块间的接口字段差异，将会非常蛋疼。下面为大家提供部分例程来辅助理解。其中， use 方法会接受各类处理钩子最终拼接出一个 Function ，在对应模块处理数据时会被调用。// bi.helper.js\r\n\r\n/**\r\n * 插件引擎\r\n * @param {function} options.formatName 标题处理钩子\r\n * @param {function} options.validList 数据校验器钩子\r\n */ \r\nconst use = options => data => format(data)\r\n\r\n/**\r\n * 预置插件库\r\n */ \r\nnameHelpers = {\r\n  text: data => data.text,\r\n  icon: data => data.icon\r\n}\r\nlistHelpers = {\r\n  single: list => list.slice(0, 1),\r\n  double: list => list.slice(0, 2)\r\n}\r\n\r\n/**\r\n * “堆积木”\r\n */\r\nexport default {\r\n  1000: use({\r\n    formatName: nameHelpers.text,\r\n    validList: listHelpers.single\r\n  }),\r\n\r\n  1001: use({\r\n    formatName: nameHelpers.icon,\r\n    validList: listHelpers.double\r\n  })\r\n}<!-- bi.wxml -->\r\n<!-- 各模板节点实现 -->\r\n<template name=\"renderName\">\r\n  <view wx:if=\"{{type === 'text'}}\"> text </view>\r\n  <view wx:elif=\"{{type === 'icon'}}\"> icon </view>\r\n</template>\r\n\r\n<view class=\"bi__name\">\r\n  <template is=\"renderName\" data=\"{{...data.name}\"/>\r\n</view>// bi.js\r\nComponent({\r\n  ready() {\r\n    // 根据 tpl 值选择解析函数\r\n    const formatData = helper[data.tpl]\r\n    this.setData({\r\n      data: formatData(data)\r\n    })\r\n  }\r\n})分包加载小程序启动时只会下载主包/独立分包，启用分包可以有效减少下载时间。（独立）分包需要遵循一些原则，详细的可以看官方文档：使用分包独立分包部分页面 h5 化小程序提供了 web-view 组件，支持在小程序环境内访问网页。当实在无法在小程序代码包中腾出多余空间时，可以考虑降级方案 —— 把部分页面 h5 化。小程序和 h5 的通信可以通过 JSSDK 或 postMessage 通道来实现，详见 小程序开发文档 。白屏时间过长？白屏阶段，是指小程序代码包下载完（也就是启动界面结束）之后，页面完成首屏渲染的这一阶段，也就是 FMP (首次有效绘制)。FMP 没法用标准化的指标定义，但对于大部分小程序来说，页面首屏展示的内容都需要依赖服务端的接口数据，那么影响白屏加载时间的主要由这两个元素构成：网络资源加载时间 ；渲染时间 ；启用本地缓存小程序提供了读写本地缓存的接口，数据存储在设备硬盘上。由于本地 I/O 读写（毫秒级）会比网络请求（秒级）要快很多，所以在用户访问页面时，可以优先从缓存中取上一次接口调用成功的数据来渲染视图，待网络请求成功后再覆盖最新数据重新渲染。除此之外，缓存数据还可以作为兜底数据，避免出现接口请求失败时页面空窗，一石二鸟。但并非所有场景都适合缓存策略，譬如对数据即时性要求非常高的场景（如抢购入口）来说，展示老数据可能会引发一些问题。小程序默认会按照 不同小程序 、 不同微信用户 这两个维度对缓存空间进行隔离。诸如京喜小程序首页也采用了缓存策略，会进一步按照 数据版本号 、 用户属性 来对缓存进行再隔离，避免信息误展示。数据预拉取小程序官方为开发者提供了一个在小程序冷启动时提前拉取第三方接口的能力： 数据预拉取 。关于冷启动和热启动的定义可以看 这里数据预拉取的原理其实很简单，就是在小程序启动时，微信服务器代理小程序客户端发起一个 HTTP 请求到第三方服务器来获取数据，并且把响应数据存储在本地客户端供小程序前端调取。当小程序加载完成后，只需调用微信提供的 API wx.getBackgroundFetchData 从本地缓存获取数据即可。这种做法可以充分利用小程序启动和初始化阶段的等待时间，使更快地完成页面渲染。京喜小程序首页已经在生产环境实践过这个能力，从每日千万级的数据分析得出，预拉取使冷启动时获取到接口数据的时间节点从 2.5s 加速到 1s（提速了 60%）。虽然提升效果非常明显，但这个能力依然存在一些不成熟的地方：预拉取的数据会被强缓存；由于预拉取的请求最终是由微信的服务器发起的，也许是出于服务器资源限制的考虑，预拉取的数据会缓存在微信本地一段时间，缓存失效后才会重新发起请求。经过真机实测，在微信购物入口冷启动京喜小程序的场景下，预拉取缓存存活了 30 分钟以上，这对于数据实时性要求比较高的系统来说是非常致命的。请求体和响应体都无法被拦截；由于请求第三方服务器是从微信的服务器发起的，而不是从小程序客户端发起的，所以本地代理无法拦截到这一次真实请求，这会导致开发者无法通过拦截请求的方式来区分获取线上环境和开发环境的数据，给开发调试带来麻烦。小程序内部接口的响应体类型都是 application/octet-stream ，即数据格式未知，使本地代理无法正确解析。微信服务器发起的请求没有提供区分线上版和开发版的参数，且没有提供用户 IP 等信息 ；如果这几个问题点都不会影响到你的场景，那么可以尝试开启预拉取能力，这对于小程序首屏渲染速度是质的提升。跳转时预拉取为了尽快获取到服务端数据，比较常见的做法是在页面 onLoad 钩子被触发时发起网络请求，但其实这并不是最快的方式。从发起页面跳转，到下一个页面 onLoad 的过程中，小程序需要完成一些环境初始化及页面实例化的工作，耗时大概为 300 ~ 400 毫秒。实际上，我们可以在发起跳转前（如 wx.navigateTo 调用前），提前请求下一个页面的主接口并存储在全局 Promise 对象中，待下个页面加载完成后从 Promise 对象中读取数据即可。这也是双线程模型所带来的优势之一，不同于多页面 web 应用在页面跳转/刷新时就销毁掉 window 对象。分包预下载如果开启了分包加载能力，在用户访问到分包内某个页面时，小程序才会开始下载对应的分包。当处于分包下载阶段时，页面会维持在 “白屏” 的启动态，这用户体验是比较糟糕的。幸好，小程序提供了 分包预下载 能力，开发者可以配置进入某个页面时预下载可能会用到的分包，避免在页面切换时僵持在 “白屏” 态。非关键渲染数据延迟请求这是关键渲染路径优化的其中一个思路，从缩短网络请求时延的角度加快首屏渲染完成时间。关键渲染路径（Critical Rendering Path） 是指在完成首屏渲染的过程中必须发生的事件。以京喜小程序如此庞大的小程序项目为例，每个模块背后都可能有着海量的后台服务作支撑，而这些后台服务间的通信和数据交互都会存在一定的时延。我们根据京喜首页的页面结构，把所有模块划分成两类： 主体模块 （导航、商品轮播、商品豆腐块等）和 非主体模块 （幕帘弹窗、右侧挂件等）。在初始化首页时，小程序会发起一个聚合接口请求来获取主体模块的数据，而非主体模块的数据则从另一个接口获取，通过拆分的手段来降低主接口的调用时延，同时减少响应体的数据量，缩减网络传输时间。分屏渲染这也是关键渲染路径优化思路之一，通过延迟非关键元素的渲染时机，为关键渲染路径腾出资源。类似上一条措施，继续以京喜小程序首页为例，我们在 主体模块 的基础上再度划分出 首屏模块 （商品豆腐块以上部分） 和 非首屏模块 （商品豆腐块及以下部分）。当小程序获取到主体模块的数据后，会优先渲染首屏模块，在所有首屏模块都渲染完成后才会渲染非首屏模块和非主体模块，以此确保首屏内容以最快速度呈现。为了更好地呈现效果，上面 gif 做了降速处理接口聚合，请求合并在小程序中，发起网络请求是通过 wx.request 这个 API。我们知道，在 web 浏览器中，针对同一域名的 HTTP 并发请求数是有限制的；在小程序中也有类似的限制，但区别在于不是针对域名限制，而是针对 API 调用：wx.request\r\nwx.connectSocket\r\n超出并发限制数目的 HTTP 请求将会被阻塞，需要在队列中等待前面的请求完成，从而一定程度上增加了请求时延。因此， 对于职责类似的网络请求，最好采用节流的方式，先在一定时间间隔内收集数据，再合并到一个请求体中发送给服务端。图片资源优化图片资源一直是移动端系统中抢占大流量的部分，尤其是对于电商系统。优化图片资源的加载可以有效地加快页面响应时间，提升首屏渲染速度。使用 WebP 格式WebP 是 Google 推出的一种支持有损/无损压缩的图片文件格式，得益于更优的图像数据压缩算法，其与 JPG、PNG 等格式相比，在肉眼无差别的图片质量前提下具有更小的图片体积（据官方说明，WebP 无损压缩体积比 PNG 小 26%，有损压缩体积比 JPEG 小 25-34%）。小程序的 image 组件 支持 JPG、PNG、SVG、WEBP、GIF 等格式。图片裁剪&降质鉴于移动端设备的分辨率是有上限的，很多图片的尺寸常常远大于页面元素尺寸，这非常浪费网络资源（一般图片尺寸 2 倍于页面元素真实尺寸比较合适）。得益于京东内部强大的图片处理服务，我们可以通过资源的命名规则和请求参数来获取服务端优化后的图片：裁剪成 100x100 的图片： https://{host}/s100x100_jfs/{file_path} ；降质 70%： https://{href}!q70 ；图片懒加载、雪碧图（CSS Sprite）优化这两者都是比较老生常谈的图片优化技术，这里就不打算细讲了。小程序的 image 组件 自带 lazy-load 懒加载支持。雪碧图技术（CSS Sprite）可以参考 w3schools 的教程。降级加载大图资源在不得不使用大图资源的场景下，我们可以适当使用 “体验换速度” 的措施来提升渲染性能。小程序会把已加载的静态资源缓存在本地，当短时间内再次发起请求时会直接从缓存中取资源（与浏览器行为一致）。因此，对于大图资源， 我们可以先呈现高度压缩的模糊图片，同时利用一个隐藏的 <image> 节点来加载原图，待原图加载完成后再转移到真实节点上渲染 。整个流程，从视觉上会感知到图片从模糊到高清的过程，但与对首屏渲染的提升效果相比，这点体验落差是可以接受的。下面为大家提供部分例程：<!-- banner.wxml -->\r\n<image src=\"{{url}}\" />\r\n\r\n<!-- 图片加载器 -->\r\n<image\r\n  style=\"width:0;height:0;display:none\"\r\n  src=\"{{preloadUrl}}\"\r\n  bindload=\"onImgLoad\"\r\n  binderror=\"onErrorLoad\"\r\n/>// banner.js\r\nComponent({\r\n  ready() {\r\n    this.originUrl = 'https://path/to/picture'  // 图片源地址\r\n    this.setData({\r\n      url: compress(this.originUrl)             // 加载压缩降质的图片\r\n      preloadUrl: this.originUrl                // 预加载原图\r\n    })\r\n  },\r\n  methods: {\r\n    onImgLoad() {\r\n      this.setData({\r\n        url: this.originUrl                       // 加载原图\r\n      })\r\n    }\r\n  }\r\n})注意，具有 display: none 样式的 <image> 标签只会加载图片资源，但不渲染。京喜首页的商品轮播模块也采用了这种降级加载方案，在首屏渲染时只会加载第一帧降质图片。以每帧原图 20~50kb 的大小计算，这一措施可以在初始化阶段节省掉几百 kb 的网络资源请求。为了更好地呈现效果，上面 gif 做了降速处理骨架屏一方面，我们可以从降低网络请求时延、减少关键渲染的节点数这两个角度出发，缩短完成 FMP（首次有效绘制）的时间。另一方面，我们也需要从用户感知的角度优化加载体验。“白屏” 的加载体验对于首次访问的用户来说是难以接受的，我们可以使用尺寸稳定的骨架屏，来辅助实现真实模块占位和瞬间加载。骨架屏目前在业界被广泛应用，京喜首页选择使用灰色豆腐块作为骨架屏的主元素，大致勾勒出各模块主体内容的样式布局。由于微信小程序不支持 SSR（服务端渲染），使动态渲染骨架屏的方案难以实现，因此京喜首页的骨架屏是通过 WXSS 样式静态渲染的。有趣的是，京喜首页的骨架屏方案经历了 “统一管理” 和 “（组件）独立管理” 两个阶段。出于避免对组件的侵入性考虑，最初的骨架屏是由一个完整的骨架屏组件统一管理的：<!-- index.wxml -->\r\n<skeleton wx:if=\"{{isLoading}}\"></skeleton>\r\n<block wx:else>\r\n  页面主体\r\n</block>但这种做法的维护成本比较高，每次页面主体模块更新迭代，都需要在骨架屏组件中的对应节点同步更新（譬如某个模块的尺寸被调整）。除此之外，感官上从骨架屏到真实模块的切换是跳跃式的，这是因为骨架屏组件和页面主体节点之间的关系是整体条件互斥的，只有当页面主体数据 Ready（或渲染完毕）时才会把骨架屏组件销毁，渲染（或展示）主体内容。为了使用户感知体验更加丝滑，我们把骨架屏元素拆分放到各个业务组件中，骨架屏元素的显示/隐藏逻辑由业务组件内部独立管理，这就可以轻松实现 “谁跑得快，谁先出来” 的并行加载效果。除此之外，骨架屏元素与业务组件共用一套 WXML 节点，且相关样式由公共的 sass 模块集中管理，业务组件只需要在适当的节点挂上 skeleton 和 skeleton__block 样式块即可，极大地降低了维护成本。<!-- banner.wxml -->\r\n<view class=\"{{isLoading ? 'banner--skeleton' : ''}}\">\r\n  <view class=\"banner_wrapper\"></view>\r\n</view>// banner.scss\r\n.banner--skeleton {\r\n  @include skeleton;\r\n  .banner_wrapper {\r\n    @include skeleton__block;\r\n  }\r\n}上面的 gif 在压缩过程有些小问题，大家可以直接访问【京喜】小程序体验骨架屏效果。如何提升渲染性能？当调用 wx.navigateTo 打开一个新的小程序页面时，小程序框架会完成这几步工作：1. 准备新的 webview 线程环境，包括基础库的初始化；2. 从逻辑层到视图层的初始数据通信；3. 视图层根据逻辑层的数据，结合 WXML 片段构建出节点树（包括节点属性、事件绑定等信息），最终与 WXSS 结合完成页面渲染；由于微信会提前开始准备 webview 线程环境，所以小程序的渲染损耗主要在后两者 数据通信和 节点树创建/更新 的流程中。相对应的，比较有效的渲染性能优化方向就是：降低线程间通信频次；减少线程间通信的数据量；减少 WXML 节点数量；合并 setData 调用尽可能地把多次 setData 调用合并成一次。我们除了要从编码规范上践行这个原则，还可以通过一些技术手段降低 setData 的调用频次。譬如，把同一个时间片（ 事件循环 ）内的 setData 调用合并在一起，Taro 框架就使用了这个优化手段。在 Taro 框架下，调用 setState 时提供的对象会被加入到一个数组中，当下一次事件循环执行的时候再把这些对象合并一起，通过 setData 传递给原生小程序。// 小程序里的时间片 API\r\nconst nextTick = wx.nextTick ? wx.nextTick : setTimeout;只把与界面渲染相关的数据放在 data 中不难得出， setData 传输的数据量越多，线程间通信的耗时越长，渲染速度就越慢。根据微信官方测得的数据，传输时间和数据量大体上呈正相关关系：上图来自小程序官方开发指南所以，与视图层渲染无关的数据尽量不要放在 data 中，可以放在页面（组件）类的其他字段下。应用层的数据 diff每当调用 setData 更新数据时，会引起视图层的重新渲染，小程序会结合新的 data 数据和 WXML 片段构建出新的节点树，并与当前节点树进行比较得出最终需要更新的节点（属性）。即使小程序在底层框架层面已经对节点树更新进行了 diff，但我们依旧可以优化这次 diff 的性能。譬如，在调用 setData 时，提前确保传递的所有新数据都是有变化的，也就是针对 data 提前做一次 diff。Taro 框架内部做了这一层优化。在每次调用原生小程序的 setData 之前，Taro 会把最新的 state 和当前页面实例的 data 做一次 diff，筛选出有必要更新的数据再执行 setData 。附 Taro 框架的 数据 diff 规则去掉不必要的事件绑定当用户事件（如 Click 、 Touch 事件等）被触发时，视图层会把事件信息反馈给逻辑层，这也是一个线程间通信的过程。但，如果没有在逻辑层中绑定事件的回调函数，通信将不会被触发。所以，尽量减少不必要的事件绑定，尤其是像 onPageScroll 这种会被频繁触发的用户事件，会使通信过程频繁发生。去掉不必要的节点属性组件节点支持附加自定义数据 dataset （见下面例子），当用户事件被触发时，视图层会把事件 target 和 dataset 数据传输给逻辑层。那么，当自定义数据量越大，事件通信的耗时就会越长，所以应该避免在自定义数据中设置太多数据。<!-- wxml -->\r\n<view\r\n  data-a='A'\r\n  data-b='B'\r\n  bindtap='bindViewTap'\r\n>\r\n  Click Me!\r\n</view>// js\r\nPage({\r\n  bindViewTap(e) {\r\n    console.log(e.currentTarget.dataset)\r\n  }\r\n})适当的组件颗粒度小程序的组件模型与 Web Components 标准中的 ShadowDOM 非常类似，每个组件都有独立的节点树，拥有各自独立的逻辑空间（包括独立的数据、 setData 调用、 createSelectorQuery执行域等）。不难得出，如果自定义组件的颗粒度太粗，组件逻辑过重，会影响节点树构建和新/旧节点树 diff 的效率，从而影响到组件内 setData 的性能。另外，如果组件内使用了 createSelectorQuery来查找节点，过于庞大的节点树结构也会影响查找效率。我们来看一个场景，京喜首页的 “京东秒杀” 模块涉及到一个倒计时特性，是通过 setInterval每秒调用 setData 来更新表盘时间。我们通过把倒计时抽离出一个基础组件，可以有效降低频繁 setData 时的性能影响。适当的组件化，既可以减小数据更新时的影响范围，又能支持复用，何乐而不为？诚然，并非组件颗粒度越细越好，组件数量和小程序代码包大小是正相关的。尤其是对于使用编译型框架（如 Taro）的项目，每个组件编译后都会产生额外的运行时代码和环境 polyfill，so，为了代码包空间，请保持理智...事件总线，替代组件间数据绑定的通信方式WXML 数据绑定是小程序中父组件向子组件传递动态数据的较为常见的方式，如下面例程所示： Component A 组件中的变量 a 、 b 通过组件属性传递给 Component B 组件。在此过程中，不可避免地需要经历一次 Component A 组件的 setData 调用方可完成任务，这就会产生线程间的通信。“合情合理”，但，如果传递给子组件的数据只有一部分是与视图渲染有关呢？<!-- Component A -->\r\n<component-b prop-a=\"{{a}}\" prop-b=\"{{b}}\" />// Component B\r\nComponent({\r\n  properties: {\r\n    propA: String,\r\n    propB: String,\r\n  },\r\n  methods: {\r\n    onLoad: function() {\r\n      this.data.propA\r\n      this.data.propB\r\n    }\r\n  }\r\n})推荐一种特定场景下非常便捷的做法：通过事件总线（EventBus），也就是发布/订阅模式，来完成由父向子的数据传递。其构成非常简单（例程只提供关键代码...）：一个全局的事件调度中心class EventBus {\r\n  constructor() {\r\n    this.events = {}\r\n  }\r\n\r\n  on(key, cb) { this.events[key].push(cb) }\r\n\r\n  trigger(key, args) { \r\n    this.events[key].forEach(function (cb) {\r\n      cb.call(this, ...args)\r\n    })\r\n  }\r\n  \r\n  remove() {}\r\n}\r\n\r\nconst event = new EventBus()事件订阅者// 子组件\r\nComponent({\r\n  created() {\r\n    event.on('data-ready', (data) => { this.setData({ data }) })\r\n  }\r\n})事件发布者// Parent\r\nComponent({\r\n  ready() {\r\n    event.trigger('data-ready', data)\r\n  }\r\n})子组件被创建时事先监听数据下发事件，当父组件获取到数据后触发事件把数据传递给子组件，这整个过程都是在小程序的逻辑层里同步执行，比数据绑定的方式速度更快。但并非所有场景都适合这种做法。像京喜首页这种具有 “数据单向传递” 、 “展示型交互” 特性、且 一级子组件数量庞大 的场景，使用事件总线的效益将会非常高；但若是频繁 “双向数据流“ 的场景，用这种方式会导致事件交错难以维护。题外话，Taro 框架在处理父子组件间数据传递时使用的是观察者模式，通过 Object.defineProperty 绑定父子组件关系，当父组件数据发生变化时，会递归通知所有后代组件检查并更新数据。这个通知的过程会同步触发数据 diff 和一些校验逻辑，每个组件跑一遍大概需要 5 ~ 10 ms 的时间。所以，如果组件量级比较大，整个流程下来时间损耗还是不小的，我们依旧可以尝试事件总线的方案。组件层面的 diff我们可能会遇到这样的需求，多个组件之间位置不固定，支持随时随地灵活配置，京喜首页也存在类似的诉求。京喜首页主体可被划分为若干个业务组件（如搜索框、导航栏、商品轮播等），这些业务组件的顺序是不固定的，今天是搜索框在最顶部，明天有可能变成导航栏在顶部了（夸张了...）。我们不可能针对多种顺序可能性提供多套实现，这就需要用到小程序的自定义模板 <template> 。实现一个支持调度所有业务组件的模板，根据后台下发的模块数组按序循环渲染模板，如下面例程所示。<!-- index.wxml -->\r\n<template name=\"render-component\">\r\n  <search-bar wx:if=\"{{compId === 'SearchBar'}}\" floor-id=\"{{index}}\" />\r\n  <nav-bar wx:if=\"{{compId === 'NavBar'}}\" floor-id=\"{{index}}\" />\r\n  <banner wx:if=\"{{compId === 'Banner'}}\" floor-id=\"{{index}}\" />\r\n  <icon-nav wx:if=\"{{compId === 'IconNav'}}\" floor-id=\"{{index}}\" />\r\n</template>\r\n\r\n<view\r\n  class=\"component-wrapper\"\r\n  wx:for=\"{{comps}}\"\r\n  wx:for-item=\"comp\"\r\n>\r\n  <template is=\"render-component\" data=\"{{...comp}}\"/>\r\n</view>// search-bar.js\r\nComponent({\r\n  properties: {\r\n    floorId: Number,\r\n  },\r\n  created() {\r\n    event.on('data-ready', (comps) => {\r\n      const data = comps[this.data.floorId] // 根据楼层位置取数据\r\n    })\r\n  }\r\n})貌似非常轻松地完成需求，但值得思考的是： 如果组件顺序调整了，所有组件的生命周期会发生什么变化？假设，上一次渲染的组件顺序是 ['search-bar'，'nav-bar'，'banner', 'icon-nav'] ，现在需要把 nav-bar 组件去掉，调整为 ['search-bar'，'banner', 'icon-nav'] 。经实验得出， 当某个组件节点发生变化时，其前面的组件不受影响，其后面的组件都会被销毁重新挂载。原理很简单，每个组件都有各自隔离的节点树（ ShadowTree ），页面 body 也是一个节点树。在调整组件顺序时，小程序框架会遍历比较新/旧节点树的差异，于是发现新节点树的 nav-bar 组件节点不见了，就认为该（树）分支下从 nav-bar 节点起发生了变化，往后节点都需要重渲染。但实际上，这里的组件顺序是没有变化的，丢失的组件按道理不应该影响到其他组件的正常渲染。所以，我们在 setData 前先进行了新旧组件列表 diff： 如果 newList 里面的组件是 oldList 的子集，且相对顺序没有发生变化，则所有组件不重新挂载 。除此之外，我们还要在接口数据的相应位置填充上空数据，把该组件隐藏掉，done。通过组件 diff 的手段，可以有效降低视图层的渲染压力，如果有类似场景的朋友，也可以参考这种方案。内存占用过高？想必没有什么会比小程序 Crash 更影响用户体验了。当小程序占用系统资源过高，就有可能会被系统销毁或被微信客户端主动回收。应对这种尴尬场景，除了提示用户提升硬件性能之外（譬如来京东商城买新手机），还可以通过一系列的优化手段降低小程序的内存损耗。内存预警小程序提供了监听内存不足告警事件的 API： wx.onMemoryWarning ，旨在让开发者收到告警时及时释放内存资源避免小程序 Crash。然而对于小程序开发者来说，内存资源目前是无法直接触碰的，最多就是调用 wx.reLaunch 清理所有页面栈，重载当前页面，来降低内存负荷（此方案过于粗暴，别冲动，想想就好...）。不过内存告警的信息收集倒是有意义的，我们可以把内存告警信息（包括页面路径、客户端版本、终端手机型号等）上报到日志系统，分析出哪些页面 Crash 率比较高，从而针对性地做优化，降低页面复杂度等等。回收后台页面计时器根据双线程模型，小程序每一个页面都会独立一个 webview 线程，但逻辑层是单线程的，也就是所有的 webview 线程共享一个 JS 线程。以至于当页面切换到后台态时，仍然有可能抢占到逻辑层的资源，譬如没有销毁的 setInterval 、 setTimeout 定时器：// Page A\r\nPage({\r\n  onLoad() {\r\n    let i = 0\r\n    setInterval(() => { i++ }, 100)\r\n  }\r\n})即使如小程序的 <swiper> 组件，在页面进入后台态时依然是会持续轮播的。正确的做法是， 在页面 onHide 的时候手动把定时器清理掉，有必要时再在 onShow 阶段恢复定时器 。坦白讲，区区一个定时器回调函数的执行，对于系统的影响应该是微不足道的，但不容忽视的是回调函数里的代码逻辑，譬如在定时器回调里持续 setData 大量数据，这就非常难受了...避免频发事件中的重度内存操作我们经常会遇到这样的需求：广告曝光、图片懒加载、导航栏吸顶等等，这些都需要我们在页面滚动事件触发时实时监听元素位置或更新视图。在了解小程序的双线程模型之后不难发现，页面滚动时 onPageScroll 被频发触发，会使逻辑层和视图层发生持续通信，若这时候再 “火上浇油” 调用 setData 传输大量数据，会导致内存使用率快速上升，使页面卡顿甚至 “假死”。所以，针对频发事件的监听，我们最好遵循以下原则：onPageScroll 事件回调使用节流；避免 CPU 密集型操作，譬如复杂的计算；避免调用 setData ，或减小 setData 的数据量；尽量使用 IntersectionObserver 来替代 SelectorQuery ，前者对性能影响更小；大图、长列表优化据 小程序官方文档 描述，大图片和长列表图片在 iOS 中会引起 WKWebView 的回收，导致小程序 Crash。对于大图片资源（譬如满屏的 gif 图）来说，我们只能尽可能对图片进行降质或裁剪，当然不使用是最好的。对于长列表，譬如瀑布流，这里提供一种思路：我们可以利用 IntersectionObserver 监听长列表内组件与视窗之间的相交状态，当组件距离视窗大于某个临界点时，销毁该组件释放内存空间，并用等尺寸的骨架图占坑；当距离小于临界点时，再取缓存数据重新加载该组件。然而无可避免地，当用户快速滚动长列表时，被销毁的组件可能来不及加载完，视觉上就会出现短暂的白屏。我们可以适当地调整销毁阈值，或者优化骨架图的样式来尽可能提升体验感。小程序官方提供了一个 长列表组件 ，可以通过 npm 包的方式引入，有兴趣的可以尝试。总结结合上述的种种方法论，京喜小程序首页进行全方位升级改造之后给出了答卷：1. Audits 审计工具的性能得分 86 ；2. 优化后的首屏渲染完成时间（FMP）：3. 优化前后的测速数据对比：然而，业务迭代在持续推进，多样化的用户场景徒增不减，性能优化将成为我们日常开发中挥之不去的原则和主题。本文以微信小程序开发中与性能相关的问题为出发点，基于小程序的底层框架原理，探究小程序性能体验提升的各种可能性，希望能为各位小程序开发者带来参考价值。参考User-centric Performance MetricsReduce JavaScript Payloads with Tree Shaking小程序开发指南小程序官方文档Taro 官方文档探究WebP一些事儿京喜首页（微信购物入口）跨端开发与优化实践欢迎关注凹凸实验室博客： aotu.io或者关注凹凸实验室公众号（AOTULabs），不定时推送文章："}
{"title": "微信小程序自定义navigationBar顶部导航栏，兼容适配所有机型（附完整案例） ...", "author": "Rolan", "time": "2020-3-27 00:37", "content": "本文首发自个人自有博客： 【FaxMiao个人博客】 ，一个关注Web前端开发技术、关注用户体验、记录前端点滴，坚持更多原创，为大家提供高质量技术博文！前言navigationBar相信大家都不陌生把？今天我们就来说说自定义navigationBar，把它改变成我们想要的样子（搜索框+胶囊、搜索框+返回按钮+胶囊等）。思路隐藏原生样式获取胶囊按钮、状态栏相关数据以供后续计算根据不同机型计算出该机型的导航栏高度，进行适配编写新的导航栏引用到页面正文一、隐藏原生的navigationBarwindow全局配置里有个参数：navigationStyle（导航栏样式），default=默认样式，custom=自定义样式。\"window\": {\r\n\t\"navigationStyle\": \"custom\"\r\n}\r\n复制代码让我们看看隐藏后的效果：可以看到原生的navigationBar已经消失了，剩下孤零零的胶囊按钮，胶囊按钮是无法隐藏的。二、准备工作1.获取胶囊按钮的布局位置信息我们用wx.getMenuButtonBoundingClientRect() 【官方文档】 获取胶囊按钮的布局位置信息，坐标信息以屏幕左上角为原点：const menuButtonInfo = wx.getMenuButtonBoundingClientRect();\r\n复制代码widthheighttoprightbottomleft宽度高度上边界坐标右边界坐标下边界坐标左边界坐标下面是官方给的示意图，方便大家理解几个坐标。2.获取系统信息用wx.getSystemInfoSync() 【官方文档】 获取系统信息，里面有个参数：statusBarHeight（状态栏高度），是我们后面计算整个导航栏的高度需要用到的。const systemInfo = wx.getSystemInfoSync();\r\n复制代码三、计算公式我们先要知道导航栏高度是怎么组成的， 计算公式： 导航栏高度 = 状态栏到胶囊的间距（胶囊距上距离-状态栏高度） * 2 + 胶囊高度 + 状态栏高度 。实例 【源码下载】自定义导航栏会应用到多个、甚至全部页面，所以封装成组件，方便调用；下面是我写的一个简单例子：app.jsApp({\r\n    onLaunch: function(options) {\r\n        const that = this;\r\n        // 获取系统信息\r\n        const systemInfo = wx.getSystemInfoSync();\r\n        // 胶囊按钮位置信息\r\n        const menuButtonInfo = wx.getMenuButtonBoundingClientRect();\r\n        // 导航栏高度 = 状态栏到胶囊的间距（胶囊距上距离-状态栏高度） * 2 + 胶囊高度 + 状态栏高度\r\n        that.globalData.navBarHeight = (menuButtonInfo.top - systemInfo.statusBarHeight) * 2 + menuButtonInfo.height + systemInfo.statusBarHeight;\r\n        that.globalData.menuRight = systemInfo.screenWidth - menuButtonInfo.right;\r\n        that.globalData.menuBotton = menuButtonInfo.top - systemInfo.statusBarHeight;\r\n        that.globalData.menuHeight = menuButtonInfo.height;\r\n    },\r\n    // 数据都是根据当前机型进行计算，这样的方式兼容大部分机器\r\n    globalData: {\r\n        navBarHeight: 0, // 导航栏高度\r\n        menuRight: 0, // 胶囊距右方间距（方保持左、右间距一致）\r\n        menuBotton: 0, // 胶囊距底部间距（保持底部间距一致）\r\n        menuHeight: 0, // 胶囊高度（自定义内容可与胶囊高度保证一致）\r\n    }\r\n})\r\n复制代码app.json{\r\n    \"pages\": [\r\n        \"pages/index/index\"\r\n    ],\r\n    \"window\": {\r\n        \"navigationStyle\": \"custom\"\r\n    },\r\n    \"sitemapLocation\": \"sitemap.json\"\r\n}\r\n复制代码下面为组件代码： /components/navigation-bar/navigation-bar.wxml<!-- 自定义顶部栏 -->\r\n<view class=\"nav-bar\" style=\"height:{{navBarHeight}}px;\">\r\n    <input class=\"search\" placeholder=\"输入关键词！\" style=\"height:{{menuHeight}}px; min-height:{{menuHeight}}px; line-height:{menuHeight}}px; left:{{menuRight}}px; bottom:{{menuBotton}}px;\"></input>\r\n</view>\r\n\r\n<!-- \r\n    内容区域：\r\n    自定义顶部栏用的fixed定位，会遮盖到下面内容，注意设置好间距\r\n-->\r\n<view class=\"content\" style=\"margin-top:{{navBarHeight}}px;\"></view>\r\n复制代码/components/navigation-bar/navigation-bar.json{\r\n  \"component\": true\r\n}\r\n复制代码/components/navigation-bar/navigation-bar.jsconst app = getApp()\r\nComponent({\r\n    properties: {\r\n        // defaultData（父页面传递的数据-就是引用组件的页面）\r\n        defaultData: {\r\n            type: Object,\r\n            value: {\r\n                title: \"我是默认标题\"\r\n            },\r\n            observer: function(newVal, oldVal) {}\r\n        }\r\n    },\r\n    data: {\r\n        navBarHeight: app.globalData.navBarHeight,\r\n        menuRight: app.globalData.menuRight,\r\n        menuBotton: app.globalData.menuBotton,\r\n        menuHeight: app.globalData.menuHeight,\r\n    },\r\n    attached: function() {},\r\n    methods: {}\r\n})\r\n复制代码/components/navigation-bar/navigation-bar.wxss.nav-bar{ position: fixed; width: 100%; top: 0; color: #fff; background: #000;}\r\n.nav-bar .search{ width: 60%; color: #333; font-size: 14px; background: #fff; position: absolute; border-radius: 50px; background: #ddd; padding-left: 14px;}\r\n复制代码以下是调用页面的代码，也就是引用组件的页面： /pages/index/index.wxml<navigation-bar default-data=\"{{defaultData}}\"></navigation-bar>\r\n复制代码/pages/index/index.json{\r\n    \"usingComponents\": {\r\n        \"navigation-bar\": \"/components/navigation-bar/navigation-bar\"\r\n    }\r\n}\r\n复制代码/pages/index/index.jsconst app = getApp();\r\nPage({\r\n    data: {\r\n        // 组件参数设置，传递到组件\r\n        defaultData: {\r\n            title: \"我的主页\", // 导航栏标题\r\n        }\r\n    },\r\n    onLoad() {\r\n        console.log(this.data.height)\r\n    }\r\n})\r\n复制代码效果图：好了，以上就是全部代码了，大家可以文中复制代码，也可以 【下载源码】，直接到开发者工具里运行，记得appid用自己的或者测试哦！下面附几张其它小程序的效果图，大家也可以尝试照着做：总结本文写了自定义navigationBar的一些基础性东西，里面涉及组件用法、参数传递、导航栏相关。由于测试环境有限，大家在使用时如果发现有什么问题，希望及时反馈，以供及时更新帮助更多的人！大家有什么疑问，欢迎评论区留言！"}
{"title": "阿里盒马、腾讯小程序团队 —— 小菜鸡自闭の面经（等HRing...） ...", "author": "Rolan", "time": "2020-3-27 00:42", "content": "俺这只小菜鸡:chicken:终于也快迎来曙光了！:grinning:俺现在是一名大三学生，渴望能获得一份大厂的实习机会呜呜呜，所以不自量力的投了一下阿里跟腾讯。阿里是提前批就开始面了的。很多部门都面了一下下，面了啥也忘了哈哈哈哈。也多亏了提前批，让俺知道哪些地方还需要再补补。阿里这边最终选择了盒马，盒马的面试官都好好，好和蔼，给了好多建议，没有因为我菜就嫌弃我呜呜呜，太感动了。而且！看到这张“ 屁股脸 ”难道不想加入换一套限量公仔/手办吗！个人の想法我觉得面试更像是一次学习的机会，可以查漏补缺，之后自己深入学习更多的东西我还是觉得大厂面试，还是得有一个自己熟悉的、参与度高的项目来展开，因为还是很多面试官会选择问问项目经历来了解我们。不会就是不会哈哈哈哈，老实承认就好，之后自己下去再找找资料补一补就好！不必沉浸在悲伤之中面试完之后，如果有问题，尽量积极主动的去寻找面试官请教，不要觉得不好意思或者说不敢这样子，我觉得就算即便是挂了也好，也可以请教一下学到更多的东东，不至于一场面试下来颗粒无收阿里の盒马初面初面是聊得最久的一次了，一个多小时了吧，不过初面的面试官真的很让人感动一直在鼓励我，“好啊好啊”，“没关系没关系”，啊太棒了，给俺这个小菜鸡很多信心hhhh输入url到页面展示浏览器存储如何实现继承跨域，常用哪个，解释一下缓存重绘回流性能优化React优势React生命周期React最佳实践React新特性如果列表组件要新增一些内容，例如标题，简介等，你会怎么对代码进行修改（容器组件 -> 展示组件）csrf 和 xssflex判断是否为数组typeof arr === 'object'浏览器事件循环，node事件循环事件委托webpack流程，插件koa源码koa洋葱模型mobx原理首屏优化async/await Promise盒模型babel原理Taro原理一面一面俺就放放笔试题还有俺自己做的情况吧哈哈哈哈，一面的面试官跟俺说拓扑排序，俺才知道原来还有这种东西（流泪...笔试题目给定一个链表，判断链表中是否有环，比如下图这种即为有环链表。加分项：使用空间复杂度 O(1) 实现分析一个项目的依赖结构，并按依赖优先级排序。 已知一个项目的依赖结构，期望在前端通过 loader 的方式异步加载相关的组件，而我们期望依赖在加载的过程中：每一个依赖被加载后都会被立刻执行，那么如果要争取加载一个依赖，则其子依赖都应该优先被加载每一个依赖不希望在钱多出现冗余的情况，若依赖出现多版本的情况，则默认使用更新的版本，比如已知项目依赖结构为（其中 @ 后面的为依赖版本号）：ProjectA\r\n- a@0.1.0\r\n    - d@0.2.0\r\n    - c@0.1.0\r\n- b@0.1.1\r\n    - e@0.1.2\r\n    - c@0.1.2\r\n- c@0.2.0\r\n复制代码则其中一种输出的依赖优先级排序为：['d@0.2.0', 'c@0.2.0', 'a@0.1.0', 'e@0.1.2', 'b@0.1.1']输出分析： 为了让 a 加载后可以争取执行，则必须先加载 d 和 c，b 的加载同理，又因为在整个依赖关系下，c 的最新版本为 0.2.0 于是有了如上的输出结果。请用 React 实现一个搜索框组件，功能包括：输入文本字数限制可配置输入文本约束，比如仅限输入数字用户输入时可支持关键字搜索，并出现下拉框展示相关项俺的答案第一题leetcode原题来的，环形链表好像是，可以用快慢指针或者简单的集合const cycle1 = function (node) {\r\n  let set = new Set()\r\n  while (node) {\r\n    if (set.has(node))\r\n      return true\r\n    else\r\n      set.add(node)\r\n    node = node.next\r\n  }\r\n  return false\r\n};\r\n\r\n\r\n\r\nconst cycle2 = function (node) {\r\n  let start = node\r\n  let end = node.next\r\n  while (start !== end) {\r\n    // 没有环就null\r\n    if (end === null || end.next === null) return false\r\n    start = start.next\r\n    end = end.next.next\r\n  }\r\n  return true\r\n}\r\n复制代码第二题的话我拿到题目第一个想到的就是DFS来寻找那些依赖，然后最后再对依赖这些进行版本比较（其实应该用集合、还有拓扑排序来优化）function update(npmList) {\r\n  let versions = {}\r\n  let res = []\r\n\r\n  // 比较版本号\r\n  function cmp(a, b) {\r\n    const versionA = getVersion(a).split('.')\r\n    const versionB = getVersion(b).split('.')\r\n    for (let index = 0; index < 3; index++) {\r\n      if (versionA[index] > versionB[index]) return a\r\n      else if (versionA[index] === versionB[index]) continue\r\n      else return b\r\n    }\r\n    return a\r\n  }\r\n\r\n  // 获得版本号\r\n  function getVersion(str) {\r\n    return str.substr(str.indexOf('@') + 1)\r\n  }\r\n\r\n  function dfs(npmList) {\r\n    if (npmList.length === 0) return\r\n\r\n    npmList.forEach((npm) => {\r\n      const { name, deps = [] } = npm\r\n      // 先遍历他们的依赖\r\n      dfs(deps)\r\n      let key = name.substr(0, name.indexOf('@'))\r\n      // 如果依赖不存在则添加，若已存在，则取最新版\r\n      if (!versions[key]) {\r\n        versions[key] = name\r\n      } else {\r\n        versions[key] = cmp(versions[key], name)\r\n      }\r\n      // 添加进最后的加载列表\r\n      res.push(key)\r\n    })\r\n    return\r\n  }\r\n  dfs(npmList)\r\n  // 去除重复项，然后将包名转换为依赖名，eg: a -> a@0.1.0\r\n  return [...new Set(res)].map(key => versions[key])\r\n}\r\n复制代码第三题的话，我粗略写了一下噗，写的也不是很好，用React整的// 第三题React部分第三题React部分第三题React部分第三题React部分第三题React部分\r\n\r\nimport React, { Component } from 'react';\r\nimport './input.css'\r\n\r\nfunction debounce(fn, delay = 500) {\r\n  let timeout = null\r\n  return function (e, ...args) {\r\n    e.persist && e.persist()\r\n    timeout && clearTimeout(timeout)\r\n    timeout = setTimeout(() => {\r\n      fn.call(this, e, ...args)\r\n    }, delay)\r\n  }\r\n}\r\n\r\nclass Tips extends Component {\r\n  render() {\r\n    const { tipsList } = this.props\r\n    return tipsList && tipsList.length !== 0 ? (\r\n      <div className=\"tips__container\">\r\n        {tipsList.map((item, index) => {\r\n          return (\r\n            <a href=\"#\" key={index} className=\"link\">{item}</a>\r\n          )\r\n        })}\r\n      </div>\r\n    ) : <div></div>\r\n  }\r\n}\r\n\r\nexport default class Input extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      keyWords: [\r\n        '前端工程师1', '前端高级开发1', '后端工程师1', '测试开发1', '项目主管1', 'dress', 'Recent', '123456', 'awdad1'\r\n      ],\r\n      inputValue: '',\r\n      inputType: 'text',\r\n      inputMaxLen: 20,\r\n      wordsList: []\r\n    }\r\n    this.handleInput = debounce(this.handleInput, 200)\r\n    this.handleMaxLenChange = debounce(this.handleMaxLenChange, 400)\r\n  }\r\n\r\n  handleInput = (e) => {\r\n    const { target: { value } } = e\r\n    const { keyWords } = this.state\r\n    const tipsList = !value\r\n      ? []\r\n      : keyWords.filter(item => {\r\n        const res = item.search(new RegExp(value, 'i'))\r\n        return res !== -1\r\n      })\r\n    this.setState({\r\n      inputValue: value,\r\n      tipsList\r\n    })\r\n  }\r\n\r\n  handleTypeClick = (e) => {\r\n    const { target: { name } } = e\r\n    this.setState({ inputType: name })\r\n  }\r\n\r\n  handleMaxLenChange = (e) => {\r\n    const { target: { value } } = e\r\n    const { inputValue } = this.state\r\n    const newInputValue = inputValue.substr(0, +value)\r\n    // 如果设置最大长度小于现在关键词的长度，则截取一下\r\n    this.input.value = newInputValue\r\n    this.setState({ inputMaxLen: value, inputValue: newInputValue })\r\n  }\r\n\r\n  render() {\r\n    const { tipsList, inputType, inputMaxLen } = this.state\r\n    return (\r\n      <div className=\"container\">\r\n        <div className=\"control__container\" onClick={this.handleTypeClick}>\r\n          <button name=\"text\">文本</button>\r\n          <button name=\"number\">数字</button>\r\n          <span>最大长度: </span>\r\n          <input type=\"number\" placeholder=\"默认: 20\" onInput={this.handleMaxLenChange} />\r\n        </div>\r\n        <div className=\"input__container\">\r\n          <div className=\"input__wrap\">\r\n            <input\r\n              ref={input => this.input = input}\r\n              placeholder=\"请输入关键词\"\r\n              type={inputType}\r\n              maxLength={inputMaxLen}\r\n              onInput={this.handleInput} />\r\n            <button>搜索</button>\r\n          </div>\r\n          <Tips tipsList={tipsList} />\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n复制代码// 第三题CSS部分第三题CSS部分第三题CSS部分第三题CSS部分第三题CSS部分第三题CSS部分\r\n\r\n\r\n.container {\r\n  width: 600px;\r\n  height: 400px;\r\n  margin: 0 auto;\r\n  padding: 30px;\r\n  background: #fff;\r\n}\r\n\r\n.input__container {\r\n  margin-top: 30px;\r\n}\r\n\r\n.input__wrap {\r\n  display: flex;\r\n  align-items: center;\r\n}\r\n\r\n.input__wrap input {\r\n  box-sizing: border-box;\r\n  width: 85%;\r\n  height: 50px;\r\n  padding: 0 10px;\r\n  border: #666 1px solid;\r\n  border-right: 0;\r\n  outline: none;\r\n}\r\n\r\n.input__wrap button {\r\n  cursor: pointer;\r\n  box-sizing: border-box;\r\n  width: 15%;\r\n  height: 50px;\r\n  color: #fff;\r\n  font-size: 20px;\r\n  border: none;\r\n  border: #666 1px solid;\r\n  outline: none;\r\n  background: #1890ff;\r\n}\r\n\r\n.control__container {\r\n  display: flex;\r\n  align-items: center;\r\n}\r\n\r\n.control__container button {\r\n  cursor: pointer;\r\n  width: 50px;\r\n  height: 30px;\r\n  margin-right: 10px;\r\n  color: #fff;\r\n  outline: none;\r\n  border: #333 1px solid;\r\n  border-radius: 8px;\r\n  background: #1890ff;\r\n}\r\n\r\n.control__container span {\r\n  margin-left: auto;\r\n  margin-right: 10px;\r\n  color: #666;\r\n  font-size: 14px;\r\n}\r\n\r\n.tips__container {\r\n  overflow-y: scroll;\r\n  max-height: 200px;\r\n  border: #333 1px solid;\r\n  border-top: 0;\r\n}\r\n\r\n.tips__container .link {\r\n  display: block;\r\n  height: 30px;\r\n  padding: 5px 10px;\r\n  color: #666;\r\n  line-height: 30px;\r\n  text-decoration: none;\r\n}\r\n\r\n.tips__container .link:hover {\r\n  color: #fff;\r\n  background: #666;\r\n}\r\n\r\ninput::-webkit-outer-spin-button,\r\ninput::-webkit-inner-spin-button {\r\n  display: none;\r\n}\r\n复制代码二面二面主要是结合项目来问的，抓住一个功能发散开来，例如我项目的聊天室的功能，吓得我好慌好慌hhh，不过面试官人很好一直引导我，特别是那些场景题，引导我去思考，啊，太感动了！！！项目の各种东东聊天私聊怎么做聊天记录未读消息怎么做聊天离线信息处理session会话管理如何实现（用户登录后，打开新标签页输入url访问资源）访问资源权限控制事件队列题websocket如何连接做题系统组件的设计与拓展（拓展更多类型的题目，如何设计组件）用户鉴权系统设计为什么密码表跟用户信息表分开放数据库表的设计三面这一面也是结合项目来问的。啊，三面的面试官真的太好了，期初我的小项目没什么难点（我都以为凉透透了呜呜呜），然后面试官给了提了几个建议，让我多去深入思考思考，面试完之后去找他请教问题，也一直很有耐心给我指导指导，啊，太棒了吧项目の各种东东飞猪为什么挂了项目难点小程序登录怎么做的封装了什么组件建议：在线阅卷、批注、修改错别字等（canvas绘制）建议：实时监控每个同学的进度（选择答案后之后教师端更新/摄像头监控）a与b聊天，将他们的记录，多选，然后合并发给c，如何设计除了编译成小程序，有试过app吗四面四面应该是总监面，还是得感谢三面的面试官给我提的建议，之后做出来之后，发现这个东东可以作为项目的一个难点来吹哈哈哈！四面主要还是围绕项目来问，我个人觉得关注的更是自己的思维、对技术的认识、对自己未来的发展规划等宏观的内容就是这个小功能，canvas实现作业批注等功能项目难点（canvas绘制公式websocket实现，聊天功能的实现（心跳检测，断线重连项目の细节聊天信息的一致性，时序性目标、具体想通过实习学到什么技术规划，之后学些什么五面五面是交叉面，心惊胆跳呜呜呜，希望不要挂我...五面问的大多是基础方面的内容，不过也是结合项目来问的，这一面面试官主要关注的是 性能 方面的内容，例如数据埋点啊、页面加载时间、接口响应时间等一系列关于性能方面的问题，他希望的是数据量化的一个东东，具体的实现，达成了什么目标等项目做了那些事情小程序运行池小程序和H5的区别缓存存在哪（强缓存、协商缓存分别通过什么字段保存React与Vue的区别React的优势Taro编译的机制Taro支持的端有哪些node的机制、优势项目的难点，如何解决，遇到的问题如何监控性能尝试做了哪些性能上的优化收集用户信息？数据埋点？性能指标？量化指标？资源大小，加载速度，页面渲染时间，接口访问时间如何优化node后台的接口（sql优化，表结构重写使用什么服务器，部署在什么操作系统上多人同时访问接口测试过吗？最高承载多少webpack如何减小资源打包大小擅长什么你的优势是什么目标？规划？腾讯の小程序一面一面是笔试 + 面试，俺也放放题目跟俺的答案吧！笔试题目实现⼀个函数 reverse(a, n) ，反转⼀个含有 n 个整数的数组 a（直接在数组a上操作，元素交换次数 尽可能少，不能使⽤js Array 类内置属性和⽅法）。实现⼀个函数 countLongest(tree) ，输⼊⼀棵⼆叉树，返回⼆叉树中距离最⻓的两个叶⼦节点之间 的距离。var x = [0, 1, 2, 3]\r\nreverse(x, 4) // x = [3, 2, 1, 0]\r\nvar y = [1, 2, 3, 4, 1]\r\nreverse(y, 5) // y = [1, 4, 3, 2, 1]\r\nvar tree1 = {\r\n  value: 1,\r\n  left: {\r\n    value: 2\r\n  },\r\n  right: {\r\n    value: 3\r\n  }\r\n}\r\ncountLongest(tree1) // 2\r\nvar tree2 = {\r\n  value: 1,\r\n  left: {\r\n    value: 2,\r\n    left: {\r\n      value: 3,\r\n      left: {\r\n        value: 6\r\n      }\r\n    },\r\n    right: {\r\n      value: 4\r\n    }\r\n  },\r\n  right: {\r\n    value: 5\r\n  }\r\n}\r\ncountLongest(tree2) // 4\r\n复制代码在前端开发中，通常会把多个js⽂件合并成⼀个⽂件，以减少⽹络请求次数，达到优化加载速度的⽬ 的，但是当⽂件之间存在依赖关系时，对js合并的顺序，会有⼀定的要求，⽐如 A.js 依赖了 B.js，那打 包后的⽂件，B.js 需要排在 A.js 的前⾯。 实现⼀个函数 resolve(tree) ，根据js的依赖关系树 tree，输出合理的打包顺序的数组（结果可能不 唯⼀，输出其中⼀种即可）。样例var tree1 = {\r\n  name: 'main.js',\r\n  require: [{\r\n    name: 'A.js'\r\n  }, {\r\n    name: 'B.js'\r\n  }]\r\n}\r\nresolve(tree1) // ['A.js', 'B.js', 'main.js']\r\nvar tree2 = {\r\n  name: 'page.js',\r\n  require: [{\r\n    name: 'A.js',\r\n    require: [{\r\n      name: 'B.js',\r\n      require: [{\r\n        name: 'C.js'\r\n      }]\r\n    }]\r\n  }, {\r\n    name: 'D.js',\r\n    require: [{\r\n      name: 'C.js'\r\n    }, {\r\n      name: 'E.js'\r\n    }]\r\n  }]\r\n}\r\nresolve(tree2) // ['C.js', 'E.js', 'D.js', 'B.js', 'A.js', 'page.js']\r\n复制代码给定⼀个整数数组 a，实现⼀个函数 countMax(a) ，计算出从 a 中选择出多个不相邻元素组成最⼤的 和是多少。样例var x = [1, 4, 5, 3]\r\ncountMax(x) // 7\r\nvar y = [3, 12, 6, 2, 4]\r\ncountMax(y) // 16\r\n复制代码俺的答案就是简单的倒置hhhfunction reverse(arr) {\r\n  let len = arr.length\r\n  for (let start = 0; start < Math.floor(len / 2); start++) {\r\n    let end = len - start - 1;\r\n    [arr[start], arr[end]] = [arr[end], arr[start]]\r\n  }\r\n  return arr\r\n}\r\n复制代码这题是leetcode原题好像，就算算深度function countLongest(tree) {\r\n  if (!tree) return 0\r\n  let res = 0\r\n\r\n  function dfs(node) {\r\n    if (!node) return 0\r\n    const leftMax = dfs(node.left)\r\n    const rightMax = dfs(node.right)\r\n    res = Math.max(leftMax + rightMax, res)\r\n    return Math.max(leftMax, rightMax) + 1\r\n  }\r\n  dfs(tree)\r\n  return res\r\n}\r\n\r\nconsole.log(countLongest({\r\n  value: 1,\r\n  left: {\r\n    value: 2\r\n  },\r\n  right: {\r\n    value: 3\r\n  }\r\n}))\r\nconsole.log(countLongest({\r\n  value: 1,\r\n  left: {\r\n    value: 2,\r\n    left: {\r\n      value: 3,\r\n      left: {\r\n        value: 6\r\n      }\r\n    },\r\n    right: {\r\n      value: 4\r\n    }\r\n  },\r\n  right: {\r\n    value: 5\r\n  }\r\n}))\r\n复制代码第三题是不是很眼熟哈哈哈，跟盒马一面的笔试题好像（其实我发现很多面试笔试题都有这相关的影子）还是DFS来找function resolve(npmList) {\r\n  const res = []\r\n\r\n  function dfs(npmList) {\r\n    if (npmList.length === 0) return\r\n\r\n    npmList.forEach((npm) => {\r\n      const { name, require = [] } = npm\r\n      dfs(require)\r\n      !res.includes(name) && res.push(name)\r\n    })\r\n    return\r\n  }\r\n  dfs(npmList)\r\n  return res\r\n}\r\n\r\n\r\nconsole.log(resolve([{\r\n  name: 'page.js',\r\n  require: [{\r\n    name: 'A.js',\r\n    require: [{\r\n      name: 'B.js',\r\n      require: [{\r\n        name: 'C.js'\r\n      }]\r\n    }]\r\n  }, {\r\n    name: 'D.js',\r\n    require: [{\r\n      name: 'C.js'\r\n    }, {\r\n      name: 'E.js'\r\n    }]\r\n  }]\r\n}]))\r\n复制代码用动态规划来找function countMax2(arr) {\r\n  const len = arr.length\r\n  const dp = new Array(len).fill(0);\r\n  dp[0] = arr[0]\r\n  dp[1] = arr[1]\r\n  dp[2] = arr[0] + arr[2]\r\n  // [1, 4, 7, 0]\r\n\r\n  // [3, 12, 9, ...], \r\n  // [3, 12, 9, 14, ...],\r\n  for (let i = 3; i < len; i++) {\r\n    dp[i] = arr[i] + Math.max(dp[i - 2], dp[i - 3])\r\n  }\r\n  return dp[len - 1]\r\n}\r\n\r\nconsole.log(countMax2([1, 4, 5, 3]))\r\nconsole.log(countMax2([3, 12, 6, 2, 4]))\r\n// console.log(countMax2([1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7]))\r\n复制代码面试内容项目为什么用token不用cookie跨域（前端跟前端的跨域，iframe之间）xssReact与Vue的对比Taro与其他多端框架主要还是项目发散如何实现轮播图二面二面基本都是一些基础吧，但是就有些地方会深入去挖这样子https原理，握手过程(何时对称/非对称，谁先谁后，为什么这样)常见的优化webp格式优化了多少缓存以键值形式存在浏览器，键是什么，值是什么设计一个缓存策略，（hash值）React的keyReact与Vue的区别Taro与小程序官方框架的区别小程序运行池React列表key固定，顺序调换会渲染吗（不会）如何判断性能瓶颈项目の各种东东三面三面感觉还不够二面难，问的比较常见吧应该说，然后也是问问项目这样子算法：判断数组中是否存在两个数相加等于目标值，给出多种思路与时间空间复杂度（暴力循环，排序后循环剪枝，动态规划）es6的class如何实现私有变量（symbol + 闭包）如何进行性能监控常见的性能优化方法内存泄露如何发现，如何解决垃圾回收机制跨域（cors + jsonp + 其他不常见的跨域方法）浏览器缓存实现深拷贝，深拷贝的用途xss、csrfcookie与token的工作原理，区别，如何设计http1.1、http2.0http无状态websocket是什么协议，如何连接websocket有什么优势，对比轮训呢事件循环setTimeout是否准时，如果不是则应该提前还是延迟webpack流程常见的http状态码babel原理、taro原理map中的键值会不会被回收（weakMap，weakSet等）项目....难点、设计、收获平时如何学习"}
{"title": "iPhoneX安全区域(Safe Area)底部小黑条在微信小程序和H5的屏幕适配 ...", "author": "Rolan", "time": "2020-3-30 00:31", "content": "最近写小程序时，遇到了 iPhoneX 底部小黑线与内容重叠的问题，实际上是iPhoneX安全区域的适配问题，了解清楚这个问题花了挺多时间的，也实操出了结果，忍不住来总结总结。本文目录前言· 内容与小黑线重叠情况说明1.安全区域含义2.微信小程序适配iPhoneX底部小黑条(Home Indicator)（1）适配方案一：使用已知底部小黑条高度34px/68rpx来适配（不推荐）（2）适配方案二：使用微信官方API，getSystemInfo()中的safeArea对象进行适配（推荐）（3）适配方案三：使用苹果官方推出的css函数env()、constant()来适配 （推荐） 3.H5适配iPhoneX底部小黑条(Home Indicator)        · 适配方案：使用苹果官方推出的css函数env()、constant()来适配 （推荐）前言在苹果 iPhoneX 、iPhone XR等设备上，可以看到物理Home键被取消，改为底部小黑条替代home键功能。微信小程序和 h5 网页需要针对这种情况进行适配，否则可能会遇到底部按钮或选项卡栏与底部黑线重叠的情况，如下图。1. 安全区域是什么意思？想要解决内容与小黑线重叠的问题，我们需要先了解清楚苹果对于安全区域的定义。安全区域安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角(corners)、齐刘海(sensor housing)、小黑条(Home Indicator)的影响。看看苹果官方给的这2张图就明白了，中间蓝色区域即为安全区域。也就是说，适配安全区域也就是让小程序或者H5的内容显示在蓝色区域部分。同时安全区域是在IOS11之后并且是iPhoneX及以上机型才有的，所以需要适配的是这一类机型（为了方便，下文中统称这类需要适配的机型为iPhoneX），更老的机型则不需要考虑适配问题。2. 在微信小程序上适配安全区域三种方案：使用已知底部小黑条高度34px/68rpx来适配（不推荐）使用微信官方API，getSystemInfo()中的safeArea对象进行适配（推荐）使用苹果官方推出的css函数env()、constant()适配（推荐）方案一：使用已知底部小黑条高度34px/68rpx来适配（不推荐）这是比较老的方法，跟方案2、3比已经不推荐了，大家可以了解了解，着急可以直接看方案2和3。从网上了解到，iPhone底部的小黑条（Home Indicator）高度是34px，实际我也在真机确认了是34px，所以可以根据该值，设置底部按钮或选项卡的margin-bottom、padding-bottom、height等，或者添加一个div来占位小黑条的位置。这样做要有一个前提，需要判断当前机型是需要适配安全区域的机型。问题：如何判断当前机型是需要适配安全区域2种方案：使用 wx.getSystemInfoSync() 的 model 属性判断使用 wx.getSystemInfoSync() 中的 screenHeight 和 safeArea 对象的 bottom 属性判断方法一：使用 wx.getSystemInfoSync() 的 model 属性判断已知市面上已有的带安全区域的苹果设备包括iPhone X、iPhone XR、iPhone XS Max、iPhone 11、iPhone 11 Pro、iPhone 11 Pro Max，所以可以直接从getSystemInfoSync()方法中拿到model属性进行判断。iPhone系列微信还未适配手机的model返回值为unknown(iphone)，也可以提前做适配。let IPHONE_X = /iphone x/i\r\nlet IPHONE_X_11 = /iphone 11/i\r\nlet IPHONE_UNKNOWN = /unknown\\(iphone\\)/i\r\n\r\n//方法一：使用model判断是否是IPhoneX及其他包含安全区域的机型手机\r\nconst isIPhoneX = () => {\r\n  let model = wx.getSystemInfoSync().model\r\n  return (model.search(IPHONE_X) > -1 || model.search(IPHONE_X_11) > -1 ||\r\n    model.search(IPHONE_UNKNOWN) > -1)\r\n}\r\n\r\n//也可以使用正则表达式判断\r\nconst isIPhoneXRegex = () => {\r\n  let model = wx.getSystemInfoSync().model\r\n  return (/iphone\\sx/i.test(model)\r\n    || (/iphone/i.test(model) && /unknown/.test(model))\r\n    || /iphone\\s11/i.test(model)) \r\n}\r\n复制代码方法二：使用 wx.getSystemInfoSync() 中的 screenHeight 和 safeArea 对象的 bottom属性判断这里使用 screenHeight 而不是 windowHeight ，因为 bottom 是以屏幕左上角为原点开始计算的，所以需要的是屏幕高度，对比 screenHeight 和 bottom ，如果相等则说明不需要适配，不相等则需要适配。**注意：**如果使用微信开发者工具中的模拟器，screenHeight和bottom始终是相等的，需要用真机来测试。//方法二：使用wx.getSystemInfoSync()中的screenHeight和safeArea的bottom判断\r\nconst isIPhoneX = () => {\r\n  let screenHeight = wx.getSystemInfoSync().screenHeight\r\n  let bottom = wx.getSystemInfoSync().safeArea.bottom\r\n  return screenHeight !== bottom\r\n}\r\n复制代码解决了如何判断设备是iPhoneX的问题，就可以写代码了。<view class=\"bottom-button {{isIpX ? 'view-IPX' : ''}}\">底部按钮</view>\r\n复制代码方案二：使用微信官方API，getSystemInfo()中的safeArea对象进行适配（推荐）使用wx. getSystemInfo()中的safeArea对象获取底部小黑条的高度step 1：使用上面讲的方法先判断是否是需要适配的iPhone机型 step 2：如果是需要适配的机型，使用safeArea中的bottom，得到安全区域底部纵坐标，然后使用screenHeight减去bottom就能得到小黑条的高度。保存到localstorage里面，全局都可以使用。方案三：使用苹果官方推出适配方案css函数env()、constant()来适配 （推荐）苹果官方推荐使用 env() ， constant() 来适配，建议使用该方案，不需要管数值具体是多少。这2个方法是什么呢？env()和constant()，是IOS11新增特性，Webkit的css函数，用于设定安全区域与边界的距离，有4个预定义变量：safe-area-inset-left：安全区域距离左边边界的距离safe-area-inset-right：安全区域距离右边边界的距离safe-area-inset-top：安全区域距离顶部边界的距离safe-area-inset-bottom ：安全距离底部边界的距离因为目标是需要对底部小黑条做适配，所以只需要关注 safe-area-inset-bottom 这个值。而env()和constant()函数有个必要的 使用前提 ，当网页设置 viewport-fit=cover 的时候才生效，根据微信小程序的表现和我在实际真机测试时这两个函数生效，推测小程序里的 viewport-fit 默认是 cover 。有一点要注意，在IOS11.2系统以前，可以使用constant()函数，但是在IOS11.2系统以后，这个函数就被废弃了，被env()函数替代了。官方原话如下：The env() function shipped in iOS 11 with the name constant(). Beginning with Safari Technology Preview 41 and the iOS 11.2 beta, constant() has been removed and replaced with env(). You can use the CSS fallback mechanism to support both versions, if necessary, but should prefer env() going forward.\r\n所以我们在做屏幕适配时，需要这样写：padding-bottom: constant(safe-area-inset-bottom); /*兼容 IOS<11.2*/\r\npadding-bottom: env(safe-area-inset-bottom); /*兼容 IOS>11.2*/\r\n复制代码**注意：**env()和constant()需要同时存在，而且顺序不能换。3. 在H5上适配安全区域在H5上适配安全区域就方便多了，采用viewport+env+constant方案。viewport-fit 默认有3个值：contain：可视窗口完全包含网页内容（左图）cover：网页内容完全覆盖可视窗口（右图）auto：默认值，此值不影响初始布局视图端口，并且整个web页面都是可查看的。contain和cover具体区别如下图：而我们需要将viewport设置为cover，env和constant才能生效。设置代码如下：<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,viewport-fit=cover\">\r\n\r\n复制代码同时设置env和constant代码，同样env()和constant()需要同时存在，而且顺序不能换。/* 可以通过增加padding-bottom来适配 */\r\npadding-bottom: constant(safe-area-inset-bottom); /*兼容 IOS<11.2*/\r\npadding-bottom: env(safe-area-inset-bottom); /*兼容 IOS>11.2*/\r\n\r\n/* 可以通过margin-bottom来适配 */\r\nmargin-bottom: constant(safe-area-inset-bottom);\r\nmargin-bottom: env(safe-area-inset-bottom);\r\n\r\n/* 或者改变高度*/\r\nheight: calc(55px +  constant(safe-area-inset-bottom));\r\nheight: calc(55px +  env(safe-area-inset-bottom));\r\n复制代码也可以在底部添加一个空白的div颜色块来做适配。还有一种是使用 @supports 隔离兼容样式可以使用 @supports 来隔离兼容样式，当浏览器支持 bottom: constant(safe-area-inset-bottom) 或者 bottom: env(safe-area-inset-bottom) 的时候， bottom-button 类就会新增 margin-bottom 的样式@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) { \r\n\t.bottom-button {\r\n    \tmargin-bottom: constant(safe-area-inset-bottom);\r\n        margin-bottom: env(safe-area-inset-bottom);  \r\n    }\r\n}\r\n复制代码以上就是我对iPhoneX安全区域(Safe Area)底部小黑条在微信小程序和H5适配的总结。如果对你有帮助的话，点赞、评论、赞赏都是对我的鼓励，也是支持我写下去的动力，谢谢！参考文章：网页适配 iPhoneX，就是这么简单苹果官方开发者文档关于屏幕适配的说明微信小程序吸底区域适配iPhone X微信小程序适配 iPhone X 总结本文原创发布于微信公众号「程序员张晴天」，欢迎关注第一时间获取最新分享，一起进步。"}
{"title": "实现微信小程序编译和运行环境系列(进阶篇)", "author": "Rolan", "time": "2020-3-30 00:42", "content": "距离上一篇初始篇过了一段时间,在初始篇里面主要分享了微信小程序工具 和微信小程序的文件组成以及小程序架构的基本大纲和描述，看了第一篇的小伙伴应该大概知道了微信小程序运行时候各部分文件职能了,如果不太了解的话可以再去看下 github csdn进阶篇内容主要从以下几个方面来分享下微信小程序的架构核心文件WAService.js WAWebview.js appservice.js的解析 和其他文件在逻辑层和渲染层的:warning:注意事项websocket通信在微信小程序框架中的应用实现通过几个案例和部分代码来实现自己的小程序运行环境微信小程序云开发和小游戏架构初步分析(后续会持续更新)正文WAService.js文件在第一篇里面有讲到WAService.js文件是在 逻辑层 模版页面里面引入的，但是没有给予过多的介绍， 接下来主要分析下WAService.js的代码组成，这个文件算是微信小程序基础库文件里面很核心的文件了，所以微信对它的保护应该很到位了，微信通过了压缩 编译 打包后生成的一坨这个js文件(如下图)直接看完全没什么头绪，看着头很重！！下面只有让我们来一步一步分解它，让它原形毕露第一步让它变得看起来稍微美一点，毕竟大家都喜欢美一点的人事物， 既然有需求那肯定有解决方案，所以给大家推荐一个工具包js-beautify,可以先让代码看起来比原来漂亮很多直接执行命令(不要对他抱太大期望，美化后的不可能让你一步到位，还是要慢慢咔哧咔哧)js-beautify ./WAService.js -r\r\n复制代码美化后的代码看着花花绿绿的还是要舒心很多，但是毕竟人家是一个6万多行编译后的大物，想看明白不是一件易事，但我们还是要和它死磕来慢慢消耗它，接下里给大家介绍下个我 比较笨也是蛮傻的一种方案就是一点点有策略性的手动给他反编译过来(中间的过程只有经历后才能明白其中的痛啊)不过看到结果还是蛮欣慰的先给大家看下最终大部分解出来的编译文件如下图上面的图是通过分析代码还原的一些人看的代码，然后分类的在网上我有看到有人说通过一些工具对 WAService.js 进行格式化后进行 debug来分析，这种方式也是ok的但是有一些门槛问题，对于一些同学来说不太方便也不太能处理，因为你没有调试这些文件的运行环境，在微信开发者工具里面你是看不到WAService.js文件的更不要说去调试了，如果非要在开发者工具调试的话方法也是有的，要通过修改微信开发者工具客户端的代码才可以但是一般都不知道怎么去修改基础库代码下面介绍一个好理解但是有点痛苦的方式，比较清晰的一个操作是在上面我们让它变得美一点了，现在让它变得有条理一些，推荐使用vscode格式化后进行方法折叠这样一看其实很清晰了我们可以看到这些我们常听说的一些微信对象，WeixinJSBridge、 NativeBuffer、 wxConsole、 WeixinWorker、Reporter、VirtualDom等对象都打包一起了， 然后看到对象里面有很多个function(e,t,n)文件对应的就是每个暴露的方法，下面要做的就是把这些方法的代码手动编译过来，可以给大家一个案例演示下下图这个是VirtualDom对象文件里面的一个方法下图的是上面的代码改成我们正常人读的代码这个过程对你的js水平要有一定要求的，如果你基础不扎实和了解怎么应用的话，还原起来可能会很吃力的，如果你可以完整的编译这些文件的话，你的js水平完全可以超越大部分人可以先给大家简单分析一点非技术层面的一些疑问，具体的技术层面编译过程，可以熟悉js整个编译历史，和es6转es5的方式推荐大家熟悉下babel源码，可以有很多收获 由于本人也还比较小白（高手可以忽略这点） 大家可以看到var i=n(22)我改成了const DomIndex=require('./domIndex')这个语句语意可能很多人都可以理解，但我为什么把22这个文件写成DomIndex， 其实这里面的变量和命名和对应的文件都不是自己想当然的，这个可以在文件中进行分析得到的，具体怎么分析的这里不过多介绍了，内容就太多了有兴趣可以留言讨论使用对 WAService.js文件分析可以看出大致有 ： WeixinJSBridge、 NativeBuffer、 wxConsole、 WeixinWorker、 Reporter、 wx、 exparser、 virtualDOM 、 appServiceEngine 等对象组成的WAWebview.js文件这个大致和WAService.js文件分析方式一样，大家感兴趣的可以自行尝试下，留给大家自己研究，理解的肯定比我写出来的要深刻很多appservice.js文件这个文件分析的结果可以让我们看到一些浮出水面的东西来，但这个过程比较曲折开始 在微信小程序工具的渲染层和逻辑层里面和微信基础库都没有发现这个文件，说明可能是运行时注入进去的(猜测的)，后来在sources里面有发现这个文件但是文件是空的，页面资源和network里面都没有找到对应的文件，一时比较绝望，后来就一直瞎折腾半天后，终于在工具包里面appservice找到来这个类似文件，让生活注入了一点希望但是一打开还是这一坨不是人看的代码，但奈何不看不行啊(阿弥陀佛)通过分析研究发现，还是发现了一些蛛丝马迹，看到了这个文件里面存在webstocket和http通信方式，有通信说明就会和外界有关联，于是大胆尝试了在一些通信相关代码的地方，修改了一点代码和添加了日志标记三就是稍微在原来微信appservice.js的基础上进行了一点修改，然后保存，期待这微信开发者工具上面会有一些不一样的烟火:fireworks:，但奈何关了又开，开了又关半天屁的变化都没有，于是就产生了自我怀疑，难道不应该这样吗，但是还是感觉方向是对的，于是打算在试试终极解决方法《重启电脑》,果然当我在打开开发者工具的时候看到了不一样的烟火:fireworks:， 在console里面出现了耀眼的光芒，这里应该算一个突破性进展吧！！！看到api和返回的结果，发现这些其实就是微信提供对外的同步api,可以看到getSystemInfo走的其实是同步的方式，那微信还提供了getSystemInfoSync说明也是同步的，他们的底层实现都是同步的不知道这个api还提供这两个接口有什么意义 没理解， 然后又试了下其他微信提供的同步方法发现都会出现在这里，其他很多异步api的不会走这里都是通过webstocket走的，这里可以得出结论这些同步api请求都是通过/apihelper/assdk传输的，大家可以自己测试下拦截这个请求会发现更多内容。至于这个文件和基础库的关联和最核心的webstocket的实现和在文章开头说的案例分析和云开发小游戏架构分析相关，我打算放在下几篇《核心篇》里面来一一分享，本来打算放在一起的，但写起来才发现虽然文字不多但考虑东西太多时间要很久，如果放在一起只是大概概括的话会很快少很多省时省力，但是感觉没太大意义可能对一些想了解的同学没有太大帮助，所以我就想通过我中途的过程和遇到的问题来分析可能会好理解一些创作不易 点个赞支持一下就是动力！！欢迎感谢持续关注！！！"}
{"title": "微信小程序api封装经验", "author": "Rolan", "time": "2020-3-30 00:59", "content": "写多 之后，吸取之前的经验，瞎写了一个简单的封装api，有幸看到的朋友，就随便看看哈，如果能给到你帮助就一直棒了，额呵呵呵！新建constant.js和api.js文件　　　　  在constant.js中统一定义ip地址　　　　  api.js文件　　　对应的返回状态码要根据怎么公司的返回码的规定改了哈let CONSTANT = require('./constant')\r\n    // 从本地存储Storage中获取token值\r\nfunction getToken() {\r\n    return wx.getStorageSync(CONSTANT.TOKEN);\r\n}\r\n\r\n// 创建请求头header的内容\r\nfunction buildHeaders(isJson) {\r\n    let headers = {\r\n        \"Content-Type\": isJson ? 'application/json' : \"application/x-www-form-urlencoded\",\r\n        \"version\": CONSTANT.MINI_VERSION,\r\n    };\r\n    const token = getToken();\r\n    if (token) {\r\n        headers[\"token\"] = token;\r\n    }\r\n    return headers;\r\n}\r\n\r\n// 发起 HTTPS 网络请求。\r\nlet baseURL = CONSTANT.API_URL;\r\n\r\nfunction fetchApi(baseURL, url, params, method, isJson) {\r\n    // wx.getNetworkType判断网路类型。eg：wifi、2g、3g...;none值表示无网路\r\n    wx.getNetworkType({\r\n        success: function(res) {\r\n            // &&表示“并”\"none\" === e.networkType如果为真，才会去执行&&后面的内容，否则不执行\r\n            \"none\" === res.networkType && (wx.hideLoading(), wx.showModal({\r\n                title: \"提示\",\r\n                content: \"当前无网络，请检查网络设置后重新加载\",\r\n                showCancel: false\r\n            }));\r\n        }\r\n    });\r\n    return new Promise((resolve, reject) => {\r\n        wx.request({\r\n            url: `${baseURL}${url}`,\r\n            method: method,\r\n            header: buildHeaders(isJson),\r\n            data: params,\r\n            success: function(res) {\r\n                // 成功返回statusCode参数表示开发者服务器返回的 HTTP 状态码\r\n                // 统一拦截提示错误\r\n                // var o = res.statusCode;\r\n                // if (o !== 200 && [21020000, 41020001, 41020003, 21020002].indexOf(res.data.status) == -1) {\r\n                //     wx.hideLoading();\r\n                //     wx.showModal({\r\n                //         title: \"提示\",\r\n                //         content: res.data.msg\r\n                //     });\r\n                //     return;\r\n                // } 2020.3.9\r\n                // 41020001表示未登录那就要去拿code值\r\n                // 21020002表示登录超时\r\n                // 并重新请求获取token值\r\n                if (41020001 == res.data.status || 21020002 === res.data.status) {\r\n                    wx.login({\r\n                        success: res => {\r\n                            wx.request({\r\n                                url: baseURL + \"/api/user/login\",\r\n                                method: \"GET\",\r\n                                header: {\r\n                                    \"token\": \"\",\r\n                                    \"version\": CONSTANT.MINI_VERSION,\r\n                                },\r\n                                data: {\r\n                                    code: res.code,\r\n                                },\r\n                                success: function(res) {\r\n                                    wx.removeStorageSync(CONSTANT.TOKEN);\r\n                                    if (21020000 === res.data.status) {\r\n                                        wx.setStorageSync(CONSTANT.TOKEN, res.data.data);\r\n                                        console.log(\"already refresh token\");\r\n                                        fetchApi(url, url, params, method);\r\n                                    }\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n                // 41020003表示未授权了直接跳转到授权页（请求授权获取用户信息）\r\n                else if (41020003 == res.data.status) {\r\n                    wx.redirectTo({\r\n                        url: \"/pages/accredit/accredit\"\r\n                    });\r\n                } else {\r\n                    resolve(res.data);\r\n                }\r\n            },\r\n            fail: function(res) {\r\n                reject(res.data);\r\n                console.log(\"network fail.\", res);\r\n            },\r\n            complete: function(res) {\r\n                reject(res.data);\r\n                // console.log('complete', res);\r\n            }\r\n        });\r\n    });\r\n};\r\nmodule.exports = {\r\n    // 首页\r\n    getIndex(params) {\r\n        return fetchApi(baseURL, '/api/index', params, 'GET');\r\n    },\r\n}引用　　在需要的页面引用，也可以只引用你需要的那一个方法也行的额　　　　api.getIndex().then(res => {　　......\r\n    //那到返回值之后要执行的内容\r\n}哈哈哈，完了"}
{"title": "使用uni-app开发叮咚买菜的一些笔记（附源码）", "author": "Rolan", "time": "2020-3-31 00:05", "content": "本项目纯开源免费, 商品信息均来自网络,如有侵权,请联系作者,我会及时删除!前一段,看到一个大佬写的叮咚买菜,挺好,于是乎自己在家也琢磨了一下,自己搞了一版本,记录一些uni-app的开发事项,纯属个人总结,不对之处,还请指教!功能不是很全面,以后决定作为一个系列,持续更新一.预览:在线预览地址: http://dingdong.nodebook.top/GitHub: https://github.com/cgq001/din...管理后台: http://dingdong-admin.nodeboo...如果你觉得还凑合,给个start怎么样? 我会继续努力完善项目,争取做到前后台完整开源1.首页2.分类3.加入购物车4.收货地址5.我的二.项目简介1.vant Ui库在uni-app中使用H5版Ui库本站采用vant的H5版本(打包小程序和APP请使用vant的小程序版)UI库npm init # 初始化package.json文件\r\nnpm i vant -S # 通过npm安装vant的H5版本vant H5版本的使用(全局引入)main.jsimport Vant from 'vant';\r\n\r\nVue.use(Vant);\r\n\r\n//对vant进行注册,注意这里没有引入vant的样式文件,在main.js中 引入样式文件会报错,请在App.vue中引入App.vue<style>\r\n    @import 'vant/lib/index.css';\r\n</style>2.colorui UI库个人比较喜欢这个库炫酷的样式效果请在其官网: https://www.color-ui.com/ 下请将下载的colorui 文件夹复制到我们的项目根目录(注意 是CSS 本版的,犹豫是 H5项目,请不要复制wxss版本)然后在App.vue的style中 引入CSS文件即可三.关于uni-app中请求的简单封装1.简单封装import store from './state/index.js'  //vuex\r\n\r\n//封装request方法 无token\r\nconst request = (url, method, data) => {\r\n    var promise = new Promise((resolve, reject) => {\r\n        //提示一下\r\n        uni.showLoading({\r\n            title: '加载中...'\r\n        })\r\n        //网络请求\r\n        uni.request({\r\n            url: store.state.user.http+url, //store.state.user.http 为公共接口地址\r\n            data: data,\r\n            method: method,\r\n            header: {\r\n                \r\n            },\r\n            success: function (res) {\r\n                uni.hideLoading()\r\n                //服务器返回数据\r\n                if (res.statusCode == 200) {\r\n          \r\n                    if(res.data.code === 0 && res.data.msg){\r\n                        uni.showToast({\r\n                            title: res.data.msg,\r\n                            icon: 'success',\r\n                            duration: 2000\r\n                        })\r\n                    }else if(res.data.code != 0 && res.data.msg){\r\n                        uni.showToast({\r\n                            title: res.data.msg,\r\n                            icon: 'none',\r\n                            duration: 2000\r\n                        });\r\n                    }\r\n                    \r\n                     resolve(res);\r\n                } else {\r\n                    //返回错误提示信息\r\n                    reject(res.data);\r\n                }\r\n            },\r\n            fail: function (e) {\r\n                 uni.hideLoading()\r\n                uni.showToast({\r\n                    title: '网络连接错误',\r\n                    icon: 'loading',\r\n                    duration: 2000\r\n                });\r\n                reject('网络出错');\r\n            }\r\n        })\r\n    });\r\n    return promise;\r\n}\r\n//封装request 含token\r\nconst requests = (url, method, data={}) => {\r\n    var promise = new Promise((resolve, reject) => {\r\n        //提示一下  loading动画 可根据需要开启\r\n        // uni.showLoading({\r\n        //     title: '加载中...'\r\n        // })\r\n        //console.log(store.state.user.token)  // 这里是从vuex中获取token信息,来判断是否登陆\r\n        if(!store.state.user.token || store.state.user.token === null ){\r\n            uni.navigateTo({\r\n                url: '/pages/login/login'\r\n            });\r\n            \r\n            return false;\r\n        }\r\n        //网络请求\r\n        uni.request({\r\n            url: store.state.user.http+url, //store.state.user.http 为公共接口地址\r\n            data: data,\r\n            header:{\r\n                \"Authorization\":store.state.user.token  //'Bearer '+\r\n            },\r\n            method: method,\r\n            success: function (res) {\r\n                uni.hideLoading()\r\n                //服务器返回数据\r\n                if (res.statusCode == 200) {\r\n                    if(res.data.code === 400){\r\n                        uni.navigateTo({\r\n                            url: '/pages/login/login'\r\n                        });\r\n                        \r\n                        return false;\r\n                    }\r\n                    //根据code码 判断 和 msg提示文字 做出响应的提示\r\n                    if(res.data.code === 0 && res.data.msg){\r\n                        uni.showToast({\r\n                            title: res.data.msg,\r\n                            icon: 'success',\r\n                            duration: 2000\r\n                        })\r\n                    }else if(res.data.code != 0 && res.data.msg){\r\n                        uni.showToast({\r\n                            title: res.data.msg,\r\n                            icon: 'none',\r\n                            duration: 2000\r\n                        });\r\n                    }\r\n                    \r\n                     resolve(res);\r\n                } else {\r\n                    \r\n                    console.log(\"请求错误\")\r\n                    //返回错误提示信息\r\n                    reject(res.data);\r\n                }\r\n                \r\n            },\r\n            fail: function (e) {\r\n                \r\n                 uni.hideLoading()\r\n                uni.showToast({\r\n                    title: '网络连接错误',\r\n                    icon: 'loading',\r\n                    duration: 2000\r\n                });\r\n                reject('网络出错');\r\n            }\r\n        })\r\n    });\r\n    return promise;\r\n}\r\n//这里导出两个 请求 一个包含Token  一个包含token  请选择使用\r\nmodule.exports = {\r\n    request:request,\r\n    requests:requests\r\n}2.挂载import Vue from 'vue'\r\nimport App from './App'\r\nimport store from './static/state/index.js'\r\nVue.config.productionTip = false\r\n\r\n//引入封装的 请求文件\r\nconst https = require('./static/http.js')\r\n//挂载到Vue实例\r\n//无token请求\r\nVue.prototype.http = https.request\r\n//含token请求\r\nVue.prototype.https = https.requests\r\n\r\nimport Vant from 'vant';\r\n\r\nVue.use(Vant);\r\n\r\nApp.mpType = 'app'\r\n\r\nconst app = new Vue({\r\n    store,\r\n    ...App\r\n})\r\napp.$mount()3.使用//this.https 表示含Token的请求\r\n//this.http  表示不含token的请求\r\n\r\nthis.https('index/addOrder','post',src) //(请求地址,请求类型,数据)\r\n    .then(res=>{    \r\n       \r\n    })\r\n    .catch(err=>{"}
{"title": "微信小程序的「同层渲染」踩坑记", "author": "Rolan", "time": "2020-4-1 00:06", "content": "背景\r\n近期在开发小程序中，接触最多的就是 canvas 了，期间又因为兼容性的问题，又经历了底层 API 的新旧版的替换，踩的坑可谓令人印象深刻。小程序（微信）的 canvas 与 HTML 标准的 canvas 有较大区别，就连小程序本身的 canvas 底层 API 都有两个大版本的区别（其实远古时期还有一个版本，但年代过于久远就不做考究了）。目前现存的两个版本的区别在于是否支持「同层渲染」。\r\n同层渲染\r\n小程序的内容大多是渲染在 WebView 上的，如果把 WebView 看成单独的一层，那么由系统自带的这些原生组件则位于另一个更高的层级（如 canvas、video）。两个层级是完全独立的，因此无法简单地通过使用 z-index 控制原生组件和非原生组件之间的相对层级。想要在原生组件之上只能用 cover-view 和 cover-image 来实现。但  cover-view 和 cover-image 支持的 css 样式是在很有限，而且经过实践来看，cover-view 在安卓部分机器上性能真的很差。\r\n\r\n「同层渲染」则是将原生组件直接渲染到 WebView 层级上，就可以通过简单的 z-index 来控制层级，而且支持的 css 非常丰富，麻麻再也不用担心我碰到的层级问题了！是不是看起来很美好？然而现实非常残酷。\r\n\r\n「同层渲染」存在的问题\r\n首先，根据小程序官方的文章来看，几乎是重构了整个「原生组件」，使用方式和支持的特性与之前的区别都非常大，非常类似标准的 canvas API，甚至官方声称「支持标准 canvas 的大部分属性方法」。但是根据我的实际项目经验来看，新版 canvas API 仅仅只是在 iOS 上表现良好，在部分安卓机器上会出现许多怪异行为。一个简单的例子是绘制多个相同的形状时，画笔似乎会出现在「飘忽不定」的位置上，导致绘制最终结果无法预测。另外很让人头疼的一个地方在于 drawImage 方法上。旧版 API drawImage 第一个参数是图片路径，本地路径或网络路径皆可，但新版 API  drawImage 第一个参数必须是图片实例，由于小程序无法获取 DOM 元素，只能用官方提供的 createImage 方法创建图片实例，在其 onLoad 回调中再次调用 drawImage，才能实现原先简单的方法。诸如此类。但这些都是可以克服的，最终导致我们放弃的原因是其在部分安卓机器上的「不确定性」，如果在「新特性」和「兼容性」上做选择，我想我还是坚持选择「兼容性」吧。就好像「优雅降级」和「渐进增强」，我更倾向于后者。\r\n「兼容性」下的「同层渲染」\r\n我相信大多数做过小程序 canvas 相关都有层级的烦恼。既然无法使用新版 API 来实现，那问题总要解决，最终我们想出了一套在旧版 API 也可以实现类似「同层渲染」的效果。目前需要「同层渲染」的场景基本上都是需要在 canvas 上弹层，所以在覆盖 canvas 的时候不会同时操作 canvas，因为可以利用canvasToTempFilePath 可以临时将  canvas 转成图片，然后隐藏 canvas，显示 tempImage 即可。\r\n黎明的曙光\r\n新版 canvas API 并不是一无是处，有一个很大的变化在于它不再使用物理尺寸来绘制，使用的是实际尺寸。这就会使得使用新版 API 绘制的结果比原来高清许多，这算是为数不多的优点吧。另外新版 canvas API 在 iOS 上表现还是很不错的。希望未来官方可以让新版 canvas API 兼容性更优秀，让开发者早日摆脱这些临时方案。"}
{"title": "功能完善的小程序日历组件", "author": "Rolan", "time": "2020-4-1 00:21", "content": "小程序日历组件\r\n日历组件，表单组件绝逼是前端开发的一个噩梦，尤其要做好一个旅游项目的日历，变态需求特别多，要在小程序中实现携程app的日历，还要兼顾性能问题。\r\n\r\n\r\n自定义横向/纵向日历\r\n自定义区间大小\r\n自定义日期内容\r\n指定节假日\r\n支持跨月显示\r\n\r\n难点\r\n\r\n懒加载保证渲染性能\r\n通过配置实现纵向日历和横向日历\r\n阳历节日与农历节日与节气\r\n交互，尤其是区域选择的交互\r\n\r\n\r\n示例代码\r\nhttps://github.com/webkixi/aotoo-xquery \r\n=> pages/calendar    \r\n复制代码\r\n配置说明\r\nwxml\r\n<ui-calendar dataSource=\"{{config}}\" />\r\n复制代码\r\njs\r\n基本用法\r\nconst Pager = require('../../components/aotoo/core/index')\r\nPager({\r\n  data: {\r\n    config: {\r\n      $$id: 'calendar',\r\n      mode: 1,  // 纵向日历\r\n      type: 'range',  // 区域选择\r\n      tap: 'onTap', // page响应事件\r\n      total: 365, // 定义从今天开始一年事件\r\n      rangeCount: 28,  // 区选区间28天\r\n      festival: true, // 开启节假日显示\r\n      value: ['2019-12-24', '2020-01-05'],  // 默认值\r\n      methods: { \r\n        // 响应 tap事件\r\n        onTap(e, param, inst) {\r\n          if (param.range === 'start') {\r\n            inst.update({dot: [{title: '入住'}]})\r\n          }\r\n          if (param.range === 'end') {\r\n            inst.update({dot: [{title: '离店'}]})\r\n            setTimeout(() => {\r\n              Pager.alert('离店，跳回页面')\r\n            }, 1000);\r\n          }\r\n          console.log(param);\r\n        }\r\n      }\r\n    }\r\n  }\r\n})\r\n复制代码\r\n$$id\r\n{String} 配置实例的Id\r\nmode\r\n{Number} 设置日历的展示模式，1=纵向日历 2=横向日历\r\ntype\r\n{Number} single=单选日历， range=选择区间， multiple=多选日历\r\ntotal\r\n{Number} 设置日历从今天开始起需要跨多少天，如 180天，或者365天\r\nstart\r\n{String} 设置起始日期，如：'2020-06-05'\r\ndate\r\n{Object|Function} 定义附加日期内容\r\ndisable\r\n{Boolean} 设置全局无效，所有日期均不能交互，权重低于单个日期设置的disable\r\nrangeCount\r\n{Number} 当type === 'range'时，rangeCount为区间大小，意味着区间允许选择多少天\r\nrangeMode\r\n{Number} 当正在做日期区间选择时，是否允许显示angeCount之外的日期 1=显示， 2=不显示\r\ntap\r\n{String} 响应日期元素的tap事件\r\nvalue\r\n{Array} 默认选中的日期，允许数组为空，如果type='single'则应该设置如['2020-06-05']，type='range'应该设置如['2020-06-03', '2020-06-05'], type='multiple'时，数组允许多值\r\ndata\r\n{Array} 该数据会自动计算日期跨度数量(允许跨年设置)，如果设置了该数据，则total无效，如设置为['2019-11-05', '2021-11-05']，自动计算日期为730天\r\nfestival\r\n{Boolean|Array} 设置日历假期显示，支持显示指定假期\r\ntoolbox\r\n{Object} 日历的扩展配置，允许设置一些高级功能，如日历是否允许跨月，特殊的range算法等等\r\ntoolbox.header\r\n{Boolean} 是否显示日历的头部，一般用于横向日历时为true\r\ntoolbox.monthHeader\r\n{Boolean} 是否显示日历的月头部，一般在纵向日历时为true\r\ntoolbox.rangeEdge\r\n{Function} 默认值null，type='range'时，自定义range选择算法\r\ntoolbox.discontinue\r\n{Boolean} 默认false，当日历有data数组构建时，缺少数据的月份会被忽略\r\n如何设置\r\n设置横向、纵向日历\r\nlet calenderConfig = {\r\n  $$id: 'calendar',\r\n  mode: 2, // 1，纵向日历 2，横向日历\r\n  type: 'single', // single：单选  range: 区间选择  multiple：多选\r\n  tap: 'onTap', // 回调事件\r\n  total: 180, // 所有日期选择天数\r\n  methods: { // 响应方法\r\n    onTap(e, param, inst) {\r\n      console.log(param);\r\n    }\r\n  }\r\n}\r\n复制代码设置区间选择日历\r\n该示例配置为仿携程的功能设置\r\nlet calendarConfig = {\r\n  $$id: 'calendar',  //实例id\r\n  mode: 1,  // 纵向日历\r\n  type: 'range',  // 区间选择日历\r\n  tap: 'onTap', // tap响应方法\r\n  total: 365,  // 指定日历从今天开始总天数\r\n  rangeCount: 28, // 区间范围\r\n  rangeMode: 1, // 区间选择是否隐藏非区间的月份\r\n  festival: true, // 是否显示节假日\r\n  value: ['2020-04-03', '2020-04-09'],  // 默认值\r\n  methods: { \r\n    // 定义响应方法  \r\n    onTap(e, param, inst) {\r\n      \r\n      if (param.range === 'start') {  // 第一次点击时\r\n        inst.update({dot: [{title: '入住'}]})\r\n      }\r\n      if (param.range === 'end') { // 第二次点击时\r\n        inst.update({dot: [{title: '离店'}]})\r\n      }\r\n      console.log(param);\r\n    }\r\n  }\r\n}\r\n复制代码设置多选日历\r\n支持选中多个日期\r\nlet calenderConfig = {\r\n  $$id: 'calendar',\r\n  mode: 2,\r\n  type: 'multiple', // single：单选  range: 区间选择  multiple：多选\r\n  tap: 'onTap', // 回调事件\r\n  total: 180, // 所有日期选择天数\r\n  value: ['2020-04-03', '2020-04-09', '2020-04-10'],\r\n  methods: { // 响应方法\r\n    onTap(e, param, inst) {\r\n      console.log(param);\r\n    }\r\n  }\r\n}\r\n复制代码据已知日期自动构建\r\n此例中total无效，由两个给定的日期构建了三个月的日历\r\nlet calenderConfig = {\r\n  $$id: 'calendar',\r\n  mode: 2, // 1，纵向日历 2，横向日历\r\n  type: 'single', // single：单选  range: 区间选择  multiple：多选\r\n  tap: 'onTap', // 回调事件\r\n  total: 180, // 所有日期选择天数，此例中无效  \r\n  data: [{\"date\":\"2020-04-03\"}, {\"date\":\"2020-06-03\"}],\r\n  methods: { // 响应方法\r\n    onTap(e, param, inst) {\r\n      console.log(param);\r\n    }\r\n  }\r\n},\r\n复制代码根据已知日期自动构建，忽略无数据月份\r\n此例中total无效， 由两个给定的日期构建了三个月的日历\r\nlet calenderConfig = {\r\n  $$id: 'calendar',\r\n  mode: 2, // 1，纵向日历 2，横向日历\r\n  type: 'single', // single：单选  range: 区间选择  multiple：多选\r\n  tap: 'onTap', // 回调事件\r\n  total: 180, // 所有日期选择天数，此例中无效\r\n  data: [{\"date\":\"2020-04-03\"}, {\"date\":\"2020-06-03\"}],\r\n  toolbox: {\r\n    discontinue: true // 允许构建跨月日历\r\n  },\r\n  methods: { // 响应方法\r\n    onTap(e, param, inst) {\r\n      console.log(param);\r\n    }\r\n  }\r\n},\r\n复制代码构建节假日日历\r\n允许指定节假日，指定节假日内容\r\n\r\n\r\nfestival: true\r\n显示所有组件自带节日\r\n\r\n\r\nfestival: ['元旦节', '情人节', '劳动节', '冬至']\r\n显示指定假日\r\n\r\n\r\nfestival: [{title: '春节', content: {dot: ['新年好']}}]\r\n显示指定节日，并附加内容\r\n\r\n\r\nlet calenderConfig = {\r\n  $$id: 'calendar',\r\n  mode: 1, // 1，纵向日历 2，横向日历\r\n  type: 'single', // single：单选  range: 区间选择  multiple：多选\r\n  tap: 'onTap', // 回调事件\r\n  data: [{\"date\":\"2020-09-03\"}, {\"date\":\"2020-12-28\"}],\r\n  festival: ['教师节', '圣诞节'],\r\n  toolbox: {\r\n    discontinue: true // 允许忽略无数据月份\r\n  },\r\n  methods: { // 响应方法\r\n    onTap(e, param, inst) {\r\n      console.log(param);\r\n    }\r\n  }\r\n},\r\n复制代码自定义日期内容\r\n自定义日期内容有两种方法\r\n\r\n\r\n在data数据配置中加入'dot'数组属性\r\nconfig.data = [{date: '2020-03-03', content: {dot: ['内容']}}]\r\n\r\n\r\n在date属性中配置\r\n\r\n\r\n// 配置所有日期的附加内容   \r\nconfig.date = {dot: ['自定义内容']}  \r\n\r\n// 指定日期内容配置   \r\nconfig.date = function(param){\r\n  // 通过param的属性写逻辑 param.date, param.year, param.month, param.day ...\r\n  if (param.date === '2020-8-13') {\r\n    param.dot = ['附加内容']\r\n    return param\r\n  }\r\n}\r\n复制代码设置示例\r\nlet calenderConfig = {\r\n  $$id: 'calendar',\r\n  mode: 2, // 1，纵向日历 2，横向日历\r\n  type: 'single', // single：单选  range: 区间选择  multiple：多选\r\n  tap: 'onTap', // 回调事件\r\n  date: function(param){\r\n    if (param.month === 12 && param.day === 26) {\r\n      param.dot = ['毛主席诞辰']\r\n      return param\r\n    }\r\n    if (param.month === 9 && param.day === 10) {\r\n      param.dot = [\r\n        {title: '生日', itemStyle: 'font-size: 11px; color: blue;'},\r\n        {title: '骗你的', itemStyle: 'font-size: 11px; color: #666'},\r\n      ]\r\n      return param\r\n    }\r\n    if (param.month === 9 && param.day === 20) {\r\n      param.dot = [\r\n        {title: '无效日期', itemStyle: 'font-size: 12px; color: red;'},\r\n        {title: '不能交互', itemStyle: 'font-size: 12px; color: #666;'},\r\n      ]\r\n      param.disable = true\r\n      return param\r\n    }\r\n  },\r\n  toolbox: {\r\n    discontinue: true\r\n  },\r\n  data: [{\"date\":\"2020-09-03\"}, {\"date\":\"2020-12-28\"}],\r\n  methods: { // 响应方法\r\n    onTap(e, param, inst) {\r\n      console.log(param);\r\n    }\r\n  }\r\n},\r\n复制代码GITHUB源码\r\n示例小程序"}
{"title": "dev环境测试动态小程序码", "author": "Rolan", "time": "2020-4-2 00:32", "content": "背景\r\n动态带参小程序二维码生成后如何在dev环境进行测试成为了很多人的疑惑，那么如何通过技术解决这个问题呢？接下来小编带大家来解决这个问题。\r\n解决思路\r\n\r\n使用测试版本小程序码，修改默认路径为二维码要进入路径，加入路径参数\r\n通过增加自己小程序扫码能力，重新定义扫码\r\n\r\n详细方案\r\n\r\n\r\n使用测试版本小程序码，修改默认路径为二维码要进入路径，加入路径参数\r\n我们可以借助微信开发的能力进行测试码生成，将路径改写成我们想扫码进入的path + params的模式,这样我们在使用微信扫码就会直接跳转到我们的测试小程序，并且拿到我们的参数。\r\n\r\n\r\n通过增加自己小程序扫码能力，重新定义扫码\r\n\r\n思路分析\r\ndemo展现\r\n\r\n\r\n\r\n\r\n总结\r\n微信只支持线上小程序动态二维码生成，那么通过以上两种方式我们就可以成功进行dev环境的测试，解决了我们测试的难题。\r\n相关链接\r\n\r\n示例代码地址\r\n服务端小程序二维码生成\r\nwepy+weui+redux实现小程序脚手架\r\n玩转微信小程序的位置授权\r\n如何玩转小程序登录体系"}
{"title": "微信小程序开发教程第五章：名片夹详情页开发", "author": "admin", "time": "2016-10-12 22:39", "content": "先看下「名片盒」详情页的效果图：备注下大致需求：顶部背后是轮播图，二维码按钮弹出模态框信息、点击微信栏、点击存入手机，地址栏需要地图展示，名片分享也是模态框指引。首先是轮播图，autoplay 自动播放，interval 轮播的时间，duration 切换速度，可以根据自己需求去添加。Delete：是删除按钮，加载进来是隐藏的，需用户点轮播图进去后，轮播图全屏显示才出来。noClickImg 与 ClickImg：切换全屏与非全屏轮播图，绑定了点击事件 changeClick 来切换，只是改变样式即可。Block：图片列表。Number_img：当前轮播 index（currentNumber），与图片 length 集合（cardnum）。其中 currentNumber：//轮播图发生改变时改变数字//初始化数据Data:{currentNumber:1}slidechange:function(e){var number = e.detail.current;this.setData({currentNumber:number+1})},这里可以看到全屏状态下当关闭按钮被点击后 getBackStyle，把 changeClick 切换到 imgFullScrenn 待命。再次点击返回原样式，切换后事件又走回到 getBackStyle 了，灵活运用。刷新下开发者工具可以看到具体效果如下：详情页可以看到信息基本都是样式一样，可以使用微信提供的循环 block。下面是详情页里面的个人信息数据，如果有信息就显示出来，没有数据的不显示，这里使用//中文信息               var chinaMessage = res.card.groups[0].fields;var personMessage= []               for(var i = 0;i                personMessage.push(chinaMessage[i])               }               //为空或者null是不显示判断              for(var k in personMessage){                if(personMessage[k].value==null || personMessage[k].value==\"\"){                personMessage[k][\"display\"] = \"none\";                }else{                personMessage[k][\"display\"] = \"block\";                }               }具体以 json 数据格式来处理，我们需要做的就是给它绑定 display 的值，然后我们调用即可。微信此版本的 setData 不支持异步更新数据，故而我们在发生真实网络数据请求时一定要在后面加上 forceUpdata()，强制触发视图渲染，否则会出现很多莫名其妙的 bug。这里说明下：如是服务器真实数据。可以看到会报错，可能是 js 的执行顺序，依次往下走，此时网络数据还在请求中。定义一个变量即可。当然这里的数据都是 push 上来的。以下是二维码弹出信息。这是弹出模态框二维码信息，布好局初始化是none状态。那里需要它直接绑定数据即可：This.setData({//模态框名字:”显示？隐藏”})方法是让它显示。需要用他的地方调用方法即可。(支持重复调用)详情页公司位置地图直接调用微信提供的接口实现（群里的 demo 有实现方式）。可以看下实现的效果："}
{"title": "微信小程序开发教程第六章：「名片盒」「我」的页面开发", "author": "admin", "time": "2016-10-12 22:46", "content": "效果图与需求：用户有多张名片，需要左右切换查看，往下切换是菜单按钮。这里需求两处滑动，用到了微信提供给我们的滑动组件 swiper，并且进行了嵌套使用，第一层是名片展示与菜单按钮的上下滑动，第二层是名片展示的左右滑动（支持互相嵌套使用的，可以放心使用）。Vertical 加上就是纵向滑动，去掉即是左右滑动。整体结构如下所示：点击事件绑定的是数据切换方式，因为需要支持多次点击切换。初始化数据是 nextSlide：再看下 nextSlide 事件。currentSlide 是当前页面的 index，改变它即可完成切换效果，可以看上图初始化数据时设置了 cs 是 0。因而赋值当前 data.cs+1 即可，再把绑定点击事件 clickNext 切换成 nextSlideAgain。再看下 nextSlideAgain 事件，执行的减去 1 个索引，实现多次点击切换效果。具体效果可以看到。点击个人名片进去编辑名片页面，由于需要带参，故而使用的是 wx.navgateTo。可以看下效果：最后上点干货：我们发出第一篇教程的时候有人就注意到这点了，怎么做真实数据交互，下面大家可以了解下。首先进去是 MD5 加密，requster 交互层。怎么引用 MD5.js？当然是模块化 require，被引用的 js 不要忘记 module.exports 出来。下面是 requester.js 引用 MD5.js。ApplicationRoot 是服务器地址（配置服务器时在开发设置页面查看 AppID 和 AppSecret，配置服务器域名）。Require.js 这里 module.exports 是暴露方法出去。这时候在全局 app.js 里面引入 require.js 映射到全局 global，这个 global 是全局的。这时候那个页面需要那个页面就直接去接受吧，模块化是不是很好用？可以完整的看下与后台做数据交互的一个请求实现方式如下：图一是 requester.js 里面的封装。图二是需要调用数据的页面渲染。"}
{"title": "解决 uni-app 微信小程序项目中腾讯统计 mta 不上报数据的问题", "author": "Rolan", "time": "2020-5-26 00:31", "content": "# 解决 uni-app 微信小程序项目中腾讯统计 mta 不上报数据的问题\r\n\r\n在 `uni-app` 微信小程序项目开发中，发现腾讯统计 `mta` 不上报数据。\r\n\r\n## 1. 原因\r\n\r\n1. `uni-app` 框架与 `mta` 组件都对原生的 `Page` 对象进行了重写，在 `onLoad` 生命周期函数中上报数据，这一点开发者无感知\r\n2. 因为 `uni-app` 框架会首先加载自身框架脚本，导致 `mta` 后加载的脚本对 `Page` 对象重写无效（两者冲突）\r\n3. 所以，`mta` 组件中设置了 `\"autoReport\": true` 会导致数据不上报（`\"autoReport\": false` 配置不受影响，因为不需要重写 `Page`）\r\n\r\n`uni-app 框架脚本重写 Page`:var MPPage = Page;Page = function Page() {var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};initHook('onLoad', options);return MPPage(options);};mta-wechat-analysis.js 重写 Page`:function initOnload() {var a = Page;Page = function (b) {var c = b.onLoad;\r\nb.onLoad = function (a) {\r\n  c && c.call(this, a);\r\n  MTA.Data.lastPageQuery = MTA.Data.pageQuery;\r\n  MTA.Data.pageQuery = a;\r\n  MTA.Data.lastPageUrl = MTA.Data.pageUrl;\r\n  MTA.Data.pageUrl = getPagePath();\r\n  MTA.Data.show = !1;\r\n  MTA.Page.init()\r\n};\r\na(b)}}按理说，前后两次对 `Page` 进行重写，应该是不冲突、都有效的，但 `uni-app` 在对 Vue 组件转微信小程序原生组件时，使用了局部封装的函数，导致后面其他脚本对 `Page` 的重写无效function createPage(vuePageOptions) {return Component(parsePage(vuePageOptions));}## 2. 解决\r\n\r\n有两个解决方案：\r\n\r\n1. 把 `mta-wechat-analysis.js` 脚本放到 `uni-app` 框架脚本之前加载，但官方并没有提供这个功能，所以放弃这个方法\r\n2. 重写 Vue 组件，在 Vue 组件里上报统计数据\r\n\r\n因为 Vue 组件是不能重写生命周期函数的，所以只能重写调用生命周期函数的方法 `Vue.prototype.__call_hook`：\r\n\r\n`mta-wechat-analysis.js`:function initOnload() {var a = Page;Page = function (b) {var c = b.onLoad;b.onLoad = function (a) {c && c.call(this, a);MTA.Data.lastPageQuery = MTA.Data.pageQuery;MTA.Data.pageQuery = a;MTA.Data.lastPageUrl = MTA.Data.pageUrl;MTA.Data.pageUrl = getPagePath();MTA.Data.show = !1;MTA.Page.init()};a(b)import Vue from 'vue';+function initOnload() {// 重写 Vue.prototype.__call_hook 方法Vue.prototype.__call_hook_proxy = Vue.prototype.__call_hook;Vue.prototype.__call_hook = function(hook, args) {if (hook === 'onLoad') {MTA.Data.lastPageQuery = MTA.Data.pageQuery;MTA.Data.pageQuery = args;MTA.Data.lastPageUrl = MTA.Data.pageUrl;MTA.Data.pageUrl = getPagePath();MTA.Data.show = !1;MTA.Page.init();this.__call_hook_proxy(hook, args);};改写后的 [mta-wechat-analysis.js](https://github.com/senntyou/blogs/blob/master/resources/mta-wechat-analysis.js) 脚本可以[点这里下载](https://github.com/senntyou/blogs/blob/master/resources/mta-wechat-analysis.js)。\r\n\r\n## 后续\r\n\r\n更多博客，查看 [https://github.com/senntyou/blogs](https://github.com/senntyou/blogs)\r\n\r\n作者：[深予之 (@senntyou)](https://github.com/senntyou)\r\n\r\n版权声明：自由转载-非商用-非衍生-保持署名（[创意共享 3.0 许可证](https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh)）"}
{"title": "小程序运行机制以及相关知识点", "author": "Rolan", "time": "2020-5-27 00:09", "content": "可能今天在很多人眼中，小程序已经成为别人印象中的app，功能齐全，且可以完成各种功能以及业务。但是个人从小程序的诞生使用至今，在我眼中他依然是个轻量级应用，虽逐步的壮大，一些功能还是有所限制，但是从功能上的角度却无法与app相媲美。以微信小程序为例，也许今天大小限制8M，页面栈已经是15层，大小可开发约50~70个页面，的确已经很好的支持业务的开发以及功能的扩张。但是在小程序开始之初，页面栈仅为5，包大小限制1M，很多业务的确无法扩展。小程序也因业务的扩展，逐步逐渐支持工程化，如当前支持npm包。但我们从小程序的产品整体设计上，还是不能忘记这个限制，无止境的叠加页面以及业务。小程序的编译原理简单的借助大神的思路，描述一下小程序的编译原理。 我们都知道，小程序页面由View（视图层）,App Service(逻辑层)组成。它们在两个线程中运行（我们传统的h5,是单线程运行）。他们之间是由系统的JSBridage（常用于原生与h5交互的工具，可自行百度）进行交互的。视图层使用 WebView 渲染，iOS 中使用自带 WKWebView，在 Android 使用腾讯的 x5 内核（基于 Blink）运行。 逻辑层使用在 iOS 中使用自带的 JSCore 运行，在 Android 中使用腾讯的 x5 内核（基于 Blink）运行。以上原理借鉴来自大神yck。看到这里，是否明白，为什么小程序不支持直接获取dom跟bom了吧？因为不像h5在同一个层级，在逻辑层时间上压根没有dom，只有通过官方的写法，通过系统层去操作dom。小程序的常用第三方框架原生官方概念：官方自带笔者观点：只有原生代码，才能在对应的小程序环境跑起来。任何第三方框架，都是经过自己的bable编译成原生支持代码才能运行。因此，在不考虑多端的情况下，强烈推荐使用原生，这样可以绕过第三方的坑。Taro官方概念:官方命名解释为多端统一开发解决方案。京东研发笔者观点：这在多端中的需求中，相比原生的优势。此外，个人实践的应用中，taro是个人觉得为数不多兼容性较好的，坑相对较少。此外，官方还提供了taro-ui，ui从性能还有从外观，个人都是觉得写得非常的不错。 此外，他是利用React的方式开发小程序的框架。 使用 React的方式开发小程序的框架，同时支持生成多端应用，此外还支持转换rn等，如果同一项目需求有多个终端的要求。可以建议使用。kbone官方概念：Web 与小程序同构解决方案，腾讯研发。曾有这么一句话：kbone，十分钟让 Vue 项目同时支持小程序笔者观点：如果有当前vue项目，急需支持微信小程序的话，可以考虑。这是一个求快不求精的选择。为腾讯官方出品，但是时间上的沉淀并不长，坑位估计不会少。有兴趣继续深入可查看： wechat-miniprogram.github.io/kbone/docs/…mpvue官方概念：基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系笔者观点：小程序第三方中较早起家的框架。这是曾经vue开发者非常喜欢的框架，无成本的从vue的开发者，成为小程序开发者。植入了很多vue的概念，重写了babel，支持vuex，vue常用api等。不过貌似已经停止迭代了，使用慎重。uni-app官方概念：使用 Vue 语法开发小程序、H5、App的统一框架笔者观点：历史悠长，从hridyapp的时代就有了uni至今。将微信的api二次讽刺，用自己的uni-对象替换了wx对应去转移成对应的api。目前还是有部分使用者，部分培训机构也有提到（毕竟培训的都是重点）。WePY官方概念：支持组件化的小程序开发框架，腾讯原生框架笔者观点：只是略有了解，身边以及个人无人使用，不评论。chameleon官方概念：一套代码运行多端，一端所见即多端所见，滴滴研发笔者观点：同上。megalo官方概念：基于 Vue 的小程序开发框架，网易考拉研发笔者观点：同上。小程序如何工程化我们都知道，当前前端项目都有自己的脚手架，可随时更改自己的编译，如create-react-app，vue-cli等都自带webpack。而小程序的编译器属于内置编译器，我们没法对进行编译处理，当我们需要对整个项目进行编译或者工程化处理的时候，就会遇到瓶颈。这时候我们只能考虑自己嵌入工程化。实际上，今天的小程序工程化的意义不是特别大。我们曾经有很多需要工程化小程序的需要，比如：支持npm包，支持es7，支持代码压缩，支持自定义指令，支持typescript等。但是，小程序在长达几年的迭代中，也逐步支持着一些（但是总是慢前端架构一段很长的时间，比如es7到2019年才支持，前端早几年就可以用）那当前工程化可以解决什么问题呢？1)我们前端框架是否都用了css预处理。如less，sass。小程序由于自身定位是一个“小”项目，所以，官方可能认为不需要。但是我们实际业务中，或者手写代码的习惯，都习惯了less或者sass。2)植入eslint 等代码检查工具可能当前从这两个角度出发意义不大。但是，就跟上边所说，如再有什么新的技能点，是否还是要慢个几拍等官方支持？我们可提前做好准备。使用gulp支持多页面打包到对应的位置，相信对前端来说不是很困难吧？晚点可上传demo。小程序特别说明尺寸单位换算rpx换算px (屏幕宽度/750)\r\npx换算rpx (750/屏幕宽度)\r\n复制代码小程序bug转发（分享）小程序不能拿到成功结果\r\n复制代码小程序优化建议代码压缩，分包加载，控制图片源文件，首屏优化。\r\n复制代码小程序官方优势（相比web）1.支持服务通知推送。\r\n2.支持缓存数据推送。\r\n3.开放能力\r\n4.支持云端开发\r\n5.无需考虑兼容性\r\n6.成本较低，体验较好（相比web）\r\n复制代码"}
{"title": "使用矢量字体自定义小程序 icon 组件图标", "author": "Rolan", "time": "2020-5-27 00:10", "content": "一个问题微信小程序中的 icon 组件只有 9 种类型 success、success_no_circle、info、warn、waiting、cancel、download、search、clear。具体可以参考 icon 组件官方文档。一个想法我们往往希望不受上述 9 种图标的限制，拓展 icon 组件的图标。这就涉及到如何自定义图标的问题。自定义图标有多种方法，比如使用图片、精灵图、CSS 样式绘制、SVG 矢量文件等方法。本文着重介绍如何使用矢量字体自定义小程序的 icon 组件图标。一个概念什么是矢量字体？字体包括点阵字体和矢量字体。矢量字体目前用的比较广泛，分为三类：Adobe 的 Type1、Apple 和 Microsoft 主导的 TrueType、Adobe Apple Microsoft 共同主导的开源字体 OpenType。对于矢量字体，每个 Unicode 是编码的索引，每个字符的描述信息是一个几何矢量绘图描述信息。矢量字体是实时绘制出来的，所以可以实时填充任何颜色，可以无级缩放而没有锯齿。要使用矢量字体，就要涉及到一个非常有用的网站：Iconfont-阿里巴巴矢量图标库。这个网站不仅提供图标下载，还提供自定义矢量图标的生成和下载。接下来我会结合丰富的截图来一步步看如何使用矢量字体自定义小程序 icon 组件图标。一个实践获取矢量图标打开 Iconfont-阿里巴巴矢量图标库 网站，其首页如下图：网站首页因为这里我们不关心图标长什么样子，只关心如何一步步的从矢量图标生成到微信小程序代码来自定义 icon 组件图标。所以我们直接选择第一个图标合集，点击后如下图。QH 徐小花图标库然后点击第一个图标库，其详情如下。这里我们把鼠标放到第三个图标——咖啡豆图标上面，会出现三个按钮，分别是加入购物车、收藏、下载。我们需要点击加入购物车按钮。QH 徐小花的茶与咖啡图标库此时右上角的购物会有红色的角标，点击一下右上角的按钮出现以下界面。购物车然后我们点击“添加至项目”按钮，会弹出以下界面。如果没有项目就新建一个，如果有的话直接选择一个你认为合适的界面即可。这里我提前新建了 Test 项目，直接选择 Test 项目。加入项目添加项目后，网页会自动跳转到项目详情界面。此界面包含了刚刚添加进来的图标。项目详情页面此时我们点击中间的“查看在线链接”按钮，会生成一系列代码，并在网页中间显示。此时我们在 iconfont.cn 的任务就已经完成，我们已经拿到了我们想要的图标远程链接和 Unicode 值。其中刚刚生成的代码就是图标的远程链接，咖啡豆图标下边的  字样就是图标对应的 Unicode 值。这两个内容在下边编写微信小程序代码时会用到。生成在线代码微信小程序代码编写微信小程序的代码编写就比较容易了，首先编写 WXSS 文件，将刚刚拿到的远程字体链接直接粘贴到 WXSS 中，然后编写自定义的 iconfont 样式，最后在 icon 组件中引用即可。其代码如下：WXSS 代码其中要注意的是，在 iconfont 中复制的 font-face 代码是直接粘贴到 WXSS 中的。咖啡豆图片的 Unicode  把前边的 &#x 转为 \\ 即可，然后将其放到 icon-coffee 的 content 中。@font-face {  font-family: 'iconfont';  /* project id 1834535 */  src: url('//at.alicdn.com/t/font_1834535_c5751gpcjt.eot');  src: url('//at.alicdn.com/t/font_1834535_c5751gpcjt.eot?#iefix') format('embedded-opentype'),  url('//at.alicdn.com/t/font_1834535_c5751gpcjt.woff2') format('woff2'),  url('//at.alicdn.com/t/font_1834535_c5751gpcjt.woff') format('woff'),  url('//at.alicdn.com/t/font_1834535_c5751gpcjt.ttf') format('truetype'),  url('//at.alicdn.com/t/font_1834535_c5751gpcjt.svg#iconfont') format('svg');}.iconfont {  font-family: \"iconfont\" !important;  font-size: 16px;  font-style: normal;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;}.icon-coffee:before {  content: \"\\e634\";  color: darkgoldenrod;  font-size: 70px;}WXML 代码<icon class=\"iconfont icon-coffee\"></icon>运行效果运行效果至此，使用矢量字体自定义小程序 icon 组件图标的流程就介绍完了。如果你有什么疑问，欢迎讨论。特别说明本文受极客时间上《微信小程序全栈开发实战》第七课的影响而写，在学习第七课时，不知道其中的 font-face 是如何来的，所以自己搜索一番，结合第七课部分笔记总结成此篇文章。本文只是个人的笔记总结，分享出来给大家，希望有所帮助。参考资料《微信小程序全栈开发实战》第七课·极客时间iconfont——帮助中心——代码应用版权声明本文发布于简书，搜索作者 QinGeneral同步发于CSDN博客，搜索作者 QinGeneral同步发于微信公众号：AndroidRain无需授权即可转载，甚至无需保留以上版权声明；转载时请务必注明作者。"}
{"title": "小程序-云开发-多图片内容安全检测", "author": "Rolan", "time": "2020-5-28 00:29", "content": "前言相比于文本的安全检测,图片的安全检测要稍微略复杂一些,当您读完本篇,将get到图片安全检测的应用场景解决图片的安全方式使用云开发中云调用方式对图片进行检测如何对上传图片大小进行限制如何解决多图上传覆盖问题如有收获,不忘三连击(给赞,留言,分享~)先看一下完成的示例效果当用户上传敏感违规图片时,禁止用户上传发布,并且做出相对应的用户友好提示完成UI的布局对于wxml与wxss,大家可以自行任意修改,本文重点在于图片安全的校验<view class=\"image-list\">\r\n    <!-- 显示图片 -->\r\n    <block wx:for=\"{{images}}\" wx:key=\"*this\">\r\n      <view class=\"image-wrap\">\r\n        <image class=\"image\" src=\"{{item}}\" mode=\"aspectFill\" bind:tap=\"onPreviewImage\" data-imgsrc=\"{{item}}\"></image>\r\n        <i class=\"iconfont icon-shanchu\" bind:tap=\"onDelImage\" data-index=\"{{index}}\"></i>\r\n      </view>\r\n    </block>\r\n\r\n    <!-- 选择图片 -->\r\n    <view class=\"image-wrap selectphoto\" hidden=\"{{!selectPhoto}}\" bind:tap=\"onChooseImage\">\r\n      <i class=\"iconfont icon-add\"></i>\r\n    </view>\r\n  </view>\r\n\r\n<view class=\"footer\">\r\n    <button class=\"send-btn\"  bind:tap=\"send\">发布</button>\r\n</view>\r\n复制代码对应的wxss代码.footer {\r\n  display: flex;\r\n  align-items: center;\r\n  width: 100%;\r\n  box-sizing: border-box;\r\n  background: #34bfa3;\r\n}\r\n\r\n.send-btn {\r\n  width: 100%;\r\n  color: #fff;\r\n  font-size: 32rpx;\r\n  background: #34bfa3;\r\n}\r\n\r\nbutton {\r\n  border-radius: 0rpx;\r\n}\r\n\r\nbutton::after {\r\n  border-radius: 0rpx !important;\r\n}\r\n\r\n/* 图片样式 */\r\n.image-list {\r\n  display: flex;\r\n  flex-wrap: wrap;\r\n  margin-top: 20rpx;\r\n}\r\n\r\n.image-wrap {\r\n  width: 220rpx;\r\n  height: 220rpx;\r\n  margin-right: 10rpx;\r\n  margin-bottom: 10rpx;\r\n  position: relative;\r\n  overflow: hidden;\r\n  text-align: center;\r\n}\r\n\r\n.image {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n\r\n.icon-shanchu {\r\n  position: absolute;\r\n  top: 0;\r\n  right: 0;\r\n  width: 40rpx;\r\n  height: 40rpx;\r\n  background-color: #000;\r\n  opacity: 0.4;\r\n  color: #fff;\r\n  text-align: center;\r\n  line-height: 40rpx;\r\n  font-size: 38rpx;\r\n  font-weight: bolder;\r\n}\r\n\r\n.selectphoto {\r\n  border: 2rpx dashed #cbd1d7;\r\n  position: relative;\r\n}\r\n\r\n.icon-add {\r\n  position: absolute;\r\n  top: 50%;\r\n  left: 50%;\r\n  transform: translate(-50%, -50%);\r\n  color: #cbd1d7;\r\n  font-size: 60rpx;\r\n}\r\n复制代码最终呈现的UI,如下所示对应的JS代码/*\r\n* 涉及到的API:wx.chooseImage  从本地相册选择图片或使用相机拍照\r\n*(https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.chooseImage.html)\r\n\r\n\r\n*\r\n*\r\n*/\r\n// 最大上传图片数量\r\nconst MAX_IMG_NUM = 9;\r\n\r\nconst db = wx.cloud.database(); // 初始化云数据库\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    images: [],  // 把上传的图片存放在一个数组对象里面\r\n    selectPhoto: true, // 添加+icon元素是否显示\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n\r\n  },\r\n\r\n  // 选择图片\r\n  onChooseImage() {\r\n    // 还能再选几张图片,初始值设置最大的数量-当前的图片的长度\r\n    let max = MAX_IMG_NUM - this.data.images.length; \r\n    wx.chooseImage({\r\n      count: max,               // count表示最多可以选择的图片张数\r\n      sizeType: ['original', 'compressed'], //  所选的图片的尺寸\r\n      sourceType: ['album', 'camera'],  // 选择图片的来源\r\n      success: (res) => {                     // 接口调用成功的回调函数\r\n        console.log(res)\r\n        this.setData({                       // tempFilePath可以作为img标签的src属性显示图片,下面是将后添加的图片与之前的图片给追加起来\r\n          images: this.data.images.concat(res.tempFilePaths)\r\n        })\r\n        // 还能再选几张图片\r\n        max = MAX_IMG_NUM - this.data.images.length\r\n        this.setData({\r\n          selectPhoto: max <= 0 ? false : true  // 当超过9张时,加号隐藏\r\n        })\r\n      },\r\n    })\r\n  },\r\n\r\n  // 点击右上方删除图标,删除图片操作\r\n  onDelImage(event) {\r\n    const index = event.target.dataset.index;\r\n    // 点击删除当前图片,用splice方法,删除一张,从数组中移除一个\r\n    this.data.images.splice(index, 1)\r\n    this.setData({\r\n      images: this.data.images\r\n    })\r\n    // 当添加的图片达到设置最大的数量时,添加按钮隐藏,不让新添加图片\r\n    if (this.data.images.length == MAX_IMG_NUM - 1) {\r\n      this.setData({\r\n        selectPhoto: true,\r\n      })\r\n    }\r\n  },\r\n})\r\n复制代码最终实现的前端UI效果如下所是:现在看到的效果,没有任何云函数代码,只是前端的静态,对于一些涉嫌敏感图片,是有必要进行做过滤处理的应用场景通常,在校验一张图片是否含有违法违规内容相比于文本安全的校验,同样重要,有如下应用图片智能鉴黄：涉及拍照的工具类应用(如美拍，识图类应用)用户拍照上传检测；电商类商品上架图片检测；媒体类用户文章里的图片检测等敏感人脸识别：用户头像；媒体类用户文章里的图片检测；社交类用户上传的图片检测等,凡是有用户自发生产内容的都应当提前做检测解决图片的安全手段在小程序开发中,提供了两种方式HTTPS调用云调用 HTTPS 调用的请求接口地止https://api.weixin.qq.com/wxa/img_sec_check?access_token=ACCESS_TOKEN\r\n复制代码检测图片审核,根据官方文档得知,需要两个必传的参数:分别是: access_token (接口调用凭证), media (要检测的图片文件) 对于HTTPS调用方式,愿意折腾的小伙伴可以参考文本内容安全检测(上篇)的处理方式,处理大同小异,本篇主要以云开发的云调用为主云调用方式在 cloudfunctions 目录文件夹下创建云函数 imgSecCheck并在该目录下创建 config.json,配置参数如下所示{\r\n  \"permissions\": {\r\n    \"openapi\": [\r\n      \"security.imgSecCheck\"\r\n    ]\r\n  }\r\n}\r\n复制代码配置完后,在主入口index.js中,如下所示,通过 security.imgSecCheck 接口,并传入 media 对象// 云函数入口文件\r\nconst cloud = require('wx-server-sdk');\r\n\r\n\r\ncloud.init({\r\n  env: cloud.DYNAMIC_CURRENT_ENV\r\n})\r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  const wxContext = cloud.getWXContext()\r\n  try {\r\n    const result = await cloud.openapi.security.imgSecCheck({\r\n      media: {\r\n        contentType: 'image/png',\r\n        value: Buffer.from(event.img)   // 这里必须要将小程序端传过来的进行Buffer转化,否则就会报错,接口异常\r\n      }\r\n      \r\n    })\r\n\r\n    if (result && result.errCode.toString() === '87014') {\r\n      return { code: 500, msg: '内容含有违法违规内容', data: result }\r\n    } else {\r\n      return { code: 200, msg: '内容ok', data: result }\r\n    }\r\n  } catch (err) {\r\n    // 错误处理\r\n    if (err.errCode.toString() === '87014') {\r\n      return { code: 500, msg: '内容含有违法违规内容', data: err }\r\n    }\r\n    return { code: 502, msg: '调用imgSecCheck接口异常', data: err }\r\n  }\r\n}\r\n复制代码你会发现在云函数端,就这么几行代码,就完成了图片安全校验 而在小程序端,代码如下所示// miniprogram/pages/imgSecCheck/imgSecCheck.js\r\n// 最大上传图片数量\r\nconst MAX_IMG_NUM = 9;\r\n\r\nconst db = wx.cloud.database()\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    images: [],\r\n    selectPhoto: true, // 添加图片元素是否显示\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n\r\n  },\r\n  // 选择图片\r\n  onChooseImage() {\r\n    // const that = this;  // 如果下面用了箭头函数,那么这行代码是不需要的,直接用this就可以了的\r\n    // 还能再选几张图片,初始值设置最大的数量-当前的图片的长度\r\n    let max = MAX_IMG_NUM - this.data.images.length; \r\n    wx.chooseImage({\r\n      count: max,\r\n      sizeType: ['original', 'compressed'],\r\n      sourceType: ['album', 'camera'],\r\n      success: (res) => {  // 这里若不是箭头函数,那么下面的this.setData的this要换成that上面的临时变量,作用域的问题,不清楚的,可以看下this指向相关的知识\r\n        console.log(res)\r\n       // tempFilePath可以作为img标签的src属性显示图片\r\n        const  tempFiles = res.tempFiles;\r\n        this.setData({\r\n          images: this.data.images.concat(res.tempFilePaths)\r\n        })\r\n        // 在选择图片时,对本地临时存储的图片,这个时候,进行图片的校验,当然你放在最后点击发布时,进行校验也是可以的,只不过是一个前置校验和后置校验的问题,我个人倾向于在选择图片时就进行校验的,选择一些照片时,就应该在选择时阶段做安全判断的, 小程序端请求云函数方式\r\n        // 图片转化buffer后，调用云函数\r\n        console.log(tempFiles);\r\n        tempFiles.forEach(items => {\r\n          console.log(items);\r\n          // 图片转化buffer后，调用云函数\r\n          wx.getFileSystemManager().readFile({\r\n            filePath: items.path,\r\n            success: res => {\r\n                  console.log(res);\r\n                   wx.cloud.callFunction({\r\n                    name: 'imgSecCheck',\r\n                    data: {\r\n                      img: res.data\r\n                    }\r\n            })\r\n            .then(res => {\r\n               console.log(res);\r\n               let { errCode } = res.result.data;\r\n               switch(errCode) {\r\n                 case 87014:\r\n                   this.setData({\r\n                      resultText: '内容含有违法违规内容'\r\n                   })\r\n                   break;\r\n                 case 0:\r\n                   this.setData({\r\n                     resultText: '内容OK'\r\n                   })\r\n                   break;\r\n                 default:\r\n                   break;\r\n               }\r\n \r\n            })\r\n            .catch(err => {\r\n               console.error(err);\r\n            })\r\n            },\r\n            fail: err => {\r\n              console.error(err);\r\n            }\r\n          })\r\n        })\r\n        \r\n            \r\n        // 还能再选几张图片\r\n        max = MAX_IMG_NUM - this.data.images.length\r\n        this.setData({\r\n          selectPhoto: max <= 0 ? false : true  // 当超过9张时,加号隐藏\r\n        })\r\n      },\r\n    })\r\n  },\r\n\r\n  // 删除图片\r\n  onDelImage(event) {\r\n    const index =  event.target.dataset.index;\r\n    // 点击删除当前图片,用splice方法,删除一张,从数组中移除一个\r\n    this.data.images.splice(index, 1);\r\n    this.setData({\r\n      images: this.data.images\r\n    })\r\n    // 当添加的图片达到设置最大的数量时,添加按钮隐藏,不让新添加图片\r\n    if (this.data.images.length == MAX_IMG_NUM - 1) {\r\n      this.setData({\r\n        selectPhoto: true,\r\n      })\r\n    }\r\n  },\r\n})\r\n复制代码示例效果如下所示:至此,关于图片安全检测就已经完成了,您只需要根据检测的结果,做一些友好的用户提示,或者做一些自己的业务逻辑判断即可如何对上传的图片大小进行限制有时候,您需要对用户上传图片的大小进行限制,限制用户任意上传超大图片,那怎么处理呢,在微信小程序里面,主要借助的是 wx.chooseImage 这个接口成功返回后临时路径的 res.tempFiles 中的 size 大小判断即可进行处理具体实例代码如下所示// 选择图片\r\n  onChooseImage() {\r\n    const that = this;\r\n    // 还能再选几张图片,初始值设置最大的数量-当前的图片的长度\r\n    let max = MAX_IMG_NUM - this.data.images.length; \r\n    wx.chooseImage({\r\n      count: max,\r\n      sizeType: ['original', 'compressed'],\r\n      sourceType: ['album', 'camera'],\r\n      success: (res) => {\r\n        console.log(res)\r\n        const  tempFiles = res.tempFiles;\r\n        this.setData({\r\n          images: this.data.images.concat(res.tempFilePaths)  // tempFilePath可以作为img标签的src属性显示图片\r\n        })\r\n        // 在选择图片时,对本地临时存储的图片,这个时候,进行图片的校验,当然你放在最后点击发布时,进行校验也是可以的,只不过是一个前置校验和后置校验的问题,我个人倾向于在选择图片时就进行校验的,选择一些照片时,就应该在选择时阶段做安全判断的, 小程序端请求云函数方式\r\n        // 图片转化buffer后，调用云函数\r\n        console.log(tempFiles);\r\n        tempFiles.forEach(items => {\r\n          if (items && items.size > 1 * (1024 * 1024)) {  // 限制图片的大小\r\n            wx.showToast({\r\n              icon: 'none',\r\n              title: '上传的图片超过1M,禁止用户上传',\r\n              duration: 4000\r\n            })\r\n          }\r\n          console.log(items);\r\n          // 图片转化buffer后，调用云函数\r\n          wx.getFileSystemManager().readFile({\r\n            filePath: items.path,\r\n            success: res => {\r\n                  console.log(res);\r\n                   wx.cloud.callFunction({   // 请求调用云函数imgSecCheck\r\n                    name: 'imgSecCheck',\r\n                    data: {\r\n                      img: res.data\r\n                    }\r\n            })\r\n            .then(res => {\r\n               console.log(res);\r\n               let { errCode } = res.result.data;\r\n               switch(errCode) {\r\n                 case 87014:\r\n                   this.setData({\r\n                      resultText: '内容含有违法违规内容'\r\n                   })\r\n                   break;\r\n                 case 0:\r\n                   this.setData({\r\n                     resultText: '内容OK'\r\n                   })\r\n                   break;\r\n                 default:\r\n                   break;\r\n               }\r\n            })\r\n            .catch(err => {\r\n               console.error(err);\r\n            })\r\n            },\r\n            fail: err => {\r\n              console.error(err);\r\n            }\r\n          })\r\n        })\r\n       \r\n        // 还能再选几张图片\r\n        max = MAX_IMG_NUM - this.data.images.length\r\n        this.setData({\r\n          selectPhoto: max <= 0 ? false : true  // 当超过9张时,加号隐藏\r\n        })\r\n      },\r\n    })\r\n  },\r\n复制代码注意:使用微信官方的图片内容安全接口进行校验,限制图片大小限制:1M,否则的话就会报错也就是说,对于超过1M大小的违规图片,微信官方提供的这个图片安全接口是无法进行校验的 这个根据自己的业务而定,在小程序端对用户上传图片的大小进行限制如果您觉得微信官方提供的图片安全接口满足不了自己的业务需求,那么可以选择一些其他的图片内容安全校验的接口的这个图片安全校验是非常有必要的,用户一旦上传非法图片,一旦通过网络进行传播,产生了社会影响,平台是有责任的,这种前车之鉴是有的如何解决多图上传覆盖的问题对于检测通过的图片,我们往往需要将它存储到云数据库当中(当然你可以将用户的唯一标识openid,昵称,头像,时间等一并上传到云数据库当中去的),以便于在其他地方使用,那这个在小程序云开发中是怎么实现的呢?我们需要将本地选择的图片fileID,存储到云数据库集合当中在小程序当中,上传图片至云存储使用的API是 wx.cloud.uploadFile ,将本地资源上传至云存储空间注意:如果上传至同一路径则会被覆盖对于上传图片来说,这个 wx.cloud.uploadFile API接口只能上传一张图片,但是很多时候,是需要上传多张图片到云存储当中的,当点击发布的时候,我们是希望将多张图片都上传到云存储当中去的这个API虽然只能每次上传一张,但您可以循环遍历多张图片,然后一张一张的上传的在cloudPath上传文件的参数当中,它的值:需要注意:文件的名称那如何保证上传的图片不被覆盖,文件不重名的情况下就不会被覆盖而在选择图片的时候,不应该上传,因为用户可能有删除等操作,如果直接上传的话会造成资源的浪费而应该在点发布按钮的时候,才执行上传操作,文件不重名覆盖的示例代码如下所示let promiseArr = []\r\n      let fileIds = []      // 将图片的fileId存放到一个数组中\r\n      let imgLength = this.data.images.length;\r\n      // 图片上传\r\n      for (let i = 0; i < imgLength; i++) {\r\n        let p = new Promise((resolve, reject) => {\r\n        let item = this.data.images[i]\r\n          // 文件扩展名\r\n          let suffix = /\\.\\w+$/.exec(item)[0]; // 取文件后拓展名\r\n          wx.cloud.uploadFile({      // 利用官方提供的上传接口\r\n            cloudPath: 'blog/' + Date.now() + '-' + Math.random() * 1000000 + suffix,  // 云存储路径\r\n            filePath: item,   // 要上传文件资源的路径\r\n            success: (res) => {\r\n              console.log(res);\r\n              console.log(res.fileID)\r\n              fileIds = fileIds.concat(res.fileID)       // 将新上传的与之前上传的给拼接起来\r\n              resolve()\r\n            },\r\n            fail: (err) => {\r\n              console.error(err)\r\n              reject()\r\n            }\r\n          })\r\n        })\r\n        promiseArr.push(p)\r\n      }\r\n      // 存入到云数据库,其中这个Promise.all(),等待里面所有的任务都执行之后,在去执行后面的任务,也就是等待上传所有的图片上传完后,才能把相对应的数据存到数据库当中\r\n      Promise.all(promiseArr).then((res) => {\r\n          db.collection('blog').add({ // 查找blog集合,将数据添加到这个集合当中\r\n            data: {\r\n              img: fileIds,\r\n              createTime: db.serverDate(), // 服务端的时间\r\n            }\r\n          }).then((res) => {\r\n            console.log(res);\r\n            this._hideToastTip();\r\n            this._successTip();\r\n          })\r\n        })\r\n        .catch((err) => {\r\n          // 发布失败\r\n          console.error(err);\r\n        })\r\n复制代码上面通过利用当前时间+随机数的方式进行了一个区分,规避了上传文件同名的问题因为这个上传接口,一次性只能上传一张图片,所以需要循环遍历图片,然后一张张的上传,一个是上传到云存储中另一个是添加到云数据库集合当中,要分别注意下这两个操作,云数据库中的图片是从云存储中拿到的,然后再添加到云数据库当中去的 示例效果如下所示:将上传的图片存储到云数据库中注意:需要手动创建集合,不然是无法上传不到云数据库当中的,会报错,示例中的数据集合是 blog至此,关于敏感图片的检测,以及多图片的上传到这里就已经完成了 如下是完整的小程序端逻辑示例代码// miniprogram/pages/imgSecCheck/imgSecCheck.js\r\n// 最大上传图片数量\r\nconst MAX_IMG_NUM = 9;\r\nconst db = wx.cloud.database()\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    images: [],\r\n    selectPhoto: true, // 添加图片元素是否显示\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n\r\n  },\r\n\r\n  // 选择图片\r\n  onChooseImage() {\r\n    const that = this;\r\n    // 还能再选几张图片,初始值设置最大的数量-当前的图片的长度\r\n    let max = MAX_IMG_NUM - this.data.images.length;\r\n    wx.chooseImage({\r\n      count: max,\r\n      sizeType: ['original', 'compressed'],\r\n      sourceType: ['album', 'camera'],\r\n      success: (res) => {\r\n        console.log(res)\r\n        const tempFiles = res.tempFiles;\r\n        this.setData({\r\n          images: this.data.images.concat(res.tempFilePaths) // tempFilePath可以作为img标签的src属性显示图片\r\n        })\r\n        // 在选择图片时,对本地临时存储的图片,这个时候,进行图片的校验,当然你放在最后点击发布时,进行校验也是可以的,只不过是一个前置校验和后置校验的问题,我个人倾向于在选择图片时就进行校验的,选择一些照片时,就应该在选择时阶段做安全判断的, 小程序端请求云函数方式\r\n        // 图片转化buffer后，调用云函数\r\n        console.log(tempFiles);\r\n        tempFiles.forEach(items => {\r\n          if (items && items.size > 1 * (1024 * 1024)) {\r\n            wx.showToast({\r\n              icon: 'none',\r\n              title: '上传的图片超过1M,禁止用户上传',\r\n              duration: 4000\r\n            })\r\n            // 超过1M的图片,禁止上传\r\n          }\r\n          console.log(items);\r\n          // 图片转化buffer后，调用云函数\r\n          wx.getFileSystemManager().readFile({\r\n            filePath: items.path,\r\n            success: res => {\r\n              console.log(res);\r\n              this._checkImgSafe(res.data); // 检测图片安全校验\r\n            },\r\n            fail: err => {\r\n              console.error(err);\r\n            }\r\n          })\r\n        })\r\n\r\n\r\n        // 还能再选几张图片\r\n        max = MAX_IMG_NUM - this.data.images.length\r\n        this.setData({\r\n          selectPhoto: max <= 0 ? false : true // 当超过9张时,加号隐藏\r\n        })\r\n      },\r\n    })\r\n  },\r\n\r\n  // 删除图片\r\n  onDelImage(event) {\r\n    const index = event.target.dataset.index;\r\n    // 点击删除当前图片,用splice方法,删除一张,从数组中移除一个\r\n    this.data.images.splice(index, 1);\r\n    this.setData({\r\n      images: this.data.images\r\n    })\r\n    // 当添加的图片达到设置最大的数量时,添加按钮隐藏,不让新添加图片\r\n    if (this.data.images.length == MAX_IMG_NUM - 1) {\r\n      this.setData({\r\n        selectPhoto: true,\r\n      })\r\n    }\r\n  },\r\n\r\n  // 点击发布按钮,将图片上传到云数据库当中\r\n  send() {\r\n    const images = this.data.images.length;\r\n    if (images) {\r\n      this._showToastTip();\r\n      let promiseArr = []\r\n      let fileIds = []\r\n      let imgLength = this.data.images.length;\r\n      // 图片上传\r\n      for (let i = 0; i < imgLength; i++) {\r\n        let p = new Promise((resolve, reject) => {\r\n          let item = this.data.images[i]\r\n          // 文件扩展名\r\n          let suffix = /\\.\\w+$/.exec(item)[0]; // 取文件后拓展名\r\n          wx.cloud.uploadFile({\r\n            cloudPath: 'blog/' + Date.now() + '-' + Math.random() * 1000000 + suffix,\r\n            filePath: item,\r\n            success: (res) => {\r\n              console.log(res);\r\n              console.log(res.fileID)\r\n              fileIds = fileIds.concat(res.fileID)\r\n              resolve()\r\n\r\n            },\r\n            fail: (err) => {\r\n              console.error(err)\r\n              reject()\r\n            }\r\n          })\r\n        })\r\n        promiseArr.push(p)\r\n      }\r\n      // 存入到云数据库\r\n      Promise.all(promiseArr).then((res) => {\r\n          db.collection('blog').add({ // 查找blog集合,将数据添加到这个集合当中\r\n            data: {\r\n              img: fileIds,\r\n              createTime: db.serverDate(), // 服务端的时间\r\n            }\r\n          }).then((res) => {\r\n            console.log(res);\r\n            this._hideToastTip();\r\n            this._successTip();\r\n          })\r\n        })\r\n        .catch((err) => {\r\n          // 发布失败\r\n          console.error(err);\r\n        })\r\n    } else {\r\n      wx.showToast({\r\n        icon: 'none',\r\n        title: '没有选择任何图片,发布不了',\r\n      })\r\n    }\r\n\r\n  },\r\n\r\n  // 校验图片的安全\r\n  _checkImgSafe(data) {\r\n    wx.cloud.callFunction({\r\n        name: 'imgSecCheck',\r\n        data: {\r\n          img: data\r\n        }\r\n      })\r\n      .then(res => {\r\n        console.log(res);\r\n        let {\r\n          errCode\r\n        } = res.result.data;\r\n        switch (errCode) {\r\n          case 87014:\r\n            this.setData({\r\n              resultText: '内容含有违法违规内容'\r\n            })\r\n            break;\r\n          case 0:\r\n            this.setData({\r\n              resultText: '内容OK'\r\n            })\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n      })\r\n      .catch(err => {\r\n        console.error(err);\r\n      })\r\n  },\r\n\r\n  _showToastTip() {\r\n    wx.showToast({\r\n      icon: 'none',\r\n      title: '发布中...',\r\n    })\r\n  },\r\n\r\n  _hideToastTip() {\r\n    wx.hideLoading();\r\n  },\r\n\r\n  _successTip() {\r\n    wx.showToast({\r\n      icon: 'none',\r\n      title: '发布成功',\r\n    })\r\n  },\r\n})\r\n\r\n复制代码完整的示例wxml,如下所示<view class=\"image-list\">\r\n    <!-- 显示图片 -->\r\n    <block wx:for=\"{{images}}\" wx:key=\"*this\">\r\n      <view class=\"image-wrap\">\r\n        <image class=\"image\" src=\"{{item}}\" mode=\"aspectFill\" bind:tap=\"onPreviewImage\" data-imgsrc=\"{{item}}\"></image>\r\n        <i class=\"iconfont icon-shanchu\" bind:tap=\"onDelImage\" data-index=\"{{index}}\"></i>\r\n      </view>\r\n    </block>\r\n\r\n    <!-- 选择图片 -->\r\n    <view class=\"image-wrap selectphoto\" hidden=\"{{!selectPhoto}}\" bind:tap=\"onChooseImage\">\r\n      <i class=\"iconfont icon-add\"></i>\r\n    </view>\r\n  </view>\r\n\r\n<view class=\"footer\">\r\n    <button class=\"send-btn\"  bind:tap=\"send\">发布</button>\r\n</view>\r\n<view>\r\n    检测结果显示: {{ resultText }}\r\n</view>\r\n复制代码您可以根据自己的业务逻辑需要,一旦检测到图片违规时,禁用按钮状态,或者给一些用户提示,都是可以的,在发布之前或者点击发布时,进行图片内容安全的校验都可以,一旦发现图片有违规时,就不让继续后面的操作的结语本文主要通过借助官方提供的图片security.imgSecCheck接口,实现了对图片安全的校验,实现起来,是相当的方便的,对于基础性的校验,利用官方提供的接口,已经够用了的,但是如果想要更加严格的检测,可以引入一些第三方的内容安全强强校验,确保内容更加安全实现了如何对上传的图片大小进行限制,以及解决同名图片上传覆盖的问题如果小伙伴们仍然对图片或者文本内容安全检测有问题,都可以在下方留言,一起探讨更多内容,您可关注微信itclanCoder公众号,一个只传递和分享给你带来启发智慧有用的号"}
{"title": "xquery小程序简易步进器", "author": "Rolan", "time": "2019-12-30 00:29", "content": "这样一个简单的组件，翻了ant.design才知道这种组件叫做步进器(steper)，步进器常用于购物车等需要增减数量的场景，最近的旅游项目中用于增减房间数和人数，从产品的角度来理解步进器很简单，但在开发角度来说需要适应多种场景及控制一些状态边界值(最大值，最小值)，初始值，步进值(一次增减数量)需要可控边界状态，即超出后显示为什么状态可供外部设置边界状态的api方法内部加减方法可供外部调用的加减方法(一些场景中，外部有一个总量约束，比如sku场景)加减回调方法，比如当数量超出时提示用户相关信息多实例模式，实例之间即隔离又能交互大致需求如上，demo及实现部分如下GITHUB源码小程序代码片段wxml<view class=\"container\">\r\n  <ui-item item=\"{{steperConfig}}\" />\r\n</view>\r\n复制代码Page因为是直接使用Item组件实现，所以组件写在Page页面中，当然独立成组件看需求了const Pager = require('../components/aotoo/core/index')\r\nlet lib = Pager.lib\r\n\r\nfunction mkSteper(id=lib.suid('step_'), min, max, step=1) {\r\n  return {\r\n    $$id: id,\r\n    itemClass: 'steper-class',\r\n    title: [\r\n      {title: '-', aim: 'reduce', itemClass: 'steper-reduce'},\r\n      {title: '0', aim: 'custom', itemClass: 'steper-counter'},\r\n      {title: '+', aim: 'plus', itemClass: 'steper-plus'},\r\n    ],\r\n    methods: {\r\n      __ready(){\r\n        this.count = 0\r\n        this.min = min||0\r\n        this.max = max||10\r\n        this.step = step||1\r\n        this.stat = {\r\n          reduce: true,\r\n          plus: true,\r\n          count: true\r\n        }\r\n      },\r\n      reduce(e, param, inst){\r\n        let step = this.step\r\n\r\n        if (!inst) {\r\n          inst = this.children[0]\r\n        }\r\n\r\n        if (e === false) {\r\n          this.stat.reduce = false\r\n          inst.addClass('disable')\r\n        }\r\n\r\n        if (e === true) {\r\n          this.stat.reduce = true\r\n          inst.removeClass('disable')\r\n        }\r\n\r\n        if (typeof e === 'number') {\r\n          step = e\r\n        }\r\n\r\n        this.count -= step\r\n        if (this.count <= this.min) {\r\n          this.count = this.min\r\n          this.stat.reduce = false\r\n          inst.addClass('disable')\r\n        }\r\n\r\n        if (this.count < this.max && !this.stat.plus) {\r\n          this.stat.plus = true\r\n          let $plus = inst.siblings('steper-plus')\r\n          $plus.removeClass('disable')\r\n        }\r\n        this.changeNum(inst)\r\n        this.hooks.emit('reduce', {count: this.count}, this)\r\n\r\n      },\r\n      plus(e, param, inst){\r\n        let step = this.step\r\n\r\n        if (!inst) {\r\n          inst = this.children[2]\r\n        }\r\n\r\n        if (e === false) {\r\n          this.stat.plus = false\r\n          inst.addClass('disable')\r\n        }\r\n        if (e === true) {\r\n          this.stat.plus = true\r\n          inst.removeClass('disable')\r\n        }\r\n        if (typeof e === 'number') {\r\n          step = e\r\n        }\r\n\r\n        this.count += step\r\n        if (this.count >= this.max) {\r\n          this.count = this.max\r\n          this.stat.plus = false\r\n          inst.addClass('disable')\r\n        }\r\n        if (this.count > this.min && !this.stat.reduce) {\r\n          this.stat.reduce = true\r\n          let $reduce = inst.siblings('steper-reduce')\r\n          $reduce.removeClass('disable')\r\n        }\r\n        this.changeNum(inst)\r\n        this.hooks.emit('plus', {count: this.count}, this)\r\n      },\r\n      changeNum(inst){\r\n        let count = this.count\r\n        if (typeof inst === 'number') {\r\n          count = inst\r\n          inst = undefined\r\n        }\r\n\r\n        if (!inst) {\r\n          inst = this.children[1]\r\n        }\r\n\r\n        let $counter = inst.siblings('steper-counter')\r\n        $counter.update({\r\n          title: count\r\n        })\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nPager({\r\n  data: {\r\n    steperConfig: mkSteper('steper'),\r\n  },\r\n  onReady(){\r\n    let $steper = this.getElementsById('steper')\r\n    $steper.hooks.on('plus', function(param) {\r\n      if (this.count === 10) {\r\n        Pager.alert('不能再多了，仓库没货了')\r\n      }\r\n    })\r\n    $steper.hooks.on('reduce', function(param) {\r\n      if (param.count <= 0) {\r\n        Pager.alert('大哥，买点啊')\r\n      }\r\n    })\r\n  }\r\n})\r\n复制代码"}
{"title": "小程序摸爬滚打之路", "author": "Rolan", "time": "2020-1-10 00:12", "content": "上面这张图相信接触过小程序的开发者多多少少都有看到过，小程序的渲染层和逻辑层分别由 2 个线程管理：视图层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS脚本。那么为什么要这样设计呢，为了管控和安全，我们需要阻止开发者使用一些，例如浏览器的window对象，跳转页面、操作DOM、动态执行脚本的开放性接口。我们可以使用客户端系统的 JavaScript 引擎，iOS 下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境。这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口。2.双线程之间的通信既然小程序的模型是双线程模型，那么是如何实现双线程之间的通信呢，由上图可以看出，逻辑层和视图层是通过Native层来进行转发的，这也就是说，我们可以把 DOM 的更新通过简单的数据通信来实现，类似于虚拟DOM的实现，用JS对象模拟DOM树，然后进行diff,然后把差异在视图层进行渲染，这一系列在Native之间的转化则由小程序的基础库来完成。3.组件系统--Exparser框架Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由Exparser组织管理。DOM模型：模型上与WebComponents的ShadowDOM高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。当前Web Component已经支持局部作用域、slot插槽等等现有框架所提供的组件化方法，学习Web Component也是我接下来自己学习的目标之一 Orz 。4.setData干了些什么小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。5.运行机制小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台状态的小程序切换到前台，这个过程就是热启动；冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。小程序开发日常问题1.wx.request()的promise化小程序框架自带的网络请求和Ajax请求非常相似都是异步请求，请求参数中需要送入url、method、data、header等参数，还要设置success成功的回调函数和fail失败的回调函数，如下图所示通过回调函数处理就很容易造成回调地狱，所以Promise化还是很有必要的class request {\r\n  constructor() {\r\n    this._baseUrl = 'https://xxx.com/api';\r\n    this._token = wx.getStorageSync('token');\r\n    this._header = {}\r\n  }\r\n\r\n  /**\r\n   * GET类型的网络请求\r\n   */\r\n  getRequest(url, data, header = this._header) {\r\n    return this.requestAll(url, data, header, 'GET')\r\n  }\r\n\r\n  /**\r\n   * DELETE类型的网络请求\r\n   */\r\n  deleteRequest(url, data, header = this._header) {\r\n    return this.requestAll(url, data, header, 'DELETE')\r\n  }\r\n\r\n  /**\r\n   * PUT类型的网络请求\r\n   */\r\n  putRequest(url, data, header = this._header) {\r\n    return this.requestAll(url, data, header, 'PUT')\r\n  }\r\n\r\n  /**\r\n   * POST类型的网络请求\r\n   */\r\n  postRequest(url, data, header = this._header) {\r\n    return this.requestAll(url, data, header, 'POST')\r\n  }\r\n  \r\n  requestAll(url, data, header, method) {\r\n    return new Promise((resolve, reject) => {\r\n      wx.request({\r\n        url: this._baseUrl + url,\r\n        data: data,\r\n        header: header,\r\n        method: method,\r\n        success: (res => {\r\n          if (res.statusCode === 200) {\r\n            resolve(res)\r\n          } else {\r\n            //其它错误，提示用户错误信息\r\n            reject(res)\r\n          }\r\n        }),\r\n        fail: (res => {\r\n          reject(res)\r\n        })\r\n      })\r\n    })\r\n  }\r\n}\r\n\r\nexport default request\r\n复制代码2.小程序的WXS在小程序的日常开发中大家肯定会遇到需要对数据进行过滤转义的场景，而微信小程序没有像Vue一样的filter过滤器功能，大多数人会在渲染之前对数据进行一次清洗，而WXS就是为了解决这一痛点什么是WXS是小程序出的一套脚本语言，用于 wxml 模板文件中，在模板文件中可以完成页面的结构。不依赖于运行时的基础库脚本，可以在所有版本的小程序中运行。WXS 中不能调用 javascript 中定义的函数或者变量，也不能调用小程序提供的 API，他的运行环境和 javascript 是隔离的。小程序的条件渲染和循环渲染对 WXS 是无效的，就是说如果 WXS 代码包裹在未渲染的代码中，只要渲染的 wxml 部分调用了此模块，此段 WXS 代码依然会被加载。由于运行环境的差异，在 ios 设备上小程序的 WXS 会比 javascript 快 2~20 倍，在 android 设备上运行效率无异。模块想要暴露自己的私有变量和方法，只能通过 module.exports 实现。 若在模块中想要引用其他模块，只能通过 require 实现。只能使用 var 来定义变量，表现形式和 javascript 一样，会有变量提升。WXS 模块只能在定义模块的 wxml 文件中被访问到，使用 或 时，WXS 模块不会被引入到对应的 wxml 文件中。不能使用 new Date() 应该使用 getDate() 。WXS最常见的用处可能就是实现一个过滤器，如下所示<wxs module=\"filter\">\r\n    function getFullPath(url) {\r\n        return \"https://shiyuanjieyi.cn\" + url\r\n    }\r\n    module.exports.getFullPath = getFullPath\r\n</wxs>\r\n<image src=\"{{filter.getFullPath(url)}}\"></image>\r\n复制代码"}
{"title": "小程序canvas开发水果老虎机", "author": "Rolan", "time": "2020-2-8 00:53", "content": "在这个超长假期中，无聊。。。，所以动手做一个早就计划要做的小玩意， 水果老虎机 ，嗯，这是一个小程序而不是小游戏...使用结构还是canvas？使用模板结构(view)生成水果盘的好处一是用户可自定义产出 n x n 的定制化老虎机，二是容易通过算法样式生成布局，三是通过 wx.selectQueryAll 的方法能够很方便的抓到定位数据。但，问题是动画性能过于孱弱，如图构建一个 7x7 的水果盘，动画性能估计会惨不忍睹，而且纯粹模板结构无论使用 animation 动画方法还是 css 的keyframe的动画方法得到的动画效果都非常差(测试过的结论)，还有是已知的动画方法可控性很差使用canvas来生成水果盘好处是动画性能很好(canvas2d)，但是定制性和扩展性比较差so综上考虑，使用模板(view)布局，使用canvas来实现动画。既保证了组件的性能，同时定制型，扩展性也很好准备计时器方法动画的生成离不开计时器方法，settimeout/setinterval这两兄弟真的不够看啊，问题还多，做过web开发的一定都知道 window.requestAnimationFrame ，这货在小程序的计时器方法中不存在，好在 canvas2d 中可以使用 Canvas.requestAnimationFrame(function callback) 方法来实现准备运动算法在水果老虎机中，激活状态会沿着四方的水果盘做非线性运动(easeInOut比较好用)，需要基础的运动算法来计算实际的运动距离。在 animation 动画方法中，我们可以使用 ease-in/ease-out 等缓动算法来实现动画效果，但在这里必须要借助 tween.js 中的缓动算法来实现运动效果(因为需要控制运动节点)。你会不会想到用css的keyframe动画来做这个运动效果，经过我的测试，css的动画和animation的动画会在每一条边上实现一次(ease)缓动运动(很奇怪的效果)推荐这篇文章使用其中一个，节省代码量/*\r\n * Tween.js\r\n * t: current time（当前时间）；\r\n * b: beginning value（初始值）；\r\n * c: change in value（变化量）；\r\n * d: duration（持续时间）。\r\n */\r\n// Quart 四次方的缓动\r\nconst easeInOutQuart = function (t, b, c, d) {\r\n  if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;\r\n  return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\r\n}\r\n复制代码tween算法是以时间为基准(时间比率 = 距离比率)来计算单位时间的实际运动距离布局以上面的图为例，我们需要做一个 7 x 7 的水果盘，实际有效的奖品格子数为 7*4-4 共24个有效格子有效格子算法js// 0-6 第一行所有格子全部有效  \r\n// 21-27 最后一行所有格子全部有效  \r\n// 中间部分 i%7===0 和 i%7 === (7-1) 有效\r\n// 算法源码有点无聊，依据上述思路，即可遍历28个格子并标识奖品格子valide=true\r\n// 可以扩展想一想 6x6 5x5，思路是一样的\r\n复制代码wxml<view class=\"fruits-container\" >\r\n    <view class=\"fruits-table\" >\r\n        <block wx:for=\"{{ary}}\" wx:key=\"index\" >\r\n            <view wx:if=\"{{item.valide}}\" class=\"valide\">{{item.title}}</view>\r\n            <view wx:else class=\"in-valide\"></view>\r\n        </block>\r\n    </view>\r\n    <canvas type=\"2d\" .... />\r\n</view>\r\n复制代码样式只节选关键样式，目的是让canvas覆盖在水果盘上，长宽一致.fruits-container {\r\n    position: relative;\r\n    width: 400px;\r\n    height: 400px;\r\n    ...\r\n}\r\n\r\n.fruits-table {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n    top: 0;\r\n    left: 0;\r\n    ...\r\n}\r\n复制代码抓取位置信息canvas的绘制需要X轴, Y轴的精确信息，可以使用 wx.createSelectorQuery 方式抓取类名为‘valide’的 view (奖品格子)的位置信息let query = wx.createSelectorQuery().in(this)\r\nquery.selectAll(`.fruits-table .valide`).boundingClientRect(ret => {\r\n    ....\r\n    console.log(ret[0]) // top, left, right, bottom, width, height\r\n    console.log(ret[1]) // top, left, right, bottom, width, height\r\n    ...\r\n    ...\r\n    console.log(ret[23]) // top, left, right, bottom, width, height\r\n})\r\n复制代码得到每一个奖品格子的位置信息后，就可以使用canvas的 fillRect 方法来绘制激活状态了。绘制一个激活状态let query = wx.createSelectorQuery().in(this)\r\nquery.selectAll(`.fruits-table .valide`).boundingClientRect(ret => {\r\n    ....\r\n    let {top, left, right, bottom, width, height} = ret[0]\r\n    const canvasQuery = wx.createSelectorQuery()\r\n    canvasQuery.select('#fruit-canvas')\r\n    .fields({ node: true, size: true })\r\n    .exec((res) => {\r\n        const canvas = res[0].node\r\n        const ctx = canvas.getContext('2d') \r\n        let x = top\r\n        let y = left\r\n        let dx = width\r\n        let dy = height\r\n        ctx.shadowOffsetX = 2\r\n        ctx.shadowOffsetY = -2\r\n        ctx.shadowColor = 'red'\r\n        ctx.shadowBlur = 50\r\n        ctx.lineWidth = 5\r\n        ctx.strokeStyle = 'red'\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height)\r\n        ctx.strokeRect(x, y, dx, dy)\r\n    })\r\n})\r\n复制代码跑起来已经绘制了一个激活状态，接下来使它能够简单动起来// 抽象激活方法  \r\nfuncton rect(point, canvas){\r\n    let {x, y, dx, dy} = getPosition(point)\r\n    ctx.shadowOffsetX = 2\r\n    ctx.shadowOffsetY = -2\r\n    ...\r\n    ...\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height) // 擦除整个水果盘\r\n    ctx.strokeRect(x, y, dx, dy) // 绘制激活区域\r\n}\r\n\r\nfunction run(){\r\n    setTimeout(()=>{\r\n        if (ret.length) {\r\n            let point = ret.shift()\r\n            rect(point, canvas)\r\n            run()\r\n        }\r\n    }, 100)\r\n}\r\n复制代码执行run方法后可以看到水果盘的激活状态一步一步的往前走(100毫秒)，拖拉机终于可以启动了配上运动算法经过上面的试验我们终于可以看到基本的运动效果了，接下来配上运动算法和计时器方法// Quart 四次方的缓动\r\nconst easeInOutQuart = function (t, b, c, d) {\r\n  if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;\r\n  return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\r\n}\r\n\r\nlet start = 0  // 开始时间\r\nlet begin = 0  // 开始奖品位置\r\nlet end = 23  // 终点位置，这里跑一圈\r\nlet during = 5000 // 运动总时间\r\n\r\n// 1000/60 ≈ 17，\r\n// 17毫秒即表示屏幕60帧刷新率每秒 ≈ requestAnimationFrame计数频率(一般情况)  \r\nconst steper = () => {\r\n  // left为位移距离\r\n  // 老虎机的运动位移是节点位移，不是精确位移\r\n  // 所以这里用parseInt处理，只取整数部分\r\n  // 数据变化为 0,1,2,3,4,5...23\r\n  // 间隔时间/距离由easeInOutQuart算法计算\r\n  var left = easeInOutQuart(start, begin, end, during);\r\n  let idx = parseInt(left)\r\n  start = start + 17; \r\n  if (idx <= end) {\r\n    let point = this.ret[idx] // 取节点位置信息\r\n    this.rect(point) // 绘制\r\n  }\r\n  \r\n  // 时间递增\r\n  if (start <= during) {\r\n    this.ctx.requestAnimationFrame(steper); // 计时器\r\n  } else {\r\n    // 动画结束，这里可以插入回调...\r\n    // callback()...\r\n  }\r\n};\r\n\r\nsteper(); // 启动\r\n复制代码以上为我的小程序水果老虎机的基本开发思路"}
{"title": "小程序订阅消息用户拒绝/关闭后，如何引导用户再开启？并获得用户的操作呢？ ...", "author": "Rolan", "time": "2020-3-5 00:15", "content": "前言有些时间没折腾小程序了，话说年前小程序就发布了消息，于1月10日会下线模板消息下发功能，所有的订阅消息都要用户手动触发确认同意，这可就太难了，之前的\twx.openSetting 、\twx.getPhoneNumber 、\twx.getUserInfo 等等API的调整，可把我折腾惨了，这次又来……难道直接js调用，不爽吗？非要整手动确认，爽是肯定的，但如果从一个用户的角度出发，自己啥都没干，你就把我信息获取了、天天给我推一堆垃圾信息，那肯定不爽了，所以从这角度看，微信的调整也是为了尊重用户的隐私，毕竟用户第一嘛今天主要是想分享一下，今天在处理这个订阅消息逻辑时，遇到当\t用户拒绝 后，如何重新引导开启 「订阅消息」通知的问题，并在\t开启后获取到它的状态如果你处理过小程序的订阅消息，应该是知道的，在用户拒绝或关闭消息总开关之后，我们引导用户手动开启「订阅消息」功能（也就是\topenSetting API的调用回调里，是拿不到\tscope.subscribeMessage 状态的），开始我也纠结了很久，百度、google都用上了，同样发现很多的同学也有遇到这样的问题，而都没有找到解决方案，最后在我快要放弃的时候却突然灵光一闪，想到了个办法，所以抖胆BB几句，分析一下：温馨提示：书读的少，却又喜欢瞎BB几句，内容仅为个人解决方案的思路，仅供参考，不足之处请见谅，勿喷，谢谢～授权API示例首先来看下调用的示例：wx.requestSubscribeMessage({\r\n  tmplIds: ['模版id'],\r\n  success (res) {\r\n\r\n  }\r\n})同时官方也说了，\tsuccess 回调的模版对应有三种状态：accept = 同意reject = 拒绝ban = 后台封禁fail 也有对应的状态码，如下：本次要讲的是\terrorCode 20004 与\treject 状态时，根据以往经验，如果拒绝了，我们肯定是使用直接使用\topenSetting ,引导用户进行手动开启授权（），比如：//以微信运动为例\r\nexport default class Sign extends wepy.page {\r\n  config = {\r\n    navigationBarBackgroundColor: '#fff',\r\n    navigationBarTitleText: '赢积分',\r\n  };\r\n  components = {\r\n    Toast: Toast,\r\n    Modals: Modals\r\n  };\r\n  methods = {\r\n  };\r\n  data = {\r\n    signHistory: []\r\n  };\r\n  getRunData() {\r\n    wx.getWeRunData({\r\n      success: res => {\r\n        ……处理运动步数逻辑\r\n      }\r\n    });\r\n  }\r\n  setAuth() {\r\n    wx.getSetting({\r\n      success: res => {\r\n        //第一步，检测是否有授权 - 没有授权\r\n        if (!res.authSetting['scope.werun']) {\r\n          //第二步，开始授权，但这里有一个坑点（腾讯的bug），之前授权过但是是拒绝，所以会进入失败\r\n          wx.authorize({\r\n            scope: 'scope.werun',\r\n            success: () => {\r\n              this.getRunData();\r\n            },\r\n            fail: () => {\r\n              //第三步，引导用户，手动引导用户点击按钮，去设置页开启，## Modals是自定义组件\r\n              this.$invoke('Modals', '__modalConfirm__', [\r\n                '检测到您没有打微信运动的权限，是否去设置？',\r\n                'openSetting',\r\n                //第四步，进入设置页的回调 - 成功\r\n                res => {\r\n                  let { authSetting } = res.detail;\r\n                  if (authSetting['scope.werun']) {\r\n                    this.getRunData();\r\n                  } else {\r\n                    this.$invoke('Toast', '__warning__', [\r\n                      `您没有同意授权微信运动，获取步数失败`\r\n                    ]);\r\n                  }\r\n                },\r\n                //第五步，点击取消按钮的回调\r\n                () => {\r\n                  this.$invoke('Toast', '__warning__', [\r\n                    `您已拒绝微信运动授权，无法获取步数`\r\n                  ]);\r\n                }\r\n              ]);\r\n            }\r\n          });\r\n        } else {\r\n          //第六步，已经授权直接进入保存逻辑\r\n          // console.log(\"授权了\")\r\n          this.getRunData();\r\n        }\r\n      }\r\n    });\r\n  }\r\n}上面代码执行截图如下：上述代码，\tthis.$invoke('Modals'……) 部分为自定义弹窗，即引用用户确定，去设置页，requestSubscribeMessage 问题点但是 在\topenSetting 的回调里，是没有\tscope.subscribeMessage 这一项的，下面是列出的\tscope 列表 官方清单（\t文档地址 ）：//提交订阅消息示例\r\n\r\n\r\nexport default class Sign extends wepy.page {\r\n  config = {\r\n    navigationBarBackgroundColor: '#fff',\r\n    navigationBarTitleText: '赢积分',\r\n  };\r\n  setClock(e) {\r\n    let that = this;\r\n    if (wx.requestSubscribeMessage) {\r\n      wx.requestSubscribeMessage({\r\n        tmplIds: [pushReservationTmplIds],\r\n        success(res) {\r\n          if (res[pushReservationTmplIds] === 'accept') {\r\n            //发起请求……\r\n          } else if (res[pushReservationTmplIds] === 'reject') {\r\n            // 用户历史操作有设置了拒绝 or 关闭了订阅消息的主（总）开关，导致无法推送\r\n            that.guideOpenSubscribeMessage();\r\n          } else {\r\n            wx.showToast({\r\n              title: '授权订阅消息有误',\r\n              icon: 'none'\r\n            });\r\n          }\r\n        },\r\n        fail(res) {\r\n\r\n          // 20004:用户关闭了主开关 或在 消息通知 里 “拒绝接收”操作，无法进行订阅,引导开启\r\n          if (res.errCode == 20004) {\r\n            console.log(res, 'fail:用户关闭了主开关，无法进行订阅,引导开启---');\r\n          }\r\n        }\r\n      });\r\n    } else {\r\n      wx.showToast({\r\n        title: '请更新您微信版本，来获取订阅消息功能',\r\n        icon: 'none'\r\n      });\r\n    }\r\n  }\r\n  guideOpenSubscribeMessage() {\r\n    //引导用户，手动引导用户去设置页开启，\r\n    this.$invoke('Modals', '__modalConfirm__', [\r\n      '检测到您没有开启订阅消息的权限，是否去设置？',\r\n      'openSetting',\r\n      res => {\r\n        console.log('openSetting的回调数据：', res);\r\n        //但是这个回调数据里，并没有 「订阅消息」 相关 open/close 的状态返回\r\n\r\n      },\r\n      //用户点击了取消按钮\r\n      () => {\r\n        // console.log(\"取消了\")\r\n        this.$invoke('Toast', '__warning__', [\r\n          `您已拒绝订阅消息授权，无法预约`\r\n        ]);\r\n      }\r\n    ]);\r\n}上图为\topenSetting 的回调数据，而网上说回调里不做任何处理，用户是否有手动开启，则让提示让他再手动点击一次业务按钮，如果有开启，则回到最初的逻辑，订阅消息成功，否则则又循环进入\topenSetting 设置页，俗称“死缠烂打授权法”，这当然不失为一种方法，但体验不是最好，对于追求完美的我来说，不能接受，继续寻找更好的方案，把官方文档来回看，终于发现了新大陆，——\twx.getSetting文档有有这么一个属性：\tsubscriptionsSetting ，感谢苍天，终于让我看到了\t订阅消息 相关的东西，//官方示例\r\nwx.getSetting({\r\n  withSubscriptions: true,\r\n  success (res) {\r\n    console.log(res.authSetting)\r\n    // res.authSetting = {\r\n    //   \"scope.userInfo\": true,\r\n    //   \"scope.userLocation\": true\r\n    // }\r\n    console.log(res.subscriptionsSetting)\r\n    // res.subscriptionsSetting = {\r\n    //   mainSwitch: true, // 订阅消息总开关\r\n    //   itemSettings: {   // 每一项开关\r\n    //     SYS_MSG_TYPE_INTERACTIVE: 'accept', // 小游戏系统订阅消息\r\n    //     SYS_MSG_TYPE_RANK: 'accept'\r\n    //     zun-LzcQyW-edafCVvzPkK4de2Rllr1fFpw2A_x0oXE: 'reject', // 普通一次性订阅消息\r\n    //     ke_OZC_66gZxALLcsuI7ilCJSP2OJ2vWo2ooUPpkWrw: 'ban',\r\n    //   }\r\n    // }\r\n  }\r\n})在\twx.getSetting 的回调里，有一项\tmainSwitch ，还有一项\twithSubscriptions: true ，最后回调里还能一项\tzun-LzcQyW-edafCVvzPkK4de2Rllr1fFpw2A_x0oXE: 'reject' ，到这里，但它也只是在\tgetSetting 方法里啊，跟\topenSetting 没有扯上任何关系，怎么办？其实道理很简单，但人有时候就是这样，思维如果没有转换过来，你可以就会一直杠在那个死胡同里出不来，openSetting 回调里取不到状态，\t那么我们是否可以在它的回调里，再做一次\tgetSetting 的调用里呢？\t，取\tgetSetting 回调里的状态来判断，刚才用户在设置页的行为操作，直接看示例吧：//提交订阅消息示例\r\n\r\nconst pushReservationTmplIds = 'PVC_DBcvvdtffd1fO0vdS8YpSe0c7Br3QW54';\r\n\r\nexport default class Sign extends wepy.page {\r\n  config = {\r\n    navigationBarBackgroundColor: '#fff',\r\n    navigationBarTitleText: '赢积分',\r\n  };\r\n  submitClock() {\r\n    fetchJson({\r\n      type: 'POST',\r\n      url: '/api/steps/clock',\r\n      data: {\r\n      },\r\n      success: res => {\r\n        wx.showToast({\r\n          title: '预定成功',\r\n          icon: 'success',\r\n          duration: 2000\r\n        });\r\n      }\r\n    });\r\n  }\r\n  setClock(e) {\r\n    let that = this;\r\n    if (wx.requestSubscribeMessage) {\r\n      wx.requestSubscribeMessage({\r\n        tmplIds: [pushReservationTmplIds],\r\n        success(res) {\r\n          if (res[pushReservationTmplIds] === 'accept') {\r\n            that.submitClock();\r\n          } else if (res[pushReservationTmplIds] === 'reject') {\r\n            // 用户历史操作有设置了拒绝 or 关闭了订阅消息的主（总）开关，导致无法推送\r\n            // console.log(res, '0 拒绝 or 关闭了订阅消息的主（总）开关---');\r\n            that.guideOpenSubscribeMessage();\r\n          } else {\r\n            wx.showToast({\r\n              title: '授权订阅消息有误',\r\n              icon: 'none'\r\n            });\r\n          }\r\n        },\r\n        fail(res) {\r\n          // 20004:用户关闭了主开关，无法进行订阅,引导开启\r\n          if (res.errCode == 20004) {\r\n            // console.log(res, 'fail:用户关闭了主开关，无法进行订阅,引导开启---');\r\n            that.guideOpenSubscribeMessage();\r\n          }\r\n        }\r\n      });\r\n    } else {\r\n      wx.showToast({\r\n        title: '请更新您微信版本，来获取订阅消息功能',\r\n        icon: 'none'\r\n      });\r\n    }\r\n  }\r\n  guidSubscribeMessageAuthAfter() {\r\n    //引导用户 开启订阅消息 之后，「openSetting」 接口暂时不会返回，用户手动设置后的状态，所以采用「getSetting」接口重新进行查询\r\n    wx.getSetting({\r\n      withSubscriptions: true,\r\n      success: res => {\r\n        let {\r\n          authSetting = {},\r\n          subscriptionsSetting: { mainSwitch = false, itemSettings = {} } = {}\r\n        } = res;\r\n\r\n        if (\r\n          (authSetting['scope.subscribeMessage'] || mainSwitch) &&\r\n          itemSettings[pushReservationTmplIds] === 'accept'\r\n        ) {\r\n          this.submitClock();\r\n          // console.log('用户手动开启同意了，订阅消息');\r\n        } else {\r\n          this.$invoke('Toast', '__warning__', [\r\n            `您没有同意授权订阅消息，预约领取失败`\r\n          ]);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  guideOpenSubscribeMessage() {\r\n    //引导用户，手动引导用户去设置页开启，\r\n    this.$invoke('Modals', '__modalConfirm__', [\r\n      '检测到您没有开启订阅消息的权限，是否去设置？',\r\n      'openSetting',\r\n      //用户点击了确定按钮，进入设置页的回调\r\n      res => {\r\n        console.log('openSetting的回调数据：', res);\r\n        this.guidSubscribeMessageAuthAfter();\r\n      },\r\n      //用户点击了取消按钮\r\n      () => {\r\n        // console.log(\"取消了\")\r\n        this.$invoke('Toast', '__warning__', [\r\n          `您已拒绝订阅消息授权，无法预约领取`\r\n        ]);\r\n      }\r\n    ]);\r\n  }\r\n}结尾到这里，\twx.requestSubscribeMessage 的问题，也就得到了解决，看到网上有贴子在喷\trequestSubscribeMessage API的设计，比如：\twx.requestSubscribeMessage的接口参数结构设计反人性，实习生设计的吗？ ,其实我也想说这么庞大的一个生态体系，更新方案就考虑的这么不全面吗？还是说就是这么反人类？\tgetSetting 里给\trequestSubscribeMessage 的相关状态，\topenSetting 里又压根没有，然后又把它的引导开启逻辑UI也放在设置页里面，我就郁闷了，今天的分享，为我个人的解决思路方案，如有不足之处，请指出，勿喷～谢谢！！"}
{"title": "全平台（Vue、React、微信小程序）任意角度旋转 图片裁剪组件 ...", "author": "Rolan", "time": "2020-3-5 00:34", "content": "SimpleCrop 目前是 全网唯一 支持裁剪图片任意角度旋转、交互体验 媲美原生客户端 的 全平台 图片裁剪组件。项目地址： github.com/newbieYoung… 。特性及优势和目前流行的图片裁剪组件相比，其优势在于以下几点：裁剪图片支持任意角度旋转；支持 Script 标签、微信小程序、React、Vue 等多种开发模式；支持移动和 PC 设备；支持边界判断、当裁剪框里出现空白时，图片自动吸附至完全填满裁剪框；移动端缩放以双指中心为基准点；交互体验媲美原生客户端。示例微信小程序示例移动端示例左侧是 IOS 系统相册中原生的图片裁剪功能，右侧为 SimpleCrop 移动端示例。可以扫描二维码体验：或者访问以下链接：newbieyoung.github.io/Simple-Crop…PC 示例链接如下：newbieyoung.github.io/Simple-Crop…关键实现要实现 任意角度旋转 、 双指中心缩放 、 边界判断 、 自动吸附 等功能，关键点如下：1、屏幕坐标系和变换基准点在裁剪图片场景中，存在两个坐标系，其一是裁剪图片所代表的实际尺寸坐标系，其二是裁剪框显示到屏幕上所代表的屏幕坐标系；后续进行 transform 变换计算和位置判断时，为了计算方便，需要把裁剪图片的尺寸以及位置从实际坐标系转换为屏幕坐标系。另外当对裁剪图片进行 transform 变换时，变换基准点默认为其中心点，对应 CSS 的 transform-origin 为 50% 50%。2、获取实时坐标首先需要实时获取裁剪图片进行 CSS Transform 变换后的新坐标，只有在实时获取变换后的新坐标的前提下才能结合裁剪框坐标进行越界、吸附等判断；在计算 CSS Transform 变换后的新坐标时需要注意选取的屏幕坐标系和 CSS Transform 坐标系的差别，比如示例中以黑色边框中心为坐标原点，水平向左为 X 轴正方向，垂直向上为 Y 轴正方向；但是 CSS Transform 的坐标系垂直向下为 Y 轴正方向和上述规定的坐标系 Y 轴正方向是相反的，因此在获取 CSS Transform 变换矩阵之后求实时坐标时还需要进行镜像变换。详细计算过程可以查看 CSS3 2D Transform Matrix 。3、旋转适配缩放裁剪图片任意角度旋转时需要进行适当的放大才能保证裁剪框不超出，因此就需要先计算裁剪框哪些点超出，然后根据超出的点计算刚好包含的放大倍数。当两个矩形位置关系任意变换时计算相互之间有哪些点超出有两种方案：其一：图中左侧红色矩形代表裁剪图片，黑色矩形代表裁剪框，如图所示裁剪框顶点 A 超出了裁剪图片。连接矩形四个顶点和判断点，然后计算四条连线之间的夹角，如果夹角之和小于 360 度，那么该判断点在矩形外；反之如果夹角之和等于 360 度，那么该判断点在矩形内。a1 + a2 + a3 + a4 < 360\r\nb1 + b2 + b3 + b4 = 360\r\n复制代码其二：图中黑色矩形表示裁剪图片，点 A 表示裁剪框中超出裁剪图片的某个顶点。连接矩形中心点和判断点，然后计算中心点和判断点向量在矩形边框向量上的投影长度（L1、L2），只要两个投影长度中有任意投影长度大于其投影边框长度（H1、H2）的一半即说明该点在矩形外。另外还可以根据投影长度和其投影边框长度的比例计算出矩形恰好包含该点的放大系数，也就是示例图中的 S 变量。最后旋转图片时除了要进行适当的放大，保证裁剪框不超出以外，还可以在裁剪图片中心点没有变动时进行适当的缩小，去掉多余间隙，进一步提升交互体验。缩小系数的计算原理和放大系数的计算原理类似，均是连接判断点和中心点，然后根据边框投影长度计算。大矩形为裁剪图片，小矩形表示裁剪框，O 表示裁剪图片中心点。4、双指中心位移由于默认裁剪图片的变换基准点为其中心点，这么处理虽然计算方便，但是会对双指缩放造成一定的困难；因为双指操作时双指中心并不一定是裁剪图片中心。解决方案需要先求出两个不同基准点的位移差，然后在进行缩放变换之后再进行位移变换。5、缩放适配变换在旋转裁剪图片时可以对其进行适当得放大和缩小从而保证裁剪框不会超出裁剪图片；但是在双指操作缩放裁剪图片却不能这么做，因为适配缩放会和用户的操作缩放冲突，因此需要采用移动裁剪图片的方式保证裁剪框不超出裁剪图片。当裁剪图片进行位移变换之后可以包含裁剪框，就只需要计算位移向量；红色矩形为裁剪图片，黑色矩形为裁剪框。但是还有一种情况即裁剪图片进行位移变换之后不能包含裁剪框，如下：红色实线矩形为裁剪图片，黑色矩形为裁剪框，红色虚线矩形为进行放大之后恰好包含裁剪框的裁剪图片。此时说明用户的操作缩放超出了组件的合法限制范围，可以加入适配缩放了；这时候就需要先计算裁剪图片恰好包含裁剪框的放大系数，然后再进行位移变换。"}
{"title": "微信小程序上传图片至OSS的一些个人总结", "author": "Rolan", "time": "2020-3-5 00:42", "content": "这两天修改公司小程序的一些功能，发现上传图片至OSS失败，便一直寻找出现了什么问题，最后发现是policy过期，更改后发现相应的signature也要改，因为需要特定的处理才能生成signature，当时好一顿查资料，最后算出signature，在这里做一下总结，也借签了一位作者的文章。 https://segmentfault.com/a/11...首先，准备工作:1.下载Base64.js,hmac.js,sha1.js,crypto.js相关算法 点击 。2.创建一个用于计算的policy和signa的js文件，我们只要输出结果即可。我们起名为ceshi.js。3.在ceshi.js引入我们下载的4个算法文件。const Base64 = require('./Base64.js');\r\n\r\nrequire('./hmac.js');\r\nrequire('./sha1.js');\r\nconst Crypto = require('./crypto.js');一、先转码Policy在ceshi.jslet date = new Date();\r\n  date.setHours(date.getHours() + 87677);\r\n  let srcT = date.toISOString();\r\n  const policyText = {\r\n    \"expiration\": srcT, //设置该Policy的失效时间\r\n    \"conditions\": [\r\n      [\"content-length-range\", 0, 5 * 1024 * 1024] // 设置上传文件的大小限制,5mb\r\n    ]\r\n  };\r\n  const policyBase64 = Base64.encode(JSON.stringify(policyText));使用此js可计算出一个policy二、计算signatureconst accesskey = 'QSZ***98V1DW'; // 为了保密我做了处理，大家输入自己公司的accesskey即可。\r\n  const bytes = Crypto.HMAC(Crypto.SHA1, policyBase64, accesskey, {\r\n    asBytes: true\r\n  });\r\n  const signature = Crypto.util.bytesToBase64(bytes);\r\n  console.log(policyBase64);\r\n  console.log(\"myfunc....\");\r\n  console.log(signature);这样我们便可计算出signature啦。三、全部代码为ceshi.jsconst Base64 = require('./Base64.js');\r\n\r\nrequire('./hmac.js');\r\nrequire('./sha1.js');\r\nconst Crypto = require('./crypto.js');\r\nfunction myfunc() {\r\n  let date = new Date();\r\n  date.setHours(date.getHours() + 87677);\r\n  let srcT = date.toISOString();\r\n  console.log(srcT);\r\n  const policyText = {\r\n    \"expiration\": srcT, //设置该Policy的失效时间\r\n    \"conditions\": [\r\n      [\"content-length-range\", 0, 5 * 1024 * 1024] // 设置上传文件的大小限制,5mb\r\n    ]\r\n  };\r\n  const policyBase64 = Base64.encode(JSON.stringify(policyText));\r\n  const accesskey = 'QSZYryqudf8AAzyoAoJbeCIP98V1DW';\r\n  const bytes = Crypto.HMAC(Crypto.SHA1, policyBase64,    accesskey, {\r\n    asBytes: true\r\n  });\r\n  const signature = Crypto.util.bytesToBase64(bytes);\r\n  console.log(policyBase64);\r\n  console.log(\"myfunc....\");\r\n  console.log(signature);\r\n}\r\nmodule.exports.myfunc = myfunc;四、调用ceshi.js新建oss.jsconst ceshi = require('./ceshi.js');\r\nvar app = getApp()\r\nPage({\r\n  data: {\r\n  },\r\n  onLoad: function (options) {\r\n    ceshi.myfunc();\r\n  },\r\n  onReady: function () {\r\n  },\r\n  onShow: function () {\r\n  },\r\n  onHide: function () {\r\n  },\r\n  onUnload: function () {\r\n  },\r\n  onPullDownRefresh: function () {\r\n\r\n  },\r\n  onReachBottom: function () {\r\n  },\r\n  onShareAppMessage: function () {\r\n\r\n  }\r\n})五、文件目录六、结果以上是全部内容，感谢之前看过的相似文章，在此我自己做了相关总结，希望能帮大家解决问题！谢谢！"}
{"title": "iOS程序员上手微信小程序指南：含demo及工具下载", "author": "天下雪", "time": "2016-10-14 11:25", "content": "什么是微信小程序工具破解开始教程DEMO展示iOS开发如何应对微信小程序热潮本文主要摘录微信小程序工具破解和第一个Hello World DMEO，其他内容可以从 “阅读原文” 中获取什么是微信小程序及其学习价值微信小程序是一种全新的连接用户与服务的方式，可以在微信内被便捷地获取和传播，同时具有出色的使用体验。在微信的发现Tab中增加一个“小程序”入口，点开之后，会出现自己开启的小程序。来看下小程序提供哪些开发能力？视图容器：视图(View)、滚动视图、Swiper，图标、文本、进度条，按钮、表单等等操作反馈，导航媒体组件：音频、图片、视频，地图位置服务画布，文件操作能力网络：上传下载能力、WebSocket数据：数据缓存能力位置：获取位置、查看位置设备：网络状态、系统信息、重力感应、罗盘界面：设置导航条、导航、动画、绘图等等开放接口：登录，包括签名加密，用户信息、微信支付、模板消息一句话，App能做的事，它都能做，微信是通过weixin jssdk兑现这个承诺的。。小程序的体验和原生 app 几乎没有差异。。。（惊）工具破解开发工具 v0.7百度: https://pan.baidu.com/s/1pLxqFzH （密码: bwt9）360: https://yunpan.cn/ckvTYFHWzYYFV （提取码：e09b）开发工具 v0.9百度: https://pan.baidu.com/s/1pLTKIqJ （密码: iswg）360: https://yunpan.cn/ckvXjEbnFYMSC （提取码：f9ca）Demo源代码百度: https://pan.baidu.com/s/1o8hJFuU （密码: bsky）360: https://yunpan.cn/ckvXAacJjvsgR （提取码：3327）微信小程序开发文档：http://notedown.cn/weixin/api/ Mac测试可用，Windows测试可用下载开发工具，并安装（注意：一定要安装0.9版本）打开『微信Web开发者工具』的程序目录Windows：使用资源管理器查看Mac：右键点击图标，选择『显示包内容』进入程序目录后，替换以下文件（只需要替换0.9版本里的，0.7版本用来登陆）：替换文件下载请戳原文链接enjoy开始运行『微信Web开发者工具』通过微信扫描二维码创建项目AppID：随便填项目名称：随便填本地开发目录：选择一个目录点击「添加项目」此时如果出错，先退出再重进此时，能够看到项目列表了打开项目开始开发enjoyDEMO创建项目打开项目所在目录下载「Demo源代码」并解压覆盖打开项目Good luck"}
{"title": "梁兴臣:微信小程序开发三宗罪和解决方案", "author": "天下雪", "time": "2016-10-15 22:33", "content": "在微信公布小程序的文档和开发工具后，脉冲软件在第一时间进行了学习和体验，我们发现微信小程序的技术架构和开发体验让我们非常失望。由于微信小程序的运行环境并不是一个标准的浏览器环境，而且微信的封装工作并不完善，所以我们以往开发中的很多经验并不适用。这并非简单的开发习惯不适应，更重要的是我们的开发流程、规范将不适用。微信小程序开发第一宗罪: 无法调用NPM包虽然微信小程序开发工具打包时实现了require函数加载依赖，但并不是完整的CommonJS依赖管理。因为require函数仅仅能够加载项目中的JS文件，而且必须严格定义JS文件路径，路径不支持CommonJS的路径风格。例如如下加载方式都将出错：require('lodash');require('lodash/map');require('./foo');在微信小程序开发工具中，我们必须对应写为如下格式：require('node_modules/lodash/lodash.js');require('node_modules/lodash/map.js');require('./foo.js');虽然我们可以像上面代码一样加载node_modules目录中的库，但是实际运行时却发生了：在调试工具的Network选项卡中，我们看到运行时加载了1000多个文件，总数据量1.8MB，而我们仅仅是在代码中加载了一个lodash库而已！这是因为微信小程序开发工具会将所有项目下的js文件视为项目文件，并进行打包。而实际开发中，我们需要安装很多的NPM扩展库，而这些扩展库中有大量的不需要打包的文件，例如lodash中有上千文件，而我们只需要用到其中的非常少的一部分。另外，在开发中，我们往往需要安装babal、eslient、webpack、grunt等待开发工具，微信小程序开发工具会一视同仁将这些工具的源码也进行打包......实测开发者工具将崩溃！开发者将崩溃！我崩溃！所以不支持NPM包的原因，是微信开发者工具不支持CommonJS标准，不支持CommonJS标准的原因，是微信开发者工具想当然地认为项目目录下的js文件一定是项目文件，所以只实现了简单的require函数，想当然的原因是。。。微信小程序开发第二宗罪: 无法使用Babel转码无法使用Babel转码的原因其实仍然归结于无法加载NPM库。但是后果将十分严重。因为你将不能再安全使用ES6/7特性，你将无法使用async/await函数，你将和无尽的callback做斗争，你该怎样描述自己？回调地狱中的苦逼程序员？如果你看到这里不明白Babel为何物，那么祝贺你，因为不曾见过天堂就不知何为地狱，你无须为不支持ES6/7而烦恼。但一旦你的大脑支持了ES6/7，用过了Babel，你就回不去了，像我一样，无Babel不编码。微信小程序开发第三宗罪: 无法重用组件其实微信小程序开发是并非完全不能重用组件，比如WXML语法中支持import和 include。但是那仅仅是视图模板可重用，并非组件可重用，因为我们认为组件在应当包含视图和逻辑。WXML其实是基于可重用的组件，但是不允许我们自定义组件。如果你有React经验，你就会明白我的意思。例如，你的小程序是个电商APP，项目中有两个页面中同时包含了商品列表组件，比如某分类下商品列表和搜索结果列表，我们知道这两个列表其实仅仅是参数不同而已。但是在小程序开发中，你只能将列表的模板抽象出来，不能将逻辑抽象出来，所以你就需要在两个页面上都实现一遍列表组件的控制逻辑，比如刷新、加载更多。。。我们的实践只吐槽、管杀不管埋是不道德的，既然发现了微信小程序开发中的各种弊端，我们脉冲软件在开发之中总结出了一套流程和工具，专为解决上述三个问题，并免费发布到了开源社区，这就是Labrador。接下来我们一起来尝试一下我们脉冲软件的开发体验。安装Labrador通过命令 npm install -g labrador-cli 全局安装Labrador控制行工具。初始化项目通过如下命令新建一个Labrador项目：mkdir democd demonpm initlabrador init项目初始化完成后，该目录是这个样子的：图中的src是我们的源码目录，node_modules是NPM包目录，dist是目标输出目录。请在开发者工具中新建一个项目，并设置路径到dist目录，请勿设置为demo目录！使用WebStorm或Sublime打开demo目录，开发过程中，我们使用WebStorm或Sublime修改src目录下的源码，请勿直接修改dist目录中的文件，因为dist目录是通过labrador命令生成的。在demo目录中运行 labrador build 命令编译项目，该命令会将src目录下的文件一一处理并生成dist目录下对应的文件。我们也可以运行 labrador watch 命令监控src目录下的文件变化，这样就不用每次修改后手动运行编译命令。加载NPM包我们以lodash包为例，在src/app.js中键入代码 const _ = require('lodash'); 编译后，我们看到dist目录下的文件是这样的：我们看到dist目录下有一个npm/lodash目录，该目录下只有一个lodash.js文件，那么在微信web开发者工具中打包预览，lodash的库将只有这个文件被加载。这一切是怎么发生的？我们看一下dist/app.js的源码，发现源码中const _ = require('lodash'); 被编译为 var _ = require('./npm/lodash/lodash.js'); 然后labrador命令将node_modules/lodash/lodash.js 文件复制到了dist/npm/lodash/lodash.js 。这就是通过labrador可以调用NPM包的原理。重要的是，只有真正用到的js文件才被labrador命令加入到项目目录中。这样一个小小的改进象征着我们的小程序可以便捷调用NPM仓库中海量的扩展库！Babel转码在初始化的示例代码src/app.js中的内容是这样的：图中timer和getUserInfo属性都为async函数，函数体内使用await调用异步操作。labrador 库对微信API进行了封装，使用 const wx = require('labrador'); 覆盖默认的全局变量wx; 封装后的wx对象提供的异步方法返回的都是Promise异步对象，结合async/await函数彻底终结callback，将异步代码同步写，轻松逃离回调地狱！但目前async/await函数是不被浏览器支持的，我们需要使用babel对其转码，labrador编译命令已经内置了babel转码，转码后的代码可以查看dist/app.js，内容过长，不再张贴。重用组件重用组件最需要解决的问题是组件的逻辑代码怎样重用。在实例代码中有一个src/components目录，用来存放项目内的可重用组件，其结构是这样的：子目录src/components/list中存放着一个可重用的组件。list.js / list.less / list.xml 分别对应微信小程序的 js / wxss / wxml 文件。JS为控件的逻辑层，其代码如下：文件导出一个List类，这个组件类拥有像Page一样的生命周期函数onLoad, onReady, onShow, onHide, onUnload 以及setData函数。LESS文件对应微信的WXSS文件，因为微信小程序实现的限制，LESS中无法使用连级选择语法，但是可以定义变量，方便开发。XML文件对应微信的WXML文件，是组件视图描述文件，list.xml内容为：文件中导出一个名为list的template。组件不但可以存放在src/components目录内，还可以单独做成NPM包，这样就可以轻松做到跨项目间的组件共享。组件定义完成后，接下来是在页面中调用，在 src/pages/index/index.js 中有如下代码：代码中首先引入了labrador库替换全局的默认wx对象，并使用labrador.createPage方法代替全局的Page函数声明页面。然后加载List组件类，在页面声明配置中，增加了components属性，并将List组件类实例化传入。labrador.createPage方法是对Page方法的一层封装，目的是在页面初始化时和组件对象进行关联。在 src/pages/index/index.less 中加入代码 @import 'list' 即可调用list组件的样式，如果在src/components/list中找不到list.less，那么编译命令将在NPM包中寻找 node_modules/list/index.less 。在 src/pages/index/index.xml 中加入代码 <component key=\"list\"/> 即可调用list组件的模板文件，component 是Labrador自定义的组件，编译后对应生成 import 和 template。如果在src/components/list中找不到list.xml，那么编译命令将在NPM包中寻找 node_modules/list/index.xml"}
{"title": "微信小程序学习点滴《四》：网络请求", "author": "天下雪", "time": "2016-10-17 13:19", "content": "微信小程序开发中网络请求必不可少,今天说说最简单的请求.后续会尝试上传下载,Socket这些.1.一个微信小程序，同时只能有5个网络请求连接。这个规定应该是微信为了保证用户体验制定的,毕竟是小程序.2.wx.request(OBJECT)  参数说明:微信小程序支持GET,POST等请求.用method可以设置.以下是GET请求的代码://rate.js  //获取应用实例  var app = getApp()  Page( {    data: {      code: 'USD',      currencyF_Name: '',      currencyT_Name: '',      currencyF: '',      currencyT: '',      currencyFD: 1,      exchange: 0,      result: 0,      updateTime: '',    },    onLoad: function( options ) {      var that = this;        //获取汇率        wx.request( {          url: \"http://op.juhe.cn/onebox/exchange/currency?key=我的appkey&from=CNY&to=\"+code,          success: function( res ) {            that.setData( {              currencyF_Name: res.data.result[0].currencyF_Name,              currencyT_Name: res.data.result[0].currencyT_Name,              currencyF: res.data.result[0].currencyF,              currencyT: res.data.result[0].currencyT,              currencyFD: res.data.result[0].currencyFD,              exchange: res.data.result[0].exchange,              result: res.data.result[0].result,              updateTime: res.data.result[0].updateTime,            })          }        })    }  })上面代码中只需要给出URL即可,onLoad函数在页面初始化时启动,wx.request({})中success的res.data是从后台获取的数据,这一点需要注意.以下是获取的json数据的格式.json的解析都不需要自己做了.我做Android的时候还得用gson或者是fastjson来解析json.微信为我们解决了很多麻烦.微信小程序开发网络请求文档"}
{"title": "怎么在小程序里添加想要的QQ音乐", "author": "天下雪", "time": "2016-10-18 16:28", "content": "在玩Audio组件的时候，想放一首赵雷的《南方姑娘》，可是发现搜到的音乐链接都不是真正的外部链接，而是web播放器的链接，在小程序里根本播放不了。\r\n怎么办呢？他奶奶的。\r\n好在搜了一下怎么获得音乐的外部链接，有位大神给出了结果，而且相当于免费用绿钻了。\r\n好了，话不多说，步入正题。\r\n获取qq音乐外链方法：\r\nMP3接口 ,"}
{"title": "微信小程序开发常见问题分析", "author": "天下雪", "time": "2016-10-19 14:43", "content": "距离微信小程序内测版发布已经有十几天的时间了，网上对微信小程序的讨论也异常火爆，从发布到现在微信小程序一直占领着各种技术论坛的头条，当然各种平台也对微信小程序有新闻报道，毕竟腾讯在国内影响力还是很大的。我们都知道微信小程序第一天发布内测版，并没有公开官方开发文档和开发工具，但是这阻止不了技术人的好奇心。因为自己对小程序也是很有兴趣的，感觉是很有意思的一个东西，所以立马做了一下小demo，水平有限，所以做的过程也就是一个学习的过程，一个提高的过程。这篇文章主要写我在写demo的过程中遇到的一些问题。如果阅读此文的你有一定帮助，很是欣慰。一：项目结构微信小程序项目结构主要有四个文件类型,如下WXML （WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，js 逻辑处理，网络请求json 小程序设置，如页面注册，页面标题及tabBar。注意：为了方便开发者减少配置项，规定描述页面的这四个文件必须具有相同的路径与文件名。在根目录下用app来命名的这四中类型的文件，就是程序入口文件。app.json必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的window背景色，配置导航条样式，配置默认标题。app.js必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。app.wxss全局配置的样式文件，项目非必须。知道小程序基本文件结构，就可以开始研究官方demo了，研究过程中如果有不明白的地方可以去官方文档寻求答案，如果找不到答案或者有疑问，可再此博客留言，相互交流。下面介绍下出现概率较高的几个问题。二：常见问题rpx（responsive pixel）微信小程序新定义了一个尺寸单位，可以适配不同分辨率的屏幕，它规定屏幕宽为750rpx，如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。这个项目我用的都是rpx尺寸单位，期间遇到一个很奇葩的问题。在相邻的两条信息直接都会有一个分割线，我将线的高度都设置成1rpx,但是不有个别分割线是不显示的，如下图看到没在第一条和第二条直接并没有现实这条线，但是其他的都展示了，分割线的属性是一样的，而且在不同的手机上（分辨率不同）不显示的分割线也是不同的，有的分辨率好几条分割线都不显示，不知道这是模拟器的bug还是rpx的bug。最后分割线的高度尺寸单位使用了px,解决了这个问题。40013错误在微信小程序刚出来的时候如果输入AppID提示这个信息就表示没有破解，但是现在官方软件更新可以选择无AppID开发，如下图，我们之间选择无AppID，即可解决此错误。建议安装官方开发工具。可去此处找下载链接。4058错误微信小程序创建项目时选择无AppID，创建项目时会生成app.json，app.josn是程序启动最重要的文件，程序的页面注册，窗口设置，tab设置及网络请求时间设置都是在此文件下的。如果你创建的项目目录下没有app.json文件就会报下面的错误。我们看到上面的错误信息中有个数字-4058，这应该是初入微信小程序遇到最多的错误了，这种一般都是文件缺失，后面有个path，可以对着该路径看看是否存在这个文件。造成这种错误的原因一般都是创建项目选择的目录不正确，或者在app.json注册了一个不存在的页面。当然还有一种情况就是在app.json文件的pages注册的页面是没有创建的，或者你删除了某个页面，但是没有取消注册也会是-4058错误。Page注册错误这个错误可能很容易理解，页面注册错误。页面是通过Page对象来渲染的，每个页面对应的js文件必须要创建page，最简单的方式就是在js文件下写入Page({})，在page中有管理页面渲染的生命周期，以及数据处理，事件都在这完成。这个错误引起的原因一般都是刚创建页面，js文件还有有处理或者忘了处理。所以要养成创建页面的同时在js文件先创建Page的习惯.Page route错误字面意思就是页面路由错误，在微信中有两种路由方式一种是在wxml文件使用组件，一种是调 wx.navigateTo。如下代码：wxml文件：搜索js文件事件处理函数：bindtap:function(event){wx.navigateTo({url: “search/search”})}如果你这样写的话，恭喜你，你就会看到上面提示的错误，这是因为重复调用路由引起的，处理方法就是删除一个路由，删除组件或者删除wx.navigateTo。除了上面说的可能导致路由错误外，还有一种情况，类似于下面的代码<navigator url=\"search/search\">\r\n<navigator url=\"search/search\">\r\n<view class=\"serach_view_show\" bindtap=\"bindtap\"> 搜索</view>\r\n</navigator>\r\n</navigator>\r\n这种也是不允许的，也就是说组件内部不能再嵌套组件。它只能是单层存在的。Do not have * handler in current page.大概意思就是当前页面没有此处理，让确定是否已经定义，还指出了错误出现的可能位置pages/message/message,其实这种问题出现一般就是我们在wxml定义了一些处理事件，但是在js文件中没有实现这个时事件的处理方法，就会出现这个错误。那么我们按提示在js文件加上事件处理，如下代码，加上后就不会再有此错误提示。bindtap:function(event){\r\n  wx.navigateTo({\r\n    url: \"search/search\"\r\n  })\r\n},\r\ntabBar设置不显示对于tabBar不显示，原因有很多，查找这个错误直接去app.json这个文件，最常见的也是刚学习微信小程序最容易犯的错误无外乎下面几种注册页面即将页面写到app.json的pages字段中，如\"pages\":[\r\n   \"pages/message/message\",\r\n   \"pages/contact/contact\",\r\n   \"pages/dynamic/dynamic\",\r\n    \"pages/dynamic/music/music\",\r\n   \"pages/index/index\",\r\n   \"pages/logs/logs\"\r\n ]\r\ntabBar写法错误导致的不显示，将其中的大写字母B写成小写，导致tabBar不显示。tabBar的list中没有写pagePath字段，或者pagePath中的页面没有注册tabBar的list的pagePath指定的页面没有写在注册页面第一个。微信小程序的逻辑是”pages”中的第一个页面是首页，也就是程序启动后第一个显示的页面，如果tabBar的list的pagePath指定的页面都不是pages的第一个，当然也就不会电视tabBar了。tabBar的数量低于两项或者高于五项，微信官方中明确规定tabBar的至少两项最多五项。超过或者少于都不会显示tabBar。navigationBarTitle显示问题通过这个动态图你应该发现问题了，当点击音乐进入音乐界面时，title先显示了WeChatForQQ然后显示的音乐，这个体验肯定是难以接受的，原因是音乐界面的title是在js文件中page的生命周期方法中设置的。若你不了解生命周期，可以点击查看Page({data:{// text:”这是一个页面”},onLoad:function(options){// 页面初始化 options为页面跳转所带来的参数  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n    //NavigationBarTitle如果此处和json文件都设置，最后展示此处的标题栏\r\nwx.setNavigationBarTitle({\r\n  title: '音乐'\r\n})\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  }\r\n})\r\n通过注释你应该明白了，设置标题写在了onReady方法中，也就是页面已经渲染完成了，在onReady之前显示的title就是json文件（覆盖关系，如果在子页面json文件设置title会覆盖app.json全局设置）中的title。可能你会说将wx.setNavigationBarTitle写在onLoad函数中，不过如果这样设置是不对的，因为onLoad执行过后才渲染页面，在渲染页面时title会从json文件中读取，导致onLoad设置的title会只在页面渲染之前展示，之后就显示json文件的tile，所以现在你应该明白ttle设置最优的地方就是给子文件写一个json文件，在文件中写入，如果想改变颜色直接在文件中添加就可以，该文件所写的属性值会覆盖app.json中设置的值。{“navigationBarTitleText”: “音乐”}wx.navigateTo无法打开页面一个应用同时只能打开5个页面，当已经打开了5个页面之后，wx.navigateTo不能正常打开新页面。请避免多层级的交互方式，或者使用wx.redirectTo本地资源无法通过 css 获取background-image：可以使用网络图片，或者 base64，或者使用标签页面间数据传递微信小程序路由（页面跳转）是通过API wx.navigateTo或者wxml中组件实现的，不管哪种实现都会有一个重要的参数就是url，它指定了要跳转的页面，并且页面之间数据传递也是通过url来实现的，这个数据传递有点类似于我们使用的get网络请求，把参数都拼接在要跳转界面地址的后面并以“？”连接。然后将要传入的数据以键和值的形式追加在”?”后面，多个参数直接用”&”符合。如我们点击消息聊天记录，将列表上的数据传到下一个页面，可以这样写。<navigator url=\"/pages/dynamic/dynamic?title={{item.title}}&message={{item.message}}\">\r\n         <view class=\"item\" >\r\n            <view class=\"item-left\">\r\n                 <image src=\"{{item.url}}\" class=\"image\"/>\r\n            </view>\r\n            <view class=\"item-middle\">\r\n                 <view>\r\n                      <text class=\"title\">{{item.title}}</text>\r\n                 </view>\r\n                 <view>\r\n                     <text class=\"message\">{{item.message}}</text>\r\n                 </view>\r\n           </view>\r\n           <view class=\"item_right\">\r\n               <view><text class=\"time\">{{item.time}}</text></view>\r\n               <view class=\"mark\" wx:if=\"{{item.count>0}}\"><text class=\"text\">{{item.count}}</text></view>\r\n           </view>\r\n        </view>\r\n        <view  class=\"line\"></view>\r\n      </navigator>\r\n而数据接收是在js文件的page里接收的，page生命周期有一个onLoad函数，它就是做一些初始化数据的工作，onLoad函数有一个参数options，我们就可以通过key将数据获取，如下/**  作者：dushao\r\n *   新浪微博：http://weibo.com/dushaoxiaoxiao\r\n *   博客  :    http://www.takozhang.cn\r\n * */\r\n * \r\nPage({\r\n  data:{\r\n    // text:\"这是一个页面\"\r\n    isHiddenToast:true\r\n  }\r\n  onLoad:function(options){\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n    console.log(options.title)\r\n     console.log(options.message)\r\n\r\n  },\r\n  onReady:function(){\r\n    // 页面渲染完成\r\n  },\r\n  onShow:function(){\r\n    // 页面显示\r\n  },\r\n  onHide:function(){\r\n    // 页面隐藏\r\n  },\r\n  onUnload:function(){\r\n    // 页面关闭\r\n  },\r\n  bindtap:function(event){\r\nwx.navigateTo({\r\n  url: \"/pages/message/search/search\"\r\n})\r\n  },\r\n})\r\n这样就实现了页面间数据传递功能。"}
{"title": "秀杰实战教程系列《六》：服务端之用户注册与登录基于ThinkPHP5描述 ...", "author": "天下雪", "time": "2016-10-21 14:46", "content": "1.下载ThinkPHP 5.0.1：http://www.thinkphp.cn/down/855.html2.安装 解压到站点根目录http://localhost/thinkphp_5.0.1_core/public/访问，可以看到:) ThinkPHP V5 十年磨一剑 - 为API开发设计的高性能框架 [ V5.0 版本由 七牛云 独家赞助发布 ] 新手快速入门完全开发手册说明安装成功。以上url等同于http://localhost/thinkphp_5.0.1_core/public/index.php/index/index/index第一个index是模块名，第二个index是控制器名，第三个index是方法名出处参见config.php Line 60-673.用户登录控制器目标是我们需要一个如下的接口，供我们提交用户信息http://localhost/thinkphp_5.0.1_core/public/index.php/index/user/login参数：openid创建Controller稍加改造输出json格式header(\"Content-type: application/json\");无效！查看文档，需要改配置修改第36行4.用户登录模型5. 配置数据库信息进入database.php6. 建表7. 获取用户输入使用PostMan 测试输出\"灵犀网络\"字样8. 查询是否用户是否已经存在通过openid查询数据库，判断用户是否已经注册如有，返回用户的id,accessToken,username9. 插入新用户创建并返回用户信息10. json输入用户信息，供小程序本地缓存，主要是accessToken配置文件config.php指定了返回类型是json的话，不必通过$user->toArray()，即为纯净的array。而不是如下的对象格式。"}
{"title": "微信小程序开发教程第一章：微信小程序开发实操指南", "author": "admin", "time": "2016-10-12 22:49", "content": "序言开始开发应用号之前，先看看官方公布的「小程序」教程吧！（以下内容来自微信官方公布的「小程序」开发指南）本文档将带你一步步创建完成一个微信小程序，并可以在手机上体验该小程序的实际效果。这个小程序的首页将会显示欢迎语以及当前用户的微信头像，点击头像，可以在新开的页面中查看当前小程序的启动日志。1. 获取微信小程序的 AppID首先，我们需要拥有一个帐号，如果你能看到该文档，我们应当已经邀请并为你创建好一个帐号。注意不可直接使用服务号或订阅号的 AppID。 利用提供的帐号，登录 https://mp.weixin.qq.com ，就可以在网站的「设置」-「开发者设置」中，查看到微信小程序的 AppID 了。注意：如果我们不是用注册时绑定的管理员微信号，在手机上体验该小程序。那么我们还需要操作「绑定开发者」。即在「用户身份 - 开发者」模块，绑定上需要体验该小程序的微信号。本教程默认注册帐号、体验都是使用管理员微信号。2. 创建项目我们需要通过开发者工具，来完成小程序创建和代码编辑。开发者工具安装完成后，打开并使用微信扫码登录。选择创建「项目」，填入上文获取到的 AppID，设置一个本地项目的名称（非小程序名称），比如「我的第一个项目」，并选择一个本地的文件夹作为代码存储的目录，点击「新建项目」就可以了。为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择「是」，开发者工具会帮助我们在开发目录里生成一个简单的 demo。项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在「编辑」里可以查看和编辑我们的代码，在「调试」里可以测试代码并模拟小程序在微信客户端效果，在「项目」里可以发送到手机里预览实际效果。3. 编写代码点击开发者工具左侧导航的「编辑」，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js 后缀的是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。下面我们简单了解这三个文件的功能，方便修改以及从头开发自己的微信小程序。app.js 是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用 MINA 提供的丰富的 API，如本例的同步存储及同步读取本地数据。```//app.jsApp({onLaunch: function () {// 调用 API 从本地缓存中获取数据var logs = wx.getStorageSync('logs') || []logs.unshift(Date.now())wx.setStorageSync('logs', logs)},getUserInfo:function(cb){var that = this;if(this.globalData.userInfo){typeof cb == \"function\" && cb(this.globalData.userInfo)}else{// 调用登录接口wx.login({success: function () {wx.getUserInfo({success: function (res) {that.globalData.userInfo = res.userInfo;typeof cb == \"function\" && cb(that.globalData.userInfo)}})}});}},globalData:{userInfo:null}})```app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口 背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。```{\"pages\":[\"pages/index/index\",\"pages/logs/logs\"],\"window\":{\"backgroundTextStyle\":\"light\",\"navigationBarBackgroundColor\": \"#fff\",\"navigationBarTitleText\": \"WeChat\",\"navigationBarTextStyle\":\"black\"}}```app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。```/**app.wxss**/.container {height: 100%;display: flex;flex-direction: column;align-items: center;justify-content: space-between;padding: 200rpx 0;box-sizing: border-box;}```### 4. 创建页面在这个教程里，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径 + 页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js 后缀的文件是脚本文件，.json 后缀的文件是配置文件，.wxss 后缀的是样式表文件，.wxml 后缀的文件是页面结构文件。index.wxml 是页面的结构文件：```{{userInfo.nickName}}{{motto}}```本例中使用了 、、 来搭建页面结构，绑定数据和交互处理函数。index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。```//index.js// 获取应用实例var app = getApp()Page({data: {motto: 'Hello World',userInfo: {}},// 事件处理函数bindViewTap: function() {wx.navigateTo({url: '../logs/logs'})},onLoad: function () {console.log('onLoad')var that = this// 调用应用实例的方法获取全局数据app.getUserInfo(function(userInfo){// 更新数据that.setData({userInfo:userInfo})})}})```index.wxss 是页面的样式表：```/**index.wxss**/.userinfo {display: flex;flex-direction: column;align-items: center;}.userinfo-avatar {width: 128rpx;height: 128rpx;margin: 20rpx;border-radius: 50%;}.userinfo-nickname {color: #aaa;}.usermotto {margin-top: 200px;}```页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。index.json 是页面的配置文件：页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。**logs 的页面结构**```{{index + 1}}. {{log}}```logs 页面使用 控制标签来组织代码，在 上使用 wx:for-items 绑定 logs 数据，并将 logs 数据循环展开节点//logs.jsvar util = require('../../utils/util.js')Page({data: {logs: []},onLoad: function () {this.setData({logs: (wx.getStorageSync('logs') || []).map(function (log) {return util.formatTime(new Date(log))})})}})运行结果如下：5. 手机预览开发者工具左侧菜单栏选择「项目」，点击「预览」，扫码后即可在微信客户端中体验。目前，预览和上传功能尚无法实现，需要等待微信官方的下一步更新。如你所见，微信官方给出的开发指南还非常简单，很多细节、代码和功能都没有明确的展示，所以接下来就到博卡君展示实力的时候啦！开发教程正式开始！第一章：准备工作做好准备工作很重要。开发一个微信应用号，你需要提前到微信的官方网站（weixin.qq.com）下载开发者工具。* 下载最新微信开发者工具，打开后你会看到该界面：* 点击「新建 web+」项目，随后出现如下画面：* 该页面内的各项内容需要注意——* AppID：依照官方解释来填。* Appname: 项目最外层文件夹名称，如你将其命名为「ABC」，则之后的全部项目内容均将保存在「/ABC/…」目录下。* 本地开发目录：项目存放在本地的目录。注：再次强调，如果你和团队成员共同开发该项目，则建议你们使用同样的目录名称及本地目录，以确保协同开发的统一性。如果你之前已有项目，则导入过程与以上内容近似，不再赘述。* 准备工作全部完成后，点击「新建项目」按钮，弹出框点「确定」。* 如上图所示，此刻，微信开发者工具已经为你自动构建了一个初始的 demo 项目，该项目内包含了一个微信应用项目所需具备的基本内容和框架结构。点击项目名称（图中即「cards」）进入该项目，就能看到整个项目的基本架构了："}
{"title": "微信小程序开发教程第二章：项目构架", "author": "admin", "time": "2016-10-12 23:08", "content": "微信目前用户群体非常庞大，微信推出公众号以后，火爆程度大家都看得到，也同样推动着 h5 的高速发展，随着公众号业务的需求越来越复杂，应用号现在的到来也是恰到好处。我们团队具体看了一两次文档后发现，它提供给开发者的方式也在发生全面的改变，从操作 DOM 转为操作数据，基于微信提供的一个过桥工具实现很多 h5 在公众号很难实现的功能，有点类似于 hybrid 开发，不同于 hybrid 开发的方式是：微信开放的接口更为严谨，结构必须采用他提供给我们的组件，外部的框架和插件都不能在这里使用上，让开发者完全脱离操作 DOM，开发思想转变很大。工欲善其事，必先利其器。理解它的核心功能非常重要，先了解它的整个运作流程。生命周期：在index.js里面：开发者工具上 Console 可以看到：在首页 console 可以看出顺序是 App Launch-->App Show-->onload-->onShow-->onReady。首先是整个 app 的启动与显示，app 的启动在 app.js 里面可以配置，其次再进入到各个页面的加载显示等等。可以想象到这里可以处理很多东西了，如加载框之类的都可以实现等等。路由：路由在项目开发中一直是个核心点，在这里其实微信对路由的介绍很少，可见微信在路由方面经过很好的封装，也提供三个跳转方法。* wx.navigateTo(OBJECT)：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。* wx.redirectTo(OBJECT)：关闭当前页面，跳转到应用内的某个页面。* wx.navigateBack()：关闭当前页面，回退前一页面。这三个基本上使用足够，在路由方面微信封装的很好，开发者根本不用去配置路由，往往很多框架在路由方面配置很繁琐。组件：此次微信在组件提供方面也是非常全面，基本上满足项目需求，故而开发速度非常快，开发前可以认真浏览几次，开发效率会很好。其它：任何外部框架以及插件基本上无法使用，就算原生的 js 插件也很难使用，因为以前我们的 js 插件也基本上全部是一操作 dom 的形式存在，而微信应用号此次的架构是不允许操作任何 dom，就连以前我们习惯使用的动态设置的 rem.js 也是不支持的。此次微信还提供了 WebSocket，就可以直接利用它做聊天，可以开发的空间非常大。跟公众号对比我们发现，开发应用号组件化，结构化，多样化。新大陆总是充满着惊喜，更多的彩蛋等着大家来发现。接下来开始搞一些简单的代码了！* 找到项目文件夹，导入你的编辑器里面。在这里，我使用了 Sublime Text 编辑器。你可以根据自己的开发习惯选择自己喜欢的编辑器。* 接下来，你需要根据自己的项目内容调整项目结构。在范例项目中，「card_course」目录下面主要包含了「tabBar」页面以及该应用的一些配置文件。* 示例项目的「tabBar」是五个菜单按钮：* 找到「app.json」文件，用来配置这个五个菜单。在代码行中找到「tabBar」：* 你可以根据实际项目需求更改，其中：* 「Color」是底部字体颜色，「selectedColor」是切换到该页面高亮颜色，「borderStyle」是切换菜单上面的一条线的颜色，「backgroundColor」是底部菜单栏背景颜色。文字描述较为抽象，建议你一一调试并查看其效果，加深印象。* 「“list”」下的代码顺序必须依次放置，不能随便更改。* 「”pagePath”」之后的文件名内，「.wxml」后缀被隐藏起来了，这是微信开发代码中人性化的一点——帮你节约写代码的时间，无须频繁声明文件后缀。* 「”iconPath”」为未获得显示页面的图标路径，这两个路径可以直接是网络图标。* 「”selectedIconPath”」为当前显示页面高亮图标路径，可以去掉，去掉之后会默认显示为「”iconPath”」的图标。* 「”Text”」为页面标题，也可以去掉，去掉之后纯显示图标，如只去掉其中一个，该位置会被占用。注意：微信的底部菜单最多支持五栏（五个 icons），所以在你设计微信应用的 UI 和基本架构时就要预先考虑好菜单栏的排布。* 根据以上代码规则，我做好了示例项目的基本架构，供你参考：* 「Json」文件配置好后，「card_course」的基本结构入上图所示，不需要的子集都可以暂时删除，缺少的子集则需要你主动新建。删除子集时记得顺带检查一下「app.json」里的相关内容是否已经一并删除。注意：我个人建议你新建一个「wxml」文件的同时，把对应的「js」和「wxss」文件一起新建好，因为微信应用号的配置特点就是解析到一个「wxml」文件时，会同时在同级目录下找到同文件名的「js」和「wxss」文件，所以「js」文件需及时在「app.json」里预先配置好。编写「wxml」时，根据微信应用号提供的接口编码即可，大部分就是以前的「div」，而我们现在就用「view」即可。需要用其它子集时，可以根据微信提供的接口酌情选择。使用「class」名来设置样式，「id」名在这里基本没有什么用处。主要操作数据，不操作「dom」。* 以上是示例项目首页的「wxml」编码。从图中就可以看出，实现一个页面代码量非常少。* 「Wxss」文件是引入的样式文件，你也可以直接在里面写样式，示例中采用的是引入方式：* 修改代码后刷新一次，可以看到未设背景的「view」标签直接变成了粉色。注意：修改「wxml」和「wxss」下的内容后，直接 F5 刷新就能直接看到效果，修改「js」则需点击重启按钮才能看到效果。* 另外，公共样式可以在「app.wxss」里直接引用。* 「Js」文件需要在「app.json」文件的「”page”」里预先配置好。为了项目结构清晰化，我在示例项目中的「index」首页同级目录新建其它四个页面文件，具体如下：经过以上步骤，案例中的五个底部菜单就全部配置完毕了。"}
{"title": "微信小程序开发教程第三章：项目结构以及配置", "author": "admin", "time": "2016-10-12 23:22", "content": "找到创建的 demo 文件夹，把项目导入到你的编辑器，这里使用的是Sublime Text编辑器。这个时候需要根据自己的项目需求结构进行更改了，项目根目录下面是首页渲染的几个 tabBar 页面，以及 app 的一些配置文件，如名片盒项目的 tabBar 是 3 个切换菜单我们先找到 app.json 文件打开配置好这几个菜单，配置好 tabBar，这个直接把配置文件改成你自己设计的即可。App.json 里面有几个配置项：* Pages：这个是编写的js文件，后缀.js这里不需要使用，配置好正确路径即可正常调用（若调用不到，在重启微信开发者工具会直接报 page 错误）。* Window：配置顶部的一些样式，文档介绍比较详细。* tabBar：底部的几项配置，见名知意。* networkTimeout：暂时没发现用处，建议看文档。根据实际项目需求进行添加与更改。* iconPath和selectedIconPath：底部菜单按钮图片与得到切换点击高亮。* text：可以去掉，全部去掉会发现底部 tabar 高度会减少很多。 Json 文件配置好后，根据项目进行文件创建。Demo：存放的是假数据，这一期的开发工具支持 require，假数据使用的是 .js 文件形式，里面的数据结构 json 一致，把 data 暴露出去即可然后取数据 require 进来即可，这一点使用很方便；Images：图片路径；Page：除 tabar 以外的页面；Servise：服务交付层（与后台联调真实数据时使用）；Wxss：一些公共的 css 文件；看到这里大家发现每个页面都被连带好三个不同的后缀。分别页面，css，js 目前只能依照这样，是微信应用号的一个规范吧。Wxss 文件是引入你写的样式文件，也可以直接在里面写样式。Js 文件需全部配置到 pages 里面才能生效。"}
{"title": "微信小程序开发教程第四章：首页面开发", "author": "admin", "time": "2016-10-12 23:26", "content": "进行了各种准备与配置后，来到首页开发。首先需要实现首页效果图如下：Template 名片很多，需要用模板、这里需要微信提供的基础组件大致是 input（搜索框）、action-sheet（右边是个底部下拉菜单，需要下拉菜单）、Scroll-view (右边 ABC 跳转)、（这个目前实现还有点问题，正在攻克中）。View是块元素，整个搜索框的一个样式。* 名片夹：由于该项目主打名片功能，故很多地方使用，所以需要把名片以 template 分离出来。* Template：定义一个模板，name 模板的名字其实是个作用域。* Block：循环控制，名片很多，必须用循环出来，和很多操作数据的前端框架循环差不多。* 支持自定义属性 data，这里用作判断线上名片以及线下名片。* View 里面是一些数据引入，里面是支持三目运算符。引入 template 时非常方便，is 和 name 一样，data 是 nameData 传递过来的数据填充。一切都绑定数据为中心点。取到数据具体操作根据你数据结构：这里的数据结构和 json 数据结构一样，这里如要传到页面的话即是```this.setData({nameData:card_list_name.data.cards,timeData:card_list_time.data.cards});```因为页面遍历的是 nameData,timeData可以看下打印出来的数据结构，根据你的结构进行解析与传递。也可以看下这里对数据的一些操作。（这里须根据定义的 json 数据格式来操作的）名片的样式由于很多页面需要使用放在 common.css 里面，这个 common.css 是所有页面都需要用到，一些初始化设置。它是在 app.wxss 里面引用之后才能被映射到全局 APP。搜索框：其中 bindChange 为输入框发生改变事件。微信提供的 bindchange 在支持方面还有小问题，目前是失去焦点才能触发到此事件的发生，待后续完善吧，先实现功能再说。在 index.js 里面写事件```bindInputChange:function(e){//发生搜索事情var self = this; //this绑定，这个this指向微信的提供windowvar Text = e.detail.value.toUpperCase(); //取到输入的内容if(Text==\"\"){ //如果输入为空 一些东西需要显示 否则不显示show_letter = \"block\";}else{show_letter = \"none\";}this.setData({show_letter:show_letter,showSheet:true});var res = nameData; 获取到传递的数据if(data_type==\"name\"){}else if(data_type==\"time\"){res = timeData; };for(var k in res){ //for-in循环取到data里面的cardsvar data = res[k].cards;for(var i = 0;iIf(data[i].userName!=null && data[i].userName.indexOf(Text)!=-1){data[i][\"display\"] = \"block\"; //存在就是赋值显示}else{data[i][\"display\"] = \"none\"; // 不存在赋值不显示}}}}```菜单栏：做到菜单栏，使用微信提供的下拉菜单组件 action-sheet，它被触发的条件在这里。一切以绑定事件为起点：```bindButtonTapSheet:function(e){//调取底部下拉菜单栏}```还是得先布好局才能被调动Js 配置：Data 初始化数据：这里得取非，直接设置 false 调不出来: 调用事件。调出来还得去掉它啊：如下相同即可取消直接上事件即可。（分为菜单栏外部与底部）//好了，就是这么简单。实现效果简单，体验效果确实非常不错。还需要个 loading 效果（暂时没做动画，后期再考虑。）Loading 布局首页的最外层 view根据微信的生命周期```Onload:function(e){this.setData({toastDisplay:”block”,htmlWrapDisplay:”none”})},onShow:function(e){this.setData({toastDisplay:”none”,htmlWrapDisplay:”block”})}```加载条完成。扫一扫，直接调用拍照功能，从这里看到微信提供的拍照 api 使用起来非常快速，只需根据需求配置即可。点击扫一扫之后，在开发者工具即可看到如下效果。做到这里说明下，dom 长度有限制，页面的结构太长，也是无法渲染的，暂且把公司排序暂时先去掉了。左边的 ABC 跳转（还在继续完善中）。这里还有个左滑删除名片功能，微信没有提供这个在移动端很实用的功能真的比较遗憾"}
